#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <stdlib.h>
#include <setjmp.h>
#include <time.h>
#include <sys/time.h>
#include <unistd.h>
#include <math.h>
#include <ctype.h>

/* This file was generated by QuasiBASIC to C translator */
/* qb2c  ver.4.14 27.Oct 1999                            */

#define LMAX 1023 /* Max strig length */
#define NSMX 127   /* Max no of SUBroutines */
#define NTKM 30   /* Max no of lines per phys. line */
#define GMAX 16   /* Max level of nesting GOSUBs */
#define NCMX 30   /* Max number of CONSTants */
#define CMAX 127   /* Max number of CH and CM lines (-C flag on) */
#define OPNX 20   /* Max number of file pointers */
#define IOPN 20   /* Max number of opened I/O ports */
#define TMAX 140   /* Max dimension of tmp$() */
#define NDAT 256   /* Max number of DATA lines */
#define NDYN 50   /* Max number of dynamically declared array */
#define MARR 80   /* Max number of arrays in MAIN */
#define SHMX 40   /* Max total number of SHARED arrays */
static int jrplc_int = 15, jnfun_int = 30, NFUN = 41, log_1, log_2;
static char *rplc_S[] = {"CINT",   "INT",    "ABS", "ATN", "SQR",
                         "LOG",    "SIN",    "COS",    "TAN",   "EXP",
                         "DATE$",  "TIME$",  "TIMER", "RND",
                         "INKEY$", "INP(",
                         "SPACE$", "RIGHT$", "LEFT$",  "MID$",
                         "STR$",   "CHR$",   "ASC",    "VAL",
                         "MIN", "MAX",
                         "LEN",    "SGN",    "EOF",  "LOF", "EXISTS",
                         "RANDOMIZE", "SHELL",  "COMMAND$",
                         "LCASE$", "UCASE$", "ENVIRON$", "HEX$", "OCT$",
                         "STRING$", "XLEN", "DATA"};
  static char def__str[26];
  static char def__int[26];
  static char def__dbl[26];

/* Function declarations */
extern char  *SPACE_S(int);
extern char  *MID_S(char *, int, int);
extern char  *LEFT_S(char *, int);
extern char  *RIGHT_S(char *, int);
extern char  *STR_S(double);
extern char  *CHR_S(int);
extern long   ASC(char *);
extern double VAL(char *);
extern int    LEN(char *);
extern long   Nint(double);
extern int    eof(FILE *);
extern char  *COMMAND_S(int, char *argv_S[]);
extern void    RANDOMIZE(long);
extern double  TIMER(void);
extern double DBL(double);
extern char  *TIME_S(int);

/* Shared variables and arrays declarations */
static jmp_buf j__buf[ 16 ];
static int  j__lev=0;
static char  tmp_S[TMAX+1][LMAX];
static int   statfl_int[NSMX+1];
static char  atmp_S[51][80+1];
static char  dyna_S[NSMX+1][NDYN+1][40+1];
static int   ndyna_int[NSMX+1];
static char  temp_S[11][LMAX];
static char  tcnst_S[NCMX+1][80+1];
static char   w__S[16][LMAX];
static int    j__S = 0, j__Stmp;
static int    w__s[16];
static int    i__s = 0, i__stmp;
static long   w__l[16];
static int    i__l = 0, i__ltmp;
static double w__d[16];
static int    i__d = 0, i__dtmp;
static char tws__S[LMAX];
static int  isub_int, ni_int, nl_int, bwfl_int, mathfl_int, mflg_int;
static int  expflg_int, extrnfl_int, vdblff_int, nptk_int, defstr_int;
static int  spacff_int, midff_int, leftff_int, rightff_int, strff_int;
static int  chrff_int, ascff_int, valff_int, lenff_int, sgnff_int;
static int  intff_int, nintff_int, eofff_int, commff_int, rndff_int;
static int  srndff_int, timerff_int, dateff_int, timeff_int, inkeyff_int;
static int  inputff_int, colorff_int, clsff_int, lcaseff_int, ucaseff_int;
static int  envff_int, lofff_int, hexff_int, octff_int, SScan_int;
static int  stringf_int, datalin_int, txlen_int, usingff_int, tflg_int;
static int  existff_int, Iflag_int, natmp_int, Arrfl_int, stripff_int;
static int  intflg_int, Dflg_int, doblflg_int, longflg_int, constfl_int;
static int  ncnst_int, defint_int, defdbl_int;
static char spc_S[LMAX], line_S[LMAX];

/* Open files pointers */
FILE *fp_2, *fp_1, *fp_3;
char fn2__S[160], fn1__S[160], fn3__S[160];

main(int n_arg_int, char *argv_S[])
{
 static int  nfuncs_int, nSHRDtk_int, lspac_int, nsub_int, jopn_int;
 static int  nlopen_int, signal_int, endmain_int, usersub_int, initline_int;
 static int  lastline_int, chartfl_int, longtfl_int, floattfl_int;
 static int  inttfl_int, byttfl_int, ncg_int, ncm_int, nlmax_int, tmpfl_int;
 static int  i_int, itok_int, commfl_int, nopen_int, niopen_int, g_int;
 static int  n_int, j_int, togfl_int, funcflag_int, timefl_int;
 static int  systimefl_int, unistdfl_int, pausefl_int, twsflg_int;
 static int  sigiff_int, xwflag_int, minff_int, maxff_int, grafflg_int;
 static int  readff_int, lleng_int, nvar_int, retrnfl_int, xtmpfl_int;
 static int  flag_int, ii_int, k_int, jflg_int, typ_int, leng_int, L_int;
 static int  brcnt_int, jsub_int, narr_int, alis_int, deffnf_int;
 static int  datacnt_int, ntok_int, lremfl_int, thnfl_int, dflag_int;
 static int  jj_int, i1_int, i2_int, nflag_int, tmp1_int, tmp2_int;
 static int  tmp3_int, tmp4_int, tmp8_int, minusf_int, tip_int, ix0_int;
 static int  fcond_int, lmid_int, lbfl_int, lz_int, c64flg_int, postflg_int;
 static int  cflag_int, bcppflg_int, ansiflg_int, noshell_int, updateff_int;
 static int  debug_int, Lmax_int, prnfl_int, colorfl_int, rflag_int;
 static float T0, x, rflag;
 static char c_S[LMAX], Version_S[LMAX], fff_S[LMAX], fns_S[LMAX];
 static char shred_S[LMAX], b_S[LMAX], tmpfile_S[LMAX], tmpfil0_S[LMAX];
 static char int_S[LMAX], float_S[LMAX], a_S[LMAX], d_S[LMAX], n_S[LMAX];
 static char fn_S[LMAX], funcnam_S[LMAX], shtmp_S[LMAX], e_S[LMAX];
 static char fime_S[LMAX], z_S[LMAX], rea_S[LMAX], sss_S[LMAX], lon_S[LMAX];
 static char dbl_S[LMAX], byt_S[LMAX], sho_S[LMAX], varlist_S[LMAX];
 static char inpf_S[LMAX], sint_S[LMAX], srea_S[LMAX], ssss_S[LMAX];
 static char slin_S[LMAX], sdbl_S[LMAX], t_S[LMAX], f_S[LMAX], prtf_S[LMAX];
 static char formt_S[LMAX], prt_S[LMAX], using_S[LMAX], labl_S[LMAX];
 static char mode_S[LMAX], access_S[LMAX], Len_S[LMAX], siz_S[LMAX];
 static char enc_S[LMAX], fam_S[LMAX], optim_S[LMAX], outf_S[LMAX];
 static char ime_S[LMAX], bcp_S[LMAX];
 static long g_long;
 static char c;

 /*  qb2c-3.40 free QuasiBASIC to C converter, first version: 04/04/1996 */
 /*  This is (itself !) a QB2C code. Translate it with: qb2c -c qb2c */


 static int   tmp_int[17];   /* for various temporary use (eg. 600,...) */
 static int   tok_int[NTKM+1];   /* Used in (spliter 900) */
 static char  shrd_S[201][80+1];   /* contains list of all SHARED variables and arrays */
 static char  shtok_S[NSMX+1][TMAX+1][80+1];   /* SHARED variables and arrays storage */
 static int   nshtok_int[NSMX+1];   /* Max second index in shtok$(,) and statfl%() */
 static char  linetok_S[NTKM+1][LMAX];   /* Line tokens (spliter 900) */
 static char  cnst_S[NCMX+1][80+1];   /* global CONST-ant declarations */
 static char  vari_S[NSMX+1][LMAX];   /* Declaration strings. Toliko subrutina max. */
 static char  varr_S[NSMX+1][LMAX];
 static char  vars_S[NSMX+1][LMAX];
 static char  varl_S[NSMX+1][LMAX];
 static char  vard_S[NSMX+1][LMAX];
 static char  varb_S[NSMX+1][LMAX];
 static char  vash_S[NSMX+1][LMAX];
 static int   fopen_int[OPNX+1];   /* open file logical numbers, 0..nopen% */
 static char  fio_S[IOPN+1][80+1];   /* fast access I/O port logical numbers, 1..niopen% */
 static char  lfopen_S[OPNX+1+1][LMAX];
 static int   lfopen_int[OPNX+1+1];
 static char  subvar_S[NSMX+1][22][255+1];   /* Lists of arguments of all SUBs */
 static int   nsubvar_int[NSMX+1];
 static char  subname_S[NSMX+1][LMAX];   /* user SUB names */
 static char  vlist_S[NSMX+1][201][80+1];   /* List of local variables */
 static int   nvlist_int[NSMX+1];
 static char  funames_S[NSMX+1][80+1];   /* Names of user FUNCTIONs */
 static char  funtyl_S[NSMX+1][LMAX];   /* variable type lists for FUNCTION declaration */
 static int   funcfl_int[NSMX+1];   /* funcfl%(i) set to 1 if i-th sub is a FUNCTION */
 static char  darr_S[MARR+1][80+1];   /* list of SHARED arrays which are used in MAIN, and respective DYNAMIC flags (set if dynamic) */
 static int   alist_int[SHMX+1];   /* list of SHARED arrays which are used in MAIN, and respective DYNAMIC flags (set if dynamic) */
 static short dynaf__int[MARR+1];   /* list of SHARED arrays which are used in MAIN, and respective DYNAMIC flags (set if dynamic) */
 static char  atyp_S[9][LMAX];
 static char  cg_S[CMAX+1][1000+1];   /* global and MAIN declarations */
 static char  cm_S[CMAX+1][1000+1];   /* global and MAIN declarations */
 static char  data_S[NDAT+1][256+1];   /* Storage for DATA block */
 n_arg_int--;

 strcpy(c_S,COMMAND_S(n_arg_int, argv_S));
 T0 = TIMER();
 strcpy(Version_S,"3.41 Free Version 04 May 2000\nCheck out the Pay version at http://random.com.hr/products/");
 /* From 4.14 */
 strcpy(fff_S,"");   /* contains *fp pointers of all SUBs and MAIN */
 strcpy(fns_S,"");   /* contains storage names for all open files */
 statfl_int[0] = 1;   /* variables in MAIN are always static */
 nfuncs_int = 0;   /* Number of user FUNCTIONs */
 nSHRDtk_int = 0;   /* Number of global SHARED variables */
 strcpy(shred_S,"");   /* all shared variables string */
 lspac_int = 1;   /* Left margin level counter */
 strcpy(spc_S,SPACE_S(lspac_int));
 nsub_int = 0;   /* Number of subroutines */
 jopn_int = 0;   /* translation-time 'OPEN' counter */
 nlopen_int = 0;   /* dynamic last-OPEN-file counter */
 expflg_int = 0;   /* Pure expression ( x = ... ) flag ( for -m, see mathexp ) */
 signal_int = 0;   /* If set, exit with signal */
 endmain_int = 0;   /* If set, main translator has passed the end of MAIN */
 usersub_int = 0;   /* User SUB or FUNCTION usage flag */
 initline_int = 0;   /* for initialization commands which appear in MAIN */
 ni_int = 0;
 lastline_int = 0;   /* Last line of the MAIN program, filled in 650 */
 chartfl_int = 0;
 longtfl_int = 0;
 floattfl_int = 0;
 inttfl_int = 0;
 byttfl_int = 0;
 ncg_int = 0;   /* number of global and MAIN declarations */
 ncm_int = 0;
 strcpy(b_S,TIME_S(0));
 sprintf(tmpfile_S,"%s%s%s","tmp",MID_S(b_S, 3, LMAX),".b2c");
  tmpfile_S[3]=tmpfile_S[6]='-';
 strcpy(tmpfil0_S,tmpfile_S);
  tmpfil0_S[6]='_';
 strcpy(atyp_S[0],"short ");
 strcpy(atyp_S[1],"int   ");
 strcpy(atyp_S[2],"long  ");
 strcpy(atyp_S[3],"float ");
 strcpy(atyp_S[4],"double ");
 strcpy(atyp_S[5],"char  ");
 strcpy(atyp_S[8],"unsigned char ");
 strcpy(atyp_S[9],"short ");
 /* ENVIRON  "BCC_OPTIONS" = "": optim$ = "" */

 /* GOSUB Lab_50000 */    /* tokenization of command$ */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_50000;
 /* Order of the two below is IMPORTANT */
 if(debug_int)
 {
  printf("%-14s% .7G \n","entering 800: ",(double)(TIMER() - T0));
 }
 /* GOSUB Lab_800 */    /* preprocessing global SHARED variables */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_800;
 if(debug_int)
 {
  printf("%-14s% .7G \n","entering 700: ",(double)(TIMER() - T0));
 }
 /* GOSUB Lab_700 */    /* preprocessing for variable types in SUB's */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_700;
 if(debug_int)
 {
  printf("%-14s% .7G \n","entering 600: ",(double)(TIMER() - T0));
 }
 /* GOSUB Lab_600 */    /* preprocessing for file OPEN */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_600;
 if(debug_int)
 {
  printf("%-14s% .7G \n","entering 650: ",(double)(TIMER() - T0));
 }
 /* GOSUB Lab_650 */    /* Reseting different flags, COMMAND$ */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_650;
 if(debug_int)
 {
  printf("%-14s% .7G \n","Exiting preprocessors: ",(double)(TIMER() - T0));
 }
 if((fp_2 = fopen(strcpy(fn2__S,outf_S), "w")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn2__S); exit(1);
 }
 if(commff_int == 1)
 {
  fprintf(fp_2,"%s\n","main(int n_arg_int, char *argv_S[])");
 }
 else
 {
  fprintf(fp_2,"%s\n","main()");
 }
 fprintf(fp_2,"%s\n","{");
 ni_int = 2;
 nl_int = 0;
 isub_int = 0;
 statfl_int[0] = 1;
 nlmax_int = 32767;
 /* lista varijabli: */
 tmpfl_int = 0;
 strcpy(int_S," int  ");
 strcpy(float_S," float ");
 if(longflg_int == 1)
 {
  strcpy(int_S," long ");
 }
 if(doblflg_int == 1)
 {
  strcpy(float_S," double ");
 }
 if(strcmp(vari_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 3;
  i__s = (i__s + 0 ) % 16;
  declarix(int_S, vari_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(strcmp(varr_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 0;
  i__s = (i__s + 0 ) % 16;
  declarix(float_S, varr_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(strcmp(vars_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 1;
  i__s = (i__s + 0 ) % 16;
  declarix(" char ", vars_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(strcmp(varl_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 4;
  i__s = (i__s + 0 ) % 16;
  declarix(" long ", varl_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(strcmp(vard_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 0;
  i__s = (i__s + 0 ) % 16;
  declarix(" double ", vard_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(strcmp(varb_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 0;
  i__s = (i__s + 0 ) % 16;
  declarix(" unsigned char ", varb_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(strcmp(vash_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 0;
  i__s = (i__s + 0 ) % 16;
  declarix(" short ", vash_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 /* Explicit declarations with CM */
 if(ncm_int > 0)
 {
  for(i_int = 1; i_int <= ncm_int; i_int++)
  {
   fprintf(fp_2,"%s%s\n"," ",cm_S[i_int]);
  }
  tmpfl_int = 1;
  ni_int = ni_int + ncm_int;
 }
 if(tmpfl_int == 1)
 {
  fprintf(fp_2,"\n");
  ni_int = ni_int + 1;
 }
 /* DATA block: */
 /* IF datalin% THEN */
 /*  PRINT #2, " static int  data__c_int=0, data__M_int=" + STR$(datacnt%) + ";" */
 /*  PRINT #2, " static char *DATA__S[]={" */
 /* C data_S[datalin_int][strlen(data_S[datalin_int])-1]='\0'; */
 /*  FOR i% = 1 TO datalin% */
 /*   PRINT #2, data$(i%) */
 /*  NEXT */
 /*  PRINT #2, " };" */
 /*  ni% = ni% + datalin% + 3 */
 /* END IF */
 initline_int = ni_int;   /* initline% se jos povecava u DIM, DECLARE */
 /* GOSUB Lab_31000 */    /* Make a list of possibly used arrays in MAIN */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_31000;

 /* Main processor: */
 if(debug_int)
 {
  printf("%-14s% .7G \n","Entering Translator:",(double)(TIMER() - T0));
 }
 if((fp_1 = fopen(strcpy(fn1__S,tmpfile_S), "r")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn1__S); exit(1);
 }
 while(! eof(fp_1))
 {
  fgets(line_S, LMAX, fp_1);
  line_S[strlen(line_S) - 1] = '\0';
  nl_int = nl_int + 1;
  if(nl_int >= nlmax_int)
  {
   fprintf(stderr,"%s% d %s\n","Max. number of input lines",nlmax_int," reached, aborting.");
   signal_int = 1;   /* exit(1); */
   goto Lab_9999;
  }
  if(memcmp(line_S, "#$ Last", 2)==0) {
  fprintf(fp_2,"%s\n","} /* End of MAIN */");
  lspac_int = lspac_int - 1;
  if(lspac_int != 0)
  {
    fprintf(stderr,"ERROR: Misscount at the 'End of MAIN' brace: %d\n", lspac_int);
   signal_int = 1;   /* exit(1); */
   goto Lab_9999;
  }
  endmain_int = 1;
  goto Lab_90;
  }
  /* C text lines: */
  if(cflag_int == 1)
  {
   if (line_S[0]=='C' && (line_S[1]==' ' || line_S[1]=='\0' || line_S[1]=='\t'))
   {
   fprintf(fp_2,"%s\n",line_S);
   if(isub_int == 0)
   {
    ni_int = ni_int + 1;
   }
   goto Lab_90;
   }
   if ((memcmp(line_S,"CG",2)==0 || memcmp(line_S,"CH",2)==0 || memcmp(line_S,"CM",2)==0) && (line_S[2]==' ' || line_S[2]=='\0' || line_S[2]=='\t'))
   {
    if (isub_int==0 && memcmp(line_S,"CH",2)!=0) ni_int++;
   goto Lab_90;
   }
  }
  /* GOSUB Lab_900 */    /* line splitter */
  if (setjmp(j__buf[j__lev++])==0) goto Lab_900;
  if(ntok_int > 0)
  {
   itok_int = 1;
   while(itok_int <= ntok_int)
   {
    /* GOSUB Lab_30000 */    /* a nicer 'REM' preprocessor */
    if (setjmp(j__buf[j__lev++])==0) goto Lab_30000;
    strcpy(a_S,linetok_S[itok_int]);
    if(strcmp(a_S, "") == 0)
    {
     if(ntok_int == 1)
     {
      fprintf(fp_2,"\n");
      if(isub_int == 0)
      {
       ni_int = ni_int + 1;
      }
     }
    }
    else
    {
     /* GOSUB Lab_500 */    /* Translator */
     if (setjmp(j__buf[j__lev++])==0) goto Lab_500;
    }
    itok_int = itok_int + 1;
   }
  }
  else
  {
   /* GOSUB 1500: REM Check if end of main */
   fprintf(fp_2,"\n");
   if(isub_int == 0)
   {
    ni_int = ni_int + 1;
   }
  }
Lab_90:
 ;}
 fclose(fp_1);
 if(endmain_int == 0)
 {
  fprintf(stderr,"%s\n","Bug: Last line of MAIN not detected!");
  exit(0);
 }
 if(usersub_int == 1)
 {
  fprintf(fp_2,"%s\n","/*- User SUBs--End -*/");
 }
 if(extrnfl_int == 1)
 {
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","/* Translates of used QB's intrinsic functions: */");
  qbfunc();   /* Writing out C translates of intrinsic QB functions used */
 }
 fclose(fp_2);
 /* Add pointer prefixes to variables in SUBs */
 /* GOSUB Lab_45000 */ 
 if (setjmp(j__buf[j__lev++])==0) goto Lab_45000;
 /* changing original QB variable names to suit C gramar, default = yes */
 if(postflg_int == 1)
 {
  /* GOSUB Lab_40000 */ 
  if (setjmp(j__buf[j__lev++])==0) goto Lab_40000;
 }
 goto Lab_9999;


Lab_500:   /* Translator */
 if(debug_int)
 {
  printf("%s% d %s%s\n","Line",nl_int,":",a_S);
 }
 commfl_int = 0;

  if ( memcmp(a_S,"REM",3)==0 ) {
 /* GOSUB Lab_2000 */    /* REM */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_2000;
  }

 /* GOSUB Lab_1000 */    /* SUB, FUNCTION */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_1000;
    if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"SHARED",6)==0 ) {
 /* GOSUB Lab_1250 */    /* SHARED */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_1250;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"DECLARE",7)==0 ) {
 /* GOSUB Lab_2500 */    /* DECLARE */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_2500;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"CONST",5)==0 ) {
 /* GOSUB Lab_2600 */    /* CONST */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_2600;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"DIM ",4)==0 ) {
 /* GOSUB Lab_2750 */    /* DIM */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_2750;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"ERASE ",6)==0 ) {
 /* GOSUB Lab_2800 */    /* ERASE */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_2800;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"REDIM ",6)==0 ) {
 /* GOSUB Lab_2850 */    /* REDIM */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_2850;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"IF ",3)==0 ) {
 /* GOSUB Lab_3000 */    /* IF */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_3000;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"ELSEIF ",7)==0 ) {
 /* GOSUB Lab_3100 */    /* ELSEIF */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_3100;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"ELSE",4)==0 ) {
 /* GOSUB Lab_3250 */    /* ELSE */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_3250;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"END IF",6)==0 ) {
 /* GOSUB Lab_3500 */    /* END IF */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_3500;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"DO WHILE",8)==0 || memcmp(a_S,"WHILE",5)==0 || memcmp(a_S,"DO UNTIL",8)==0 ) {
 /* GOSUB Lab_3750 */    /* DO WHILE or WHILE */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_3750;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"LOOP",4)==0 || memcmp(a_S,"WEND",4)==0 ) {
 /* GOSUB Lab_3900 */    /* LOOP     or WEND */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_3900;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"PRINT #",7)==0 ) {
 /* GOSUB Lab_4000 */    /* PRINT # */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_4000;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"PRINT USING",11)==0 ) {
 /* GOSUB Lab_4100 */    /* PRINT USING */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_4100;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"GET #",5)==0 ) {
 /* GOSUB Lab_4200 */    /* GET (file I/O) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_4200;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"PUT #",5)==0 ) {
 /* GOSUB Lab_4300 */    /* PUT (file I/O) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_4300;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"SEEK ",5)==0 ) {
 /* GOSUB Lab_4400 */    /* SEEK (file I/O) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_4400;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"LINE INPUT #",12)==0 ) {
 /* GOSUB Lab_4500 */    /* LINE INPUT # */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_4500;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"OUT ",4)==0 ) {
 /* GOSUB Lab_4600 */    /* OUT I/O statement */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_4600;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"PRINT",5)==0 || memcmp(a_S,"EPRINT",6)==0 ) {
 /* GOSUB Lab_5000 */    /* PRINT, EPRINT */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_5000;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"LOCATE ",7)==0 ) {
 /* GOSUB Lab_5100 */    /* LOCATE */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_5100;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"COLOR",5)==0 ) {
 /* GOSUB Lab_5200 */    /* COLOR */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_5200;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"CLS",3)==0 ) {
 /* GOSUB Lab_5300 */    /* CLS */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_5300;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"INPUT #",7)==0 ) {
 /* GOSUB Lab_5500 */    /* INPUT # */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_5500;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"SSCAN ",6)==0 ) {
 /* GOSUB Lab_5600 */    /* SSCAN */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_5600;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"INPUT",5)==0 ) {
 /* GOSUB Lab_5750 */    /* INPUT */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_5750;
  } if ( commfl_int==1 ) goto Lab_509;

 /* GOSUB Lab_6000 */    /* Labels */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_6000;
    if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"GOTO ",5)==0 ) {
 /* GOSUB Lab_6500 */    /* GOTO */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_6500;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"CALL",4)==0 ) {
 /* GOSUB Lab_7000 */    /* CALL */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_7000;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"FOR ",4)==0 ) {
 /* GOSUB Lab_8000 */    /* FOR..TO..STEP */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_8000;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"NEXT",4)==0 ) {
 /* GOSUB Lab_8500 */    /* NEXT */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_8500;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"OPEN ",5)==0 ) {
 /* GOSUB Lab_9000 */    /* OPEN */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_9000;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"CLOSE",5)==0 ) {
 /* GOSUB Lab_9500 */    /* CLOSE */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_9500;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"ENVIRON ",8)==0 ) {
 /* GOSUB Lab_10000 */    /* set ENVIRON variable */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_10000;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"GOSUB ",6)==0 ) {
 /* GOSUB Lab_11000 */    /* GOSUB */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_11000;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"RETURN",6)==0 ) {
 /* GOSUB Lab_11500 */    /* RETURN */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_11500;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"RANDOMIZE",9)==0 ) {
 /* GOSUB Lab_12000 */    /* RANDOMIZE */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_12000;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"PAUSE ",6)==0 ) {
 /* GOSUB Lab_12200 */    /* PAUSE */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_12200;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"SHELL",5)==0 ) {
 /* GOSUB Lab_17000 */    /* SHELL */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_17000;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"DEF FN",6)==0 ) {
 /* GOSUB Lab_19300 */    /* DEF FN*, done in 800 */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_19300;
  } if ( commfl_int==1 ) goto Lab_509;

 /* GOSUB Lab_18000 */    /* expressions */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_18000;
    if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"END SUB",7)==0 || memcmp(a_S,"END FUNCTION",12)==0 ) {
 /* GOSUB Lab_19000 */    /* END SUB, END FUNCTION */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_19000;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"EXIT SUB",8)==0 ) {
 /* GOSUB Lab_19100 */    /* EXIT SUB */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_19100;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"END",3)==0 ) {
 /* GOSUB Lab_1500 */    /* END Must be after all other END's */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_1500;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"DEFSTR ",7)==0 || memcmp(a_S,"DEFINT ",7)==0 || memcmp(a_S,"DEFDBL ",7)==0) {
   commfl_int = 1; /* GOSUB 19200: REM DEFXXX, done in 800 */
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"SOUND",5)==0 ) {
 /* GOSUB Lab_19400 */    /* SOUND */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_19400;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"DATA ",5)==0 ) {
  commfl_int = 1; /* GOSUB 19500: REM DATA, done in 800 */
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"READ ",5)==0 ) {
 /* GOSUB Lab_19550 */    /* READ */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_19550;
  } if ( commfl_int==1 ) goto Lab_509;

  if ( memcmp(a_S,"RESTORE",7)==0 ) {
 /* GOSUB Lab_19575 */    /* RESTORE */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_19575;
  } if ( commfl_int==1 ) goto Lab_509;

 /*   G R A P H I C S */
  if ( memcmp(a_S,"LINE (",6)==0 ||  memcmp(a_S,"LINE -",6)==0) {
 /* GOSUB Lab_20000 */    /* LINE (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_20000;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"MARKER ",7)==0 ) {
 /* GOSUB Lab_24000 */    /* MARKER (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_24000;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"PLINE ",6)==0 ) {
 /* GOSUB Lab_24500 */    /* PLINE (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_24500;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"PMARKER ",8)==0 ) {
 /* GOSUB Lab_25000 */    /* PMARKER (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_25000;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"PSET ",5)==0 ) {
 /* GOSUB Lab_20500 */    /* PSET (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_20500;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XUPDATE",7)==0 ) {
 /* GOSUB Lab_23000 */    /* XUPDATE (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_23000;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XCLS",4)==0 ) {
 /* GOSUB Lab_23200 */    /* XCLS (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_23200;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XSELWI",6)==0 || memcmp(a_S,"XCLOSE",6)==0 || memcmp(a_S,"XCURSOR",7)==0) {
 /* GOSUB Lab_23400 */    /* "XSELWI", "XCLOSE", "XCURSOR" or "XCLOSEDS" (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_23400;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"PALETTE ",8)==0 ) {
 /* GOSUB Lab_23500 */    /* PALETTE (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_23500;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"GETCOL ",7)==0 ) {
 /* GOSUB Lab_23300 */    /* GETCOL (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_23300;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"SCREEN ",7)==0 || memcmp(a_S,"XWINDOW ",8)==0) {
 /* GOSUB Lab_21000 */    /* "SCREEN " and/or "XWINDOW " (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_21000;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"SET ",4)==0 ) {
 /* GOSUB Lab_21500 */    /* SET  (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_21500;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"SAVEGIF ",8)==0 || memcmp(a_S,"SAVEPS ",7)==0 || memcmp(a_S,"SAVEEPS ",8)==0 || memcmp(a_S,"SAVEPSL ",8)==0 ) {
 /* GOSUB Lab_22000 */    /* SAVExxx (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_22000;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"LOADGIF ",8)==0 ) {
 /* GOSUB Lab_22500 */    /* LOADGIF (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_22500;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"GIFINFO ",8)==0 ) {
 /* GOSUB Lab_22600 */    /* GIFINFO (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_22600;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XTEXT ",6)==0 ) {
 /* GOSUB Lab_25500 */    /* XTEXT (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_25500;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"FAREA ",6)==0 ) {
 /* GOSUB Lab_26000 */    /* FAREA (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_26000;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"CIRCLE ",7)==0 ) {
 /* GOSUB Lab_26500 */    /* CIRCLE (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_26500;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"GCGET ",6)==0 ) {
 /* GOSUB Lab_27000 */    /* GCGET (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_27000;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XPOINTER ",9)==0 ) {
 /* GOSUB Lab_27500 */    /* XPOINTER (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_27500;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XTITLE ",7)==0 ) {
 /* GOSUB Lab_23600 */    /* XTITLE (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_23600;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XREQST ",7)==0 ) {
 /* GOSUB Lab_23700 */    /* XREQST (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_23700;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XCLIP ",6)==0 ) {
 /* GOSUB Lab_23800 */    /* XCLIP (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_23800;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XNOCLI ",7)==0 ) {
 /* GOSUB Lab_23900 */    /* XNOCLI (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_23900;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XWARP ",6)==0 ) {
 /* GOSUB Lab_23950 */    /* XWARP (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_23950;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XROT ",5)==0 ) {
 /* GOSUB Lab_28000 */    /* ROTATE (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_28000;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XTRAN ",6)==0 ) {
 /* GOSUB Lab_28100 */    /* TRANSLATE (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_28100;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XSCAL ",6)==0 ) {
 /* GOSUB Lab_28200 */    /* SCALE (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_28200;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"MRESET",6)==0 ) {
 /* GOSUB Lab_28300 */    /* MRESET (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_28300;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XBUF",4)==0 ) {
 /* GOSUB Lab_28400 */    /* XBUF (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_28400;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"XRMBUF",6)==0 ) {
 /* GOSUB Lab_28500 */    /* XRMBUF (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_28500;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"GET ",4)==0 || memcmp(a_S,"XGETGE ",7)==0 ) {
 /* GOSUB Lab_22100 */    /* GET (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_22100;
  } if ( commfl_int==1 ) goto Lab_509;
  if ( memcmp(a_S,"PUT ",4)==0 || memcmp(a_S,"XANIM ",6)==0 ) {
 /* GOSUB Lab_22200 */    /* PUT and/or XANIM (graphics) */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_22200;
  } if ( commfl_int==1 ) goto Lab_509;

 /* In 650 defined: SPACE$, MID$, LEFT$, RIGHT$, STR$, CHR$, ASC, VAL, LEN, */
 /*                 SGN, INT, CINT, EOF, COMMAND$, CONST, LOF */
 /* GOSUB Lab_29000 */    /* anything else */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_29000;
Lab_509:   /* End Translator */
 /* RETURN */
 longjmp(j__buf[--j__lev],1);



Lab_600:   /* preprocessing the whole file for OPEN files and opened I/O ports */
 /* and for QB functions */
 /* information on OPEN must be saved only cumulative (for all modules) */
 nopen_int = 0;
 niopen_int = 0;
 nl_int = 0;
 if((fp_1 = fopen(strcpy(fn1__S,inpf_S), "r")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn1__S); exit(1);
 }
 while(! eof(fp_1))
 {
  fgets(line_S, LMAX, fp_1);
  line_S[strlen(line_S) - 1] = '\0';
  nl_int = nl_int + 1;
      if (line_S[strlen(line_S)-1]==13) line_S[strlen(line_S)-1]='\0'; /*croff*/
      if (line_S[0]=='C' && cflag_int)
      {
       if (line_S[0]=='C' && (line_S[1]==' ' || line_S[1]=='\0' || line_S[1]=='\t') || (memcmp(line_S,"CG",2)==0 || memcmp(line_S,"CH",2)==0 || memcmp(line_S,"CM",2)==0) && (line_S[2]==' ' || line_S[2]=='\0' || line_S[2]=='\t')) goto Lab_609;
      }
  /* GOSUB Lab_900 */    /* spliter */
  if (setjmp(j__buf[j__lev++])==0) goto Lab_900;
  for(g_int = 1; g_int <= ntok_int; g_int++)
  {
   strcpy(line_S,linetok_S[g_int]);
   if(strcmp(LEFT_S(line_S, 3), "REM") == 0)
   {
    goto Lab_608;
   }

   /*    OPEN file: */
       if (memcmp(line_S, "OPEN ", 5)==0)
       {
   i_int = LEN(line_S) - 1;   /* mode$ = "" */
        while (atoi(&line_S[i_int])!=0 && line_S[i_int] !=' ') i_int--;
   /*     IF mode$ = "" THEN mode$ = "r+" */
   if(nopen_int == 0)
   {
    nopen_int = 1;
    fopen_int[nopen_int] = VAL(MID_S(line_S, i_int + 2, LMAX));
   }
   else
   {
    tmpfl_int = 1;
    n_int = VAL(MID_S(line_S, i_int + 2, LMAX));
    for(j_int = 1; j_int <= nopen_int; j_int++)
    {
     if(fopen_int[j_int] == n_int)
     {
      tmpfl_int = 0;
     }
    }
    if(tmpfl_int == 1)
    {
     nopen_int = nopen_int + 1;
     fopen_int[nopen_int] = n_int;
    }
   }
       }

   /*    I/O ports INP(port), OUT(port,data): */
       k_int = strlen(line_S) - 5; if (k_int < 0) k_int = 0;
   togfl_int = 0;

Lab_608:
  ;}
Lab_609:
 ;}
 fclose(fp_1);
 strcpy(fff_S,"");
 if(nopen_int > 0)
 {
  strcpy(d_S,"");
  strcpy(b_S,"");
  for(i_int = 1; i_int <= nopen_int; i_int++)
  {
   strcpy(n_S,STR_S(fopen_int[i_int]));
   strcpy(n_S,MID_S(n_S, 2, LEN(n_S) - 1));
   sprintf(tws__S,"%s%s%s%s",d_S,"*fp_",n_S,", ");
   strcpy(d_S,tws__S);
   sprintf(tws__S,"%s%s%s%s",b_S,"fn",n_S,"__S[160], ");
   strcpy(b_S,tws__S);
  }
  strcpy(fff_S,LEFT_S(d_S, LEN(d_S) - 2));   /* FILE pointers */
  strcpy(fn_S,LEFT_S(b_S, LEN(b_S) - 2));   /* FILE names */
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_650:   /* Check for use of QB functions and fill flags used in */
 /* mathexp, qbdecl, qbfunx and 41000 (=hederix) */
 /* Preprocessing intrinsic QB functions. */
 /* Important part is declaring functions in the preamble and */
 /* appending C subroutines at the end of file. */
 /* Here are gathered functions whose names or varlists need not to */
 /* be changed beyond what QB2C normaly does + COMMAND$ and CONST. */
 /* Others that need to be changed are implemented elsewhere (mathexp..) */
 /* Also, stores all global and MAIN explicit declarations (headers) */
 extrnfl_int = 0;   /* Set to 1 if ANY translated function is used */
 mathfl_int = 0;   /* Set to 1 if any <math.h> function is used */
 /* retrnfl% 'RETURN' usage flag, filled in 700 */
 funcflag_int = 0;   /* =1 while main processor is in a FUNCTION */
 strcpy(funcnam_S,"");
 timefl_int = 0;   /* Set to 1 if <time.h> needed */
 systimefl_int = 0;   /* Set to 1 if <sys/time.h> needed */
 unistdfl_int = 0;   /* Set to 1 if <unistd.h> needed */
 pausefl_int = 0;   /* Set to 1 if include files for 'select' needed */
 twsflg_int = 0;   /* Need for temporary storage string */
 sigiff_int = 0;   /* For complicated FOR loops */
 xwflag_int = 0;   /* If XWINDOW used on the right side */
 SScan_int = 0;   /* SScan() function usage (qbfdecl) */
 /* defstr% = 0: DEFSTR in effect (vartyp), defined in 800 */
 /* datalin% = 0: datacnt% = 0: REM DATA lines counter, defined in 800 */
 spacff_int = 0;
 midff_int = 0;
 leftff_int = 0;
 rightff_int = 0;
 strff_int = 0;
 chrff_int = 0;
 ascff_int = 0;
 valff_int = 0;
 lenff_int = 0;
 sgnff_int = 0;
 intff_int = 0;
 nintff_int = 0;
 eofff_int = 0;
 commff_int = 0;
 ncnst_int = 0;
 existff_int = 0;
 vdblff_int = 0;
 rndff_int = 0;
 srndff_int = 0;
 dateff_int = 0;
 timeff_int = 0;
 timerff_int = 0;
 inputff_int = 0;
 inkeyff_int = 0;
 colorff_int = 0;
 clsff_int = 0;
 minff_int = 0;
 maxff_int = 0;
 grafflg_int = 0;
 lcaseff_int = 0;
 ucaseff_int = 0;
 envff_int = 0;
 lofff_int = 0;
 hexff_int = 0;
 octff_int = 0;
 stringf_int = 0;
 txlen_int = 0;
 usingff_int = 0;
 readff_int = 0;
 /* SPACE$ -> SPACE_S */
 /* MID$   -> MID_S */
 /* LEFT$  -> LEFT_S */
 /* RIGHT$ -> RIGHT_S */
 /* STR$   -> STR_S */
 /* CHR$   -> CHR_S */
 /* HEX$   -> HEX_S */
 /* OCT$   -> OCT_S */
 /* LCASE$ -> LCASE_S */
 /* UCASE$ -> UCASE_S */
 /* STRING$ -> STRING_S */
 /* ENVIRON$ -> ENVIRON_S */
 /* INKEY$ -> INKEY_S() */
 /* DATE$  -> DATE_S */
 /* TIME$  -> TIME_S */
 /* TIMER  -> TIMER() */
 /* RND    -> RND(1), except if RND( then leave as is, but set rndff% */
 /* ASC    -> ASC */
 /* VAL    -> VAL */
 /* LEN    -> LEN */
 /* XLEN   -> XLEN */
 /* INT    -> Int */
 /* ABS    -> fabs */
 /* SGN    -> SGN */
 /* CINT   -> Nint */
 /* EOF(n) -> eof(fp_n) */
 /* CONST -> #define */
 /* MIN   -> #define */
 /* MAX   -> #define */
 /* LOF   -> LOF */
 /* INP   -> inb */
 /* OUT   -> outb */
 /* DEF FN -> izbaciti van */
 if((fp_1 = fopen(strcpy(fn1__S,inpf_S), "r")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn1__S); exit(1);
 }
 if((fp_2 = fopen(strcpy(fn2__S,tmpfile_S), "w")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn2__S); exit(1);
 }
 nl_int = 0;
 while(! eof(fp_1))
 {
  fgets(line_S, LMAX, fp_1);
  line_S[strlen(line_S) - 1] = '\0';
      while(line_S[strlen(line_S)-1]==13 || line_S[strlen(line_S)-1]==' ') line_S[strlen(line_S)-1]='\0'; /*croff,' '*/
  lleng_int = LEN(line_S);
  nl_int = nl_int + 1;
  /* C text lines: */
  if (cflag_int == 1 && line_S[0]=='C')
  {
   if (line_S[1]==' ' || line_S[1]=='\0' || line_S[1]=='\t')
   {
  fprintf(fp_2,"%s\n",line_S);
  goto Lab_659;
   }
   if ((memcmp(line_S,"CG",2)==0 || memcmp(line_S,"CH",2)==0) && (line_S[2]==' ' || line_S[2]=='\0' || line_S[2]=='\t'))
   {
    if (++ncg_int > CMAX) {
    printf("qb2c: Max number of CH lines reached !\n");
    printf("qb2c: Enlarge constant CMAX in qb2c and recompile it.\n"); exit(0);}
  strcpy(cg_S[ncg_int],MID_S(line_S, 4, LMAX));
  fprintf(fp_2,"%s\n",line_S);
  goto Lab_659;
   }
   if (memcmp(line_S,"CM",2)==0 && (line_S[2]==' ' || line_S[2]=='\0' || line_S[2]=='\t'))
   {
    if (++ncm_int > CMAX) {
    printf("qb2c: Max number of CM lines reached !\n");
    printf("qb2c: Enlarge constant CMAX in qb2c and recompile it.\n"); exit(0);}
  strcpy(cm_S[ncm_int],MID_S(line_S, 4, LMAX));
  fprintf(fp_2,"%s\n",line_S);
  goto Lab_659;
   }
  }
  gulix(line_S);
  if (memcmp(line_S,"REM ",4) == 0)
  {
  fprintf(fp_2,"%s\n",line_S);
  goto Lab_659;
  }

  if(!lastline_int) { /* Find last line in MAIN */
   if (memcmp(line_S,"FUNCTION ",9)==0 || memcmp(line_S,"SUB ",4)==0) {
  lastline_int = nl_int;
  nl_int = nl_int + 1;
  fprintf(fp_2,"%s\n","#$ Last line of MAIN");
   }
  }
  /* jrplc% je zadnji redni broj imena (funkcije) koje treba mijenjati (od 0) */
  /* jnfun% je zadnji redni broj funkcije */
  /* NFUN   je zadnji redni broj */
      lleng_int = strlen(line_S);
      for(i_int=0; i_int <= NFUN; ++i_int)
      {
       n_int = strlen(strcpy(b_S, rplc_S[i_int]));
       togfl_int = 0;
       for(j_int=0; j_int <= lleng_int - n_int + 1; j_int++)
       {
        if (line_S[j_int] == 34) togfl_int = 1 - togfl_int;
        if (togfl_int == 1) goto Lab_658;
        if (memcmp(b_S,&line_S[j_int],n_int) == 0)
        {
         c=0; if(j_int > 0) c=line_S[j_int-1];
         log_1=!(c>='a' && c<='z' || c>='A' && c<='Z' || c=='_');
         c=line_S[j_int+n_int];
         log_2=!(c>='a' && c<='z' || c>='A' && c<='Z' || c=='_');
         if(log_1 && log_2)
         {
          if(i_int<=jrplc_int)
          {
            if(i_int==0) strcpy(e_S,"Nint");
            if(i_int==1) strcpy(e_S,"Int");
            if(i_int==2) strcpy(e_S,"fabs");
            if(i_int==3) strcpy(e_S,"atan");
            if(i_int==4) strcpy(e_S,"sqrt");
            if(i_int==5) strcpy(e_S,"log");
            if(i_int==6) strcpy(e_S,"sin");
            if(i_int==7) strcpy(e_S,"cos");
            if(i_int==8) strcpy(e_S,"tan");
            if(i_int==9) strcpy(e_S,"exp");
           if(c!='(') {
            if(i_int==10) strcpy(e_S,"DATE$(0)");
            if(i_int==11) strcpy(e_S,"TIME$(0)");
            if(i_int==12) strcpy(e_S,"TIMER()");
            if(i_int==13) strcpy(e_S,"RND(1)");
            if(i_int==14) strcpy(e_S,"INKEY$()");
            if(i_int==15) strcpy(e_S,"inb((int)");
           }
           if(c=='(' && (i_int==10 || i_int==11 || i_int==13)) strcpy(e_S, b_S);
           strcpy(d_S,line_S);
           line_S[j_int]='\0'; strcat(line_S,e_S);
           strcat(line_S,&d_S[j_int+n_int]);
           j_int=j_int+strlen(e_S)-1;
           lleng_int=strlen(line_S);
          }
    switch(i_int) {
          case  0: nintff_int =1; mathfl_int =1; extrnfl_int=1;
                   break;
          case  1: intff_int  =1; mathfl_int =1; extrnfl_int=1;
                   break;
          case  2: mathfl_int =1;
                   break;
          case  3: mathfl_int =1;
                   break;
          case  4: mathfl_int =1;
                   break;
          case  5: mathfl_int =1;
                   break;
          case  6: mathfl_int =1;
                   break;
          case  7: mathfl_int =1;
                   break;
          case  8: mathfl_int =1;
                   break;
          case  9: mathfl_int =1;
                   break;
          case 10: dateff_int=1; extrnfl_int=1; timefl_int=1; chartfl_int=1;
                   break;
          case 11: timeff_int=1; extrnfl_int=1; timefl_int=1; chartfl_int=1;
                   break;
          case 12: timerff_int=1; extrnfl_int=1;systimefl_int=1;unistdfl_int=1;
                   break;
          case 13: rndff_int=1; extrnfl_int=1;
                   break;
          case 14: inkeyff_int=1; extrnfl_int=1; chartfl_int=1; unistdfl_int=1;
                   break;
          case 15:
                   break;
          case 16: spacff_int =1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 17: rightff_int=1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 18: leftff_int =1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 19: midff_int  =1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 20: strff_int  =1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 21: chrff_int  =1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 22: ascff_int  =1; extrnfl_int=1; longtfl_int =1;
                   break;
          case 23: valff_int  =1; extrnfl_int=1; vdblff_int =1;
                   break;
          case 24: minff_int  =1;
                   break;
          case 25: maxff_int  =1;
                   break;
          case 26: lenff_int  =1; extrnfl_int=1; vdblff_int =1;
                   break;
          case 27: sgnff_int  =1; extrnfl_int=1; vdblff_int =1;
                   break;
          case 28: eofff_int  =1; extrnfl_int=1;
                   break;
          case 29: lofff_int  =1; longtfl_int = 1; extrnfl_int=1;
                   break;
          case 30: existff_int  =1; extrnfl_int=1;
                   break;
          case 31: srndff_int =1; extrnfl_int=1;
                   break;
          case 32: twsflg_int=1;
                   break;
          case 33: commff_int=1; extrnfl_int=1; chartfl_int=1;
  /*                narr% = narr% + 1: darr$(narr%) = "argv$()" */
  /*                alis% = alis% + 1: alist%(alis%) = narr% */
  nshtok_int[0] = nshtok_int[0] + 1;
  strcpy(shtok_S[0][nshtok_int[0]],"n_arg%");
  nshtok_int[0] = nshtok_int[0] + 1;
  strcpy(shtok_S[0][nshtok_int[0]],"argv$()");
  /*                nSHRDtk% = nSHRDtk% + 1: shrd$(nSHRDtk%) = "n_arg%" */
  /*                nSHRDtk% = nSHRDtk% + 1: shrd$(nSHRDtk%) = "argv$()" */
                   break;
          case 34: lcaseff_int=1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 35: ucaseff_int=1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 36: envff_int=1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 37: hexff_int=1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 38: octff_int=1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 39: stringf_int=1; extrnfl_int=1; chartfl_int=1;
                   break;
          case 40: txlen_int=1; extrnfl_int=1;
                   break;
          case 41: readff_int=1; extrnfl_int=1;
                   break;
                  }
         }
Lab_657:
        c=0;
        }
Lab_658:
       c=0;
       }
      }
      /* printf("%s\n",line_S); */
      fprintf(fp_2," %s\n",line_S);
Lab_659:
 ;}
 if(! lastline_int)
 {
  lastline_int = nl_int;
  fprintf(fp_2,"%s\n","#$ Last line of MAIN");
 }
 fclose(fp_1);
 fclose(fp_2);
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_700:   /* preprocessing the whole file for variables in MAIN & SUB's */
 /* for a SUB do not save variables found in respective SHARED */
 /* 'Variables' can also be multidimensional arrays */
 /* Declare implicitely declared variables in commands. */
 /* Lists of variables of all SUBs: subvar$(isub%, i%), nsubvar%(isub%) */
 nsub_int = 0;
 nvar_int = 0;
 strcpy(shtmp_S,"");
 nl_int = 0;
 retrnfl_int = 0;
 strcpy(e_S,CHR_S(34));
 xtmpfl_int = 0;
 strcpy(fime_S,"");
 flag_int = 0;
 if((fp_1 = fopen(strcpy(fn1__S,inpf_S), "r")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn1__S); exit(1);
 }
 while(! eof(fp_1))
 {
  fgets(line_S, LMAX, fp_1);
  line_S[strlen(line_S) - 1] = '\0';
  nl_int = nl_int + 1;
      if(line_S[strlen(line_S)-1] == 13) line_S[strlen(line_S)-1]='\0';/*croff*/
      if (line_S[0] == 'C' && cflag_int) {
       if (line_S[0]=='C' && (line_S[1]==' ' || line_S[1]=='\0' || line_S[1]=='\t') || (memcmp(line_S,"CG",2)==0 || memcmp(line_S,"CH",2)==0 || memcmp(line_S,"CM",2)==0) && (line_S[2]==' ' || line_S[2]=='\0' || line_S[2]=='\t')) goto Lab_709;
      }
  gulix(line_S);
      if (memcmp(line_S, "FUNCTION ", 9) == 0) xtmpfl_int = 1;
  while(! (strcmp(LEFT_S(line_S, 4), "SUB ") == 0 || xtmpfl_int == 1))
  {
   if(strcmp(line_S, "") != 0)
   {
        if (memcmp(line_S,"REM ",4)==0) goto Lab_709;
    /* GOSUB Lab_900 */    /* line splitting */
    if (setjmp(j__buf[j__lev++])==0) goto Lab_900;
    for(ii_int = 1; ii_int <= ntok_int; ii_int++)
    {
     strcpy(line_S,linetok_S[ii_int]);
     gulix(line_S);
         if (memcmp(line_S, "RETURN", 6) == 0) retrnfl_int = 1;
     /* check for "FOR": */
         if (memcmp(line_S, "FOR", 3) == 0)
         {
     strcpy(line_S,MID_S(line_S, 4, LMAX));
     gulix(line_S);
     goto Lab_704;
         }
     /* check for "READ": */
         if (memcmp(line_S, "READ", 4) == 0)
         {
     strcpy(line_S,MID_S(line_S, 5, LMAX));
     gulix(line_S);
     /* GOSUB Lab_735 */    /* Tokenize line and save variables */
     if (setjmp(j__buf[j__lev++])==0) goto Lab_735;
     goto Lab_706;
         }
     /* check for "GET #" file I/O: */
         if (memcmp(line_S, "GET #", 5) == 0)
         {
     strcpy(d_S,MID_S(line_S, 6, LMAX));
     strcpy(tmp_S[3],"");
     tokenix(d_S, &n_int, ",", "");
     strcpy(line_S,tmp_S[3]);
     if(strcmp(line_S, "") != 0)   /* Tokenize line and save variables */
     {
      /* GOSUB Lab_735 */ 
      if (setjmp(j__buf[j__lev++])==0) goto Lab_735;
     }
     goto Lab_706;
         }
     /* check for "GIFINFO ": */
         if (memcmp(line_S, "GIFINFO ", 8) == 0)
         {
          /* Find the second argument */
          k_int=8; while(line_S[k_int] != ',' && line_S[k_int] !='\0') k_int++;
          strcpy(tws__S, &line_S[++k_int]); strcpy(line_S, tws__S);
     /* GOSUB Lab_735 */    /* Tokenize line and save variables */
     if (setjmp(j__buf[j__lev++])==0) goto Lab_735;
     goto Lab_706;
         }
     /* check for "GCGET ": */
         if (memcmp(line_S, "GCGET ", 6) == 0)
         {
     tokenix(MID_S(line_S, 7, LMAX), &k_int, ",", "");
          strcpy(line_S, &tmp_S[1][1]); line_S[(c=strlen(line_S))]='\0';
          line_S[c-1]=','; strcat(line_S, tmp_S[2]);
     /* GOSUB Lab_735 */    /* Tokenize line and save variables */
     if (setjmp(j__buf[j__lev++])==0) goto Lab_735;
     goto Lab_706;
         }
     /* check for "GETCOL ": */
         if (memcmp(line_S, "GETCOL ", 7) == 0)
         {
     strcpy(line_S,MID_S(line_S, 8, LMAX));
     gulix(line_S);
     /* GOSUB Lab_735 */    /* Tokenize line and save variables */
     if (setjmp(j__buf[j__lev++])==0) goto Lab_735;
     goto Lab_706;
         }
     /* check for "XPOINTER " or "XGETGE ": */
         if (memcmp(line_S,"XPOINTER ",9)==0 || memcmp(line_S,"XGETGE ",7)==0)
         {
          i_int = 10; if (line_S[1] == 'G') i_int = 8;
     strcpy(line_S,MID_S(line_S, i_int, LMAX));
     lleng_int = LEN(line_S);
     i_int = 0;
          while(line_S[i_int] != '(' && i_int < lleng_int) i_int++;
          line_S[i_int] = ' '; c = 1;
          while(i_int < lleng_int) {
           if (line_S[i_int] == '(') c++; if (line_S[i_int] == ')') c--;
           if (c == 0) break;
           i_int++;
          }
          line_S[i_int] = ' ';
          /* Make sure there is no more than 4 parameters in the list: */
          i_int = 0; k_int = 0;
          while ((c=line_S[i_int]) != 0) {
           if (c == ',') k_int++;
           if (k_int >= 4) { line_S[i_int] = '\0'; i_int--; }
           i_int++;
          }
     /* GOSUB Lab_735 */    /* Tokenize line and save variables */
     if (setjmp(j__buf[j__lev++])==0) goto Lab_735;
     goto Lab_706;
         }
     /* check for "XREQST ": */
         if (memcmp(line_S, "XREQST ", 7) == 0)
         {
     tokenix(MID_S(line_S, 7, LMAX), &k_int, ",", "");
          strcpy(line_S, tmp_S[2]); strcat(line_S, ", ");
          strcat(line_S, tmp_S[3]);
     /* GOSUB Lab_735 */    /* Tokenize line and save variables */
     if (setjmp(j__buf[j__lev++])==0) goto Lab_735;
     goto Lab_706;
         }
     jflg_int = 0;   /* check 'LINE INPUT #','INPUT #', 'INPUT' and 'SSCAN' */
     /* GOSUB Lab_730 */ 
     if (setjmp(j__buf[j__lev++])==0) goto Lab_730;
     if(jflg_int == 1)
     {
      goto Lab_706;
     }
     jflg_int = 0;   /* variables among SUB arguments, check 'CALLs' */
     /* GOSUB Lab_750 */ 
     if (setjmp(j__buf[j__lev++])==0) goto Lab_750;
     if(jflg_int == 1)
     {
      goto Lab_706;
     }
Lab_704:
     jflg_int = 0;
     lleng_int = LEN(line_S);
     for(k_int = 1; k_int <= lleng_int; k_int++)
     {
          if (line_S[k_int-1] == '=') { jflg_int = 1; goto Lab_705; }
     }
Lab_705:
     if(jflg_int == 1)
     {
      for(j_int = 0; j_int <= k_int - 3; j_int++)
      {
           if (line_S[j_int] == ' ') { jflg_int = 0; goto Lab_708; }
      }
     }
Lab_708:
     if(jflg_int == 1)
     {
      strcpy(z_S,LEFT_S(line_S, k_int - 2));
          if (z_S[strlen(z_S)-1] == ')')
          {
      j_int = 0;
           while (z_S[j_int] != '(') j_int++;
           j_int++;
           z_S[j_int  ] = ')';
           z_S[j_int+1] = '\0';
          }
      /* GOSUB Lab_790 */    /* Memorizing z$ */
      if (setjmp(j__buf[j__lev++])==0) goto Lab_790;
     }
Lab_706:
    ;}
   }
Lab_701:
   if(eof(fp_1))
   {
    goto Lab_707;
   }
   fgets(line_S, LMAX, fp_1);
   line_S[strlen(line_S) - 1] = '\0';
   nl_int = nl_int + 1;
       if(line_S[strlen(line_S)-1] == 13)line_S[strlen(line_S)-1]='\0';/*croff*/
       if (line_S[0] == 'C' && cflag_int) {
        if (line_S[0]=='C' && (line_S[1]==' ' || line_S[1]=='\0' || line_S[1]=='\t') || (memcmp(line_S,"CG",2)==0 || memcmp(line_S,"CH",2)==0 || memcmp(line_S,"CM",2)==0) && (line_S[2]==' ' || line_S[2]=='\0' || line_S[2]=='\t')) goto Lab_701;
       }
   gulix(line_S);
   if(strcmp(LEFT_S(line_S, 9), "FUNCTION ") == 0)
   {
    xtmpfl_int = 1;
   }
  }
Lab_707:   /* Get FUNCTION name */
  if(xtmpfl_int == 1)
  {
   xtmpfl_int = 0;
   /* GOSUB Lab_715 */ 
   if (setjmp(j__buf[j__lev++])==0) goto Lab_715;
  }
  /* Insert DYNAMIC arrays which are not SHARED: */
  if(ndyna_int[nsub_int] > 0)
  {
   for(i_int = 1; i_int <= ndyna_int[nsub_int]; i_int++)
   {
    strcpy(b_S,dyna_S[nsub_int][i_int]);
        j_int=0; while(b_S[j_int]!='(' && b_S[j_int]!='\0') j_int++;
        b_S[j_int]='\0';
    sprintf(d_S,"%s%s",b_S,"()");
    for(j_int = 1; j_int <= nSHRDtk_int; j_int++)
    {
     if(strcmp(d_S, shrd_S[j_int]) == 0)
     {
      goto Lab_712;
     }
    }
    nvar_int = nvar_int + 1;
    sprintf(vlist_S[nsub_int][nvar_int],"%s%s","*",b_S);
Lab_712:
   ;}
  }
  nvlist_int[nsub_int] = nvar_int;
Lab_711:   /* Sorting variables */
  strcpy(int_S,"");
  strcpy(rea_S,"");
  strcpy(sss_S,"");
  strcpy(lon_S,"");
  strcpy(dbl_S,"");
  strcpy(byt_S,"");
  strcpy(sho_S,"");
  if(nvar_int > 0)
  {
   /* GOSUB Lab_710 */ 
   if (setjmp(j__buf[j__lev++])==0) goto Lab_710;
   if(strcmp(int_S, "") != 0)
   {
    strcpy(int_S,LEFT_S(int_S, LEN(int_S) - 2));
   }
   if(strcmp(rea_S, "") != 0)
   {
    strcpy(rea_S,LEFT_S(rea_S, LEN(rea_S) - 2));
   }
   if(strcmp(sss_S, "") != 0)
   {
    strcpy(sss_S,LEFT_S(sss_S, LEN(sss_S) - 2));
   }
   if(strcmp(lon_S, "") != 0)
   {
    strcpy(lon_S,LEFT_S(lon_S, LEN(lon_S) - 2));
   }
   if(strcmp(dbl_S, "") != 0)
   {
    strcpy(dbl_S,LEFT_S(dbl_S, LEN(dbl_S) - 2));
   }
   if(strcmp(byt_S, "") != 0)
   {
    strcpy(byt_S,LEFT_S(byt_S, LEN(byt_S) - 2));
   }
   if(strcmp(sho_S, "") != 0)
   {
    strcpy(sho_S,LEFT_S(sho_S, LEN(sho_S) - 2));
   }
  }
  strcpy(vari_S[nsub_int],int_S);
  strcpy(varr_S[nsub_int],rea_S);
  strcpy(vars_S[nsub_int],sss_S);
  strcpy(varl_S[nsub_int],lon_S);
  strcpy(vard_S[nsub_int],dbl_S);
  strcpy(varb_S[nsub_int],byt_S);
  strcpy(vash_S[nsub_int],sho_S);
  if(! eof(fp_1))
  {
   nvar_int = 0;
   nsub_int = nsub_int + 1;
   strcpy(shtmp_S,"");
   /* Extraction of varlist at the beginning nsub%-th SUB */
   /* GOSUB Lab_780 */ 
   if (setjmp(j__buf[j__lev++])==0) goto Lab_780;
  }
Lab_709:
 ;}
 /* If last line is REM or CX make sure all variables are collected: */
 if(! flag_int)
 {
  flag_int = 1;
  goto Lab_711;
 }
 fclose(fp_1);
 nsubvar_int[nsub_int + 1] = 0;   /* Ensure this is 0 (important in 45000) */
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_710:   /* sorting variable types */
 for(i_int = 1; i_int <= nvar_int; i_int++)
 {
  strcpy(d_S,vlist_S[nsub_int][i_int]);
       if(d_S[0]=='*') {
  vartyp(MID_S(d_S, 2, LMAX), &typ_int);
  if(typ_int == 5)
  {
   typ_int = 35;
  }
       } else {
  vartyp(d_S, &typ_int);
       }
  if(typ_int == 0)
  {
   fprintf(stderr,"%s%s%s% d \n","ERROR can't determine vartyp of: ",d_S," in line No",nl_int);
   signal_int = 1;   /* exit(1); */
   goto Lab_9999;
  }
  if(typ_int < 10)
  {
   if(typ_int == 1)
   {
    sprintf(tws__S,"%s%s%s",int_S,d_S,", ");
    strcpy(int_S,tws__S);
   }
   else
   {
    if(typ_int == 5)
    {
     sprintf(tws__S,"%s%s%s",sss_S,d_S,"[LMAX], ");
     strcpy(sss_S,tws__S);
    }
    else
    {
     if(typ_int == 2)
     {
      sprintf(tws__S,"%s%s%s",lon_S,d_S,", ");
      strcpy(lon_S,tws__S);
     }
     else
     {
      if(typ_int == 4)
      {
       sprintf(tws__S,"%s%s%s",dbl_S,d_S,", ");
       strcpy(dbl_S,tws__S);
      }
      else
      {
       if(typ_int == 3)
       {
        sprintf(tws__S,"%s%s%s",rea_S,d_S,", ");
        strcpy(rea_S,tws__S);
       }
       else
       {
        if(typ_int == 8)
        {
         sprintf(tws__S,"%s%s%s",byt_S,d_S,", ");
         strcpy(byt_S,tws__S);
        }
        else
        {
         if(typ_int == 9)
         {
          sprintf(tws__S,"%s%s%s",sho_S,d_S,", ");
          strcpy(sho_S,tws__S);
         }
        }
       }
      }
     }
    }
   }
  }
  else
  {
   if(typ_int == 35)
   {
    sprintf(tws__S,"%s%s%s",sss_S,d_S,", ");
    strcpy(sss_S,tws__S);
   }
  }
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_715:   /* Getting FUNCTION name, "" if not a FUNCTION */
 /* This name is then forbidden in variable list */
 strcpy(fime_S,"");
 g_int = 10;
     while (line_S[g_int-1] != '(' && line_S[g_int-1] != '\0') g_int++;
 strcpy(fime_S,MID_S(line_S, 10, g_int - 10));
 gulix(fime_S);
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_720:   /* Unused */
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_730:   /* Checking variable declarations in "LINE INPUT #n," statements */
 gulix(line_S);
 leng_int = LEN(line_S);
 if(strcmp(LEFT_S(line_S, 12), "LINE INPUT #") == 0 || strcmp(LEFT_S(line_S, 7), "INPUT #") == 0)
 {
  g_int = 8;
  jflg_int = 1;
  while(strcmp(MID_S(line_S, g_int, 1), ",") != 0 && g_int < leng_int)
  {
   g_int = g_int + 1;
  }
  if(g_int == leng_int)
  {
   fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR in line No",nl_int,":",line_S);
   signal_int = 1;   /* exit(1); */
   goto Lab_9999;
  }
  else
  {
   strcpy(line_S,MID_S(line_S, g_int + 1, leng_int - g_int));
   /* GOSUB Lab_735 */ 
   if (setjmp(j__buf[j__lev++])==0) goto Lab_735;
   /* RETURN */
   longjmp(j__buf[--j__lev],1);
  }
 }
 else
 {
  /*  Checking variable declarations in "INPUT" statements */
      if (memcmp(line_S, "INPUT", 5) == 0) {
  jflg_int = 1;
  if(leng_int <= 6)
  {
   fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR: missing arguments to INPUT in line No",nl_int,":",line_S);
   signal_int = 1;   /* exit(1); */
   goto Lab_9999;
  }
  else
  {
   strcpy(line_S,MID_S(line_S, 6, leng_int - 5));
   /* GOSUB Lab_735 */ 
   if (setjmp(j__buf[j__lev++])==0) goto Lab_735;
   /* RETURN */
   longjmp(j__buf[--j__lev],1);
  }
      }
  /*  Checking variable declarations in "SSCAN" statements */
      if (memcmp(line_S, "SSCAN", 5) == 0) {
  jflg_int = 1;
  if(leng_int <= 6)
  {
   fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR: missing arguments to SSCAN in line No",nl_int,":",line_S);
   signal_int = 1;   /* exit(1); */
   goto Lab_9999;
  }
  else
  {
        i_int = 5; c = line_S[i_int];
        while(c != ';' && c != '\0') {
         c = line_S[++i_int];
        }
        if(!c) goto Lab_29000;
   strcpy(line_S,MID_S(line_S, i_int + 2, LMAX));
   /* GOSUB Lab_735 */ 
   if (setjmp(j__buf[j__lev++])==0) goto Lab_735;
   /* RETURN */
   longjmp(j__buf[--j__lev],1);
  }
      }
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_735:   /* Tokenizator varijabli u INPUT, SSCAN, GIFINFO ... linijama */
 tokenix(line_S, &L_int, ",", ";");
 for(g_int = 1; g_int <= L_int; g_int++)
 {
  strcpy(z_S,tmp_S[g_int]);   /* Memorizing variable z$ */
  /* GOSUB Lab_790 */ 
  if (setjmp(j__buf[j__lev++])==0) goto Lab_790;
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_750:   /* Potraga za varijablama argumentima user SUBroutina i FUNCTIONa */
 /* WHOLE arrays cannot be passed at the moment !!!! */
 /* Array names (when possible) passed as bare names (no brackets). */
 /* Element of an array can be passed as a single number or string, */
 /* however, they are not stored here (for simplicity). */
 if(strcmp(LEFT_S(line_S, 4), "CALL") == 0)
 {
  g_int = 5;
  leng_int = LEN(line_S);
  while(! strcmp(MID_S(line_S, g_int, 1), "(") == 0 && g_int < leng_int)
  {
   g_int = g_int + 1;
  }
  if(g_int == leng_int)
  {
   /* RETURN */
   longjmp(j__buf[--j__lev],1);
  }
  j_int = leng_int;
  while(! strcmp(MID_S(line_S, j_int, 1), ")") == 0 && j_int > g_int)
  {
   j_int = j_int - 1;
  }
  if(strcmp(MID_S(line_S, j_int, 1), ")") != 0)
  {
   fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR in line No",nl_int,":",line_S);
   signal_int = 1;   /* exit(1); */
   goto Lab_9999;
  }
  strcpy(d_S,MID_S(line_S, g_int + 1, j_int - g_int - 1));
  gulix(d_S);
  /* tokenization of the CALLed SUBroutine argument list */
  tokenix(d_S, &L_int, ",", "");
  for(g_int = 1; g_int <= L_int; g_int++)
  {
   strcpy(z_S,tmp_S[g_int]);
   /* Check whether z$ is a var (rather than funct. or express.) */
   /* GOSUB Lab_755 */ 
   if (setjmp(j__buf[j__lev++])==0) goto Lab_755;
   if(tmpfl_int == 0)
   {
    if(VAL(z_S) == 0 && strcmp(LEFT_S(z_S, 1), "0") != 0)   /* Memorizing variable z$ */
    {
     /* GOSUB Lab_790 */ 
     if (setjmp(j__buf[j__lev++])==0) goto Lab_790;
    }
   }
  }
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);
Lab_755:   /* Check whether z$ is a var (not array, funct. or expr.) */
 tmpfl_int = 0;
 if(strcmp(LEFT_S(z_S, 1), e_S) == 0)
 {
  tmpfl_int = 1;
  goto Lab_756;
 }
 for(j_int = 1; j_int <= LEN(z_S); j_int++)
 {
  strcpy(b_S,MID_S(z_S, j_int, 1));
  if(strcmp(b_S, " ") == 0 || strcmp(b_S, "(") == 0)
  {
   tmpfl_int = 1;
   goto Lab_756;
  }
 }
Lab_756:
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_780:   /* Storing argumentlist of the SUB or FUNCTION */
 /* and storing of the SUB name */
 strcpy(a_S,line_S);
 j_int = 0;
 k_int = 0;
 leng_int = LEN(a_S);
 brcnt_int = 0;
 for(i_int = 4; i_int <= leng_int; i_int++)
 {
      c=a_S[i_int-1];
      if (c=='(') { if (brcnt_int++ == 0)   j_int = i_int + 1; }
      if (c==')') { if (--brcnt_int == 0) { k_int = i_int - 1; goto Lab_781; }}
 }
Lab_781:
     if(memcmp(a_S,"SUB ",4) == 0) {strcpy(b_S, &a_S[4]), b_S[j_int-6]='\0';}
     if(memcmp(a_S,"FUNC",4) == 0) {strcpy(b_S, &a_S[9]), b_S[j_int-11]='\0';}
 gulix(b_S);
 strcpy(subname_S[nsub_int],b_S);
 if(j_int == 0)
 {
  nsubvar_int[nsub_int] = 0;
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 strcpy(varlist_S,MID_S(a_S, j_int, k_int - j_int + 1));
 gulix(varlist_S);   /* varlist -> tmp$(), n% */
 tokenix(varlist_S, &n_int, ",", "");
 nsubvar_int[nsub_int] = n_int;
 if(n_int > 0)
 {
  for(g_int = 1; g_int <= n_int; g_int++)
  {
   strcpy(subvar_S[nsub_int][g_int],tmp_S[g_int]);
  }
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_790:   /* Spremanje jedne varijable z$, za deklaraciju ako je NOVA */
 /* i ako nije u SHARED i ako nije parametar doticne SUBroutine */
 /* i ako nije char konstanta "..." ili brojna konstanta eg. 3 */
 if(strcmp(z_S, fime_S) == 0)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 j_int = ASC(LEFT_S(z_S, 1));
 if((97 <= j_int && j_int <= 122 || 65 <= j_int && j_int <= 90 || 48 <= j_int && j_int <= 57))
 {
  /*       IF LEFT$(z$, 1) = e$ THEN RETURN */
          if (z_S[0] == '"') /* RETURN */ longjmp(j__buf[--j__lev],1);
  /* GOSUB Lab_795 */ 
  if (setjmp(j__buf[j__lev++])==0) goto Lab_795;
  if(nvar_int == 0 && nshtok_int[nsub_int] == 0 && nsubvar_int[nsub_int] == 0)
  {
   nvar_int = 1;
   strcpy(vlist_S[nsub_int][1],z_S);
  }
  else
  {
   for(j_int = 1; j_int <= nvar_int; j_int++)
   {
    if(strcmp(vlist_S[nsub_int][j_int], z_S) == 0)
    {
     /* RETURN */
     longjmp(j__buf[--j__lev],1);
    }
   }
   if(nsub_int == 0)
   {
    for(j_int = 1; j_int <= nSHRDtk_int; j_int++)
    {
     if(strcmp(shrd_S[j_int], z_S) == 0)
     {
      /* RETURN */
      longjmp(j__buf[--j__lev],1);
     }
    }
   }
   else
   {
    for(j_int = 1; j_int <= nshtok_int[nsub_int]; j_int++)
    {
     if(strcmp(shtok_S[nsub_int][j_int], z_S) == 0)
     {
      /* RETURN */
      longjmp(j__buf[--j__lev],1);
     }
    }
    for(j_int = 1; j_int <= nsubvar_int[nsub_int]; j_int++)
    {
     if(strcmp(subvar_S[nsub_int][j_int], z_S) == 0)
     {
      /* RETURN */
      longjmp(j__buf[--j__lev],1);
     }
    }
   }
   nvar_int = nvar_int + 1;
   strcpy(vlist_S[nsub_int][nvar_int],z_S);
  }
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_795:   /* x(...)  -->  x() */
     if (z_S[strlen(z_S)-1] == ')')
     {
      jj_int=0; while( z_S[jj_int] != '(' ) jj_int++;
      z_S[++jj_int] = ')'; z_S[++jj_int] = '\0';
     }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_800:   /* preprocessing the whole file for SHARED variables and arrays and */
 /* storing all SHARED token lists for every SUB in shtok$(jsub%,i%) */
 /* Also takes care of: DEFSTR, DEF FN */
 /* Also makes a list of dynamically declared arrays, dyna$(,), ndyna%() */
 /* Set DYNAMIC flag for SHARED arrays: dynaf_%() */
 nSHRDtk_int = 0;
 jsub_int = 0;
 narr_int = 0;
 alis_int = 0;
 flag_int = 0;
 nl_int = 0;
 g_int = 0;
 defstr_int = 0;   /* set if DEFSTR in effect (vartyp) */
 defint_int = 0;   /* set if DEFINT in effect (vartyp) */
 defdbl_int = 0;   /* set if DEFDBL in effect (vartyp) */
 deffnf_int = 0;   /* set if DEF FN occured. Then tmpfile$ is temporary filled */
 datalin_int = 0;   /* DATA lines counter */
 datacnt_int = 0;
 if((fp_3 = fopen(strcpy(fn3__S,tmpfile_S), "w")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn3__S); exit(1);
 }
 if((fp_1 = fopen(strcpy(fn1__S,inpf_S), "r")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn1__S); exit(1);
 }
 while(! eof(fp_1))
 {
  fgets(line_S, LMAX, fp_1);
  line_S[strlen(line_S) - 1] = '\0';
  nl_int = nl_int + 1;
      if(line_S[strlen(line_S)-1] == 13) line_S[strlen(line_S)-1]='\0';/*croff*/
      if(line_S[0] == '\0') goto Lab_809;
  /* GOSUB Lab_900 */    /* line splitter */
  if (setjmp(j__buf[j__lev++])==0) goto Lab_900;
  for(itok_int = 1; itok_int <= ntok_int; itok_int++)
  {
   strcpy(line_S,linetok_S[itok_int]);
   lleng_int = LEN(line_S);
       if(memcmp(line_S,"DEFSTR ",7)==0 || memcmp(line_S,"DEFINT ",7)==0 || memcmp(line_S,"DEFDBL ",7)==0) {
   strcpy(a_S,line_S);
   /* GOSUB Lab_19200 */ 
   if (setjmp(j__buf[j__lev++])==0) goto Lab_19200;
       }
       if(memcmp(line_S,"DATA ",5)==0) {
   strcpy(a_S,line_S);
   /* GOSUB Lab_19500 */ 
   if (setjmp(j__buf[j__lev++])==0) goto Lab_19500;
       }
       if(memcmp(line_S,"DEF FN",6)==0) {
   i_int = 6;
        while(line_S[i_int] != '(' && line_S[i_int]) i_int++;
   j_int = i_int + 1;
        while(line_S[j_int] != ')' && line_S[j_int]) j_int++;
   strcpy(b_S,MID_S(line_S, 5, i_int - 4));   /* fn name */
   strcpy(d_S,MID_S(line_S, 5, j_int - 3));
   fprintf(fp_3,"\n");
   fprintf(fp_3,"%s%s\n","FUNCTION ",d_S);
   fprintf(fp_3,"%s\n","REM function created from DEF FN");
   fprintf(fp_3,"%s%s%s\n"," ",b_S,MID_S(line_S, j_int + 2, LMAX));
   fprintf(fp_3,"%s\n","END FUNCTION");
   /*     PRINT #3, */
   deffnf_int = 1;
       }
       if(memcmp(line_S,"SUB ",4)==0 || memcmp(line_S,"FUNCTION ", 9)==0) {
   jsub_int = jsub_int + 1;
   g_int = 0;
       }
   if(jsub_int > NSMX)
   {
    fprintf(stderr,"%s\n","Max. number of SUBroutines and FUNCTIONs reached !");
    fprintf(stderr,"%s\n","Enlarge the NSMX parameter in qb2c.c, and recompile it !");
    signal_int = 1;   /* exit(1); */
    goto Lab_9999;
   }
   /* List of dimensioned arrays in MAIN: */
   /* (Those which are shared shall be declared in the preamble.) */
   if(jsub_int == 0 && strcmp(LEFT_S(line_S, 4), "DIM ") == 0)
   {
    if(strcmp(LEFT_S(line_S, 11), "DIM DYNAMIC") == 0)
    {
     strcpy(b_S,MID_S(line_S, 12, LMAX));
     flag_int = 1;
    }
    else
    {
     strcpy(b_S,MID_S(line_S, 4, LMAX));
     flag_int = 0;
    }
    tokenix(b_S, &ntok_int, ",", "");
    for(i_int = 1; i_int <= ntok_int; i_int++)
    {
     strcpy(temp_S[i_int],tmp_S[i_int]);
    }
    if(ntok_int > 0)
    {
     for(i_int = 1; i_int <= ntok_int; i_int++)
     {
      strcpy(d_S,temp_S[i_int]);
      arraydim(d_S);
      narr_int = narr_int + 1;
      if(narr_int >= MARR)
      {
       fprintf(stderr,"%s\n","Max. number of arrays in MAIN is reached !");
       fprintf(stderr,"%s\n","Enlarge the MARR parameter in qb2c.c, and recompile it !");
       signal_int = 1;   /* exit(1); */
       goto Lab_9999;
      }
      strcpy(darr_S[narr_int],d_S);
      dynaf__int[narr_int] = flag_int;
     }
    }
   }
   /* List of dynamically (explicite or implicite) declared arrays */
       if (memcmp(line_S, "DIM ", 4)==0) {
   if(strcmp(LEFT_S(line_S, 11), "DIM DYNAMIC") == 0)
   {
    fprintf(stderr,"%s% d %s%s\n","qb2c: REDIM feature available in pay version only.",nl_int,":",line_S);
    signal_int = 1;   /* exit(1); */
    goto Lab_9999;
   }
       }
   /* List of dynamically (explicite or implicite) declared arrays */
   if(strcmp(LEFT_S(line_S, 7), "SHARED ") == 0)
   {
    strcpy(d_S,MID_S(line_S, 8, lleng_int - 7));
    /* GOSUB Lab_810 */ 
    if (setjmp(j__buf[j__lev++])==0) goto Lab_810;
   }
  }
Lab_809:
 ;}
 fclose(fp_1);
 fclose(fp_3);
 if(deffnf_int)
 {
  sprintf(tws__S,"%s%s%s%s%s%s","cat ",inpf_S," ",tmpfile_S," > ",tmpfil0_S);
  system(tws__S);
  strcpy(inpf_S,tmpfil0_S);
 }
 /* Sorting SHARED variables */
 if(nSHRDtk_int > 0)
 {
  strcpy(sint_S,"");
  strcpy(srea_S,"");
  strcpy(ssss_S,"");
  strcpy(slin_S,"");
  strcpy(sdbl_S,"");
  for(i_int = 1; i_int <= nSHRDtk_int; i_int++)
  {
   strcpy(d_S,shrd_S[i_int]);
   strcpy(z_S,RIGHT_S(d_S, 1));
   if(strcmp(z_S, ")") != 0)
   {
    vartyp(d_S, &typ_int);
    if(typ_int == 1)
    {
     sprintf(tws__S,"%s%s%s",sint_S,d_S,", ");
     strcpy(sint_S,tws__S);
    }
    else
    {
     if(typ_int == 5)
     {
      sprintf(tws__S,"%s%s%s",ssss_S,d_S,"[LMAX], ");
      strcpy(ssss_S,tws__S);
     }
     else
     {
      if(typ_int == 2)
      {
       sprintf(tws__S,"%s%s%s",slin_S,d_S,", ");
       strcpy(slin_S,tws__S);
      }
      else
      {
       if(typ_int == 4)
       {
        sprintf(tws__S,"%s%s%s",sdbl_S,d_S,", ");
        strcpy(sdbl_S,tws__S);
       }
       else
       {
        sprintf(tws__S,"%s%s%s",srea_S,d_S,", ");
        strcpy(srea_S,tws__S);
       }
      }
     }
    }
   }
   else
   {
    for(j_int = 1; j_int <= narr_int; j_int++)
    {
     g_int = LEN(d_S) - 1;
     if(strcmp(LEFT_S(d_S, g_int), LEFT_S(darr_S[j_int], g_int)) == 0)
     {
      alis_int = alis_int + 1;
      if(alis_int >= SHMX)
      {
       fprintf(stderr,"%s\n","Maximum number of SHARED arrays reached.");
       fprintf(stderr,"%s\n","Enlarge parameter SHMX in qb2c.c, and recompile qb2c !");
       signal_int = 1;   /* exit(1); */
       goto Lab_9999;
      }
      alist_int[alis_int] = j_int;
     }
    }
   }
  }
  /* Bare variables: */
  if(strcmp(sint_S, "") != 0)
  {
   strcpy(sint_S,LEFT_S(sint_S, LEN(sint_S) - 2));
  }
  if(strcmp(srea_S, "") != 0)
  {
   strcpy(srea_S,LEFT_S(srea_S, LEN(srea_S) - 2));
  }
  if(strcmp(ssss_S, "") != 0)
  {
   strcpy(ssss_S,LEFT_S(ssss_S, LEN(ssss_S) - 2));
  }
  if(strcmp(slin_S, "") != 0)
  {
   strcpy(slin_S,LEFT_S(slin_S, LEN(slin_S) - 2));
  }
  if(strcmp(sdbl_S, "") != 0)
  {
   strcpy(sdbl_S,LEFT_S(sdbl_S, LEN(sdbl_S) - 2));
  }
 }
 if(nSHRDtk_int > TMAX)
 {
  fprintf(stderr,"%s\n","qb2c: MAIN (800): Dimension of tmp$() too small. Enlarge TMAX and recompile qb2c!");
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 for(i_int = 1; i_int <= nSHRDtk_int; i_int++)
 {
  strcpy(shtok_S[0][i_int],shrd_S[i_int]);
 }
 nshtok_int[0] = nSHRDtk_int;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_810:   /* tokenization of SHARED variables */
 leng_int = LEN(d_S);
 i_int = 1;   /* g% = 0, this is set at the beginning of a SUB */
 while(i_int <= leng_int)
 {
  if(strcmp(MID_S(d_S, i_int, 1), ",") != 0 && strcmp(MID_S(d_S, i_int, 1), " ") != 0)
  {
   j_int = i_int;
   i_int = i_int + 1;
   while(! (strcmp(MID_S(d_S, i_int, 1), ",") == 0 || strcmp(MID_S(d_S, i_int, 1), "  ") == 0 || i_int > leng_int))
   {
    i_int = i_int + 1;
   }
   strcpy(z_S,MID_S(d_S, j_int, i_int - j_int));
   g_int = g_int + 1;
   if(g_int > TMAX)
   {
    fprintf(stderr,"%s\n","qb2c: MAIN (810): Dimension of tmp$() too small. Enlarge TMAX and recompile qb2c!");
    signal_int = 1;   /* exit(1); */
    goto Lab_9999;
   }
   strcpy(shtok_S[jsub_int][g_int],z_S);
   if(nSHRDtk_int == 0)
   {
    nSHRDtk_int = 1;
    strcpy(shrd_S[1],z_S);
   }
   else
   {
    tmpfl_int = 0;
    for(L_int = 1; L_int <= nSHRDtk_int; L_int++)
    {
     if(strcmp(shrd_S[L_int], z_S) == 0)
     {
      tmpfl_int = 1;
     }
    }
    if(tmpfl_int == 0)
    {
     nSHRDtk_int = nSHRDtk_int + 1;
     strcpy(shrd_S[nSHRDtk_int],z_S);
    }
   }
  }
  i_int = i_int + 1;
 }
 nshtok_int[jsub_int] = g_int;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_900:   /* splitting one physical line line$ into ':' pieces, line splicer */
 /* Split IF lines if something after THEN and add END IF */
 /* Force splitting if line labeled */
 /* Returns (bare, gulix!) linetok$(), ntok% */
 /* C lines must never came here. */
 lleng_int = LEN(line_S);
 gulix(line_S);
 if(lleng_int == 0)
 {
  ntok_int = 0;
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 ntok_int = 0;
 tok_int[0] = 0;
 lremfl_int = 0;
 thnfl_int = 0;
 tmpfl_int = 0;
 strcpy(t_S,"");
     if (memcmp(line_S,"REM",3)==0) {
 ntok_int = 1;
 strcpy(linetok_S[1],line_S);
 /* RETURN */
 longjmp(j__buf[--j__lev],1);
     }
 g_long = VAL(line_S);
 if(g_long != 0)
 {
  strcpy(b_S,STR_S(g_long));
  strcpy(d_S,MID_S(line_S, LEN(b_S), LMAX));
  gulix(d_S);
  sprintf(line_S,"%s%s%s",b_S,": ",d_S);
  /* C     if(memcmp(d_S,"IF ",3)==0) tmpfl_int = 1; */
 }
 /* C    if(memcmp(line_S,"IF ",3)==0) tmpfl_int = 1; */
 i_int = 0;
 togfl_int = 0;
     while(i_int <= (lleng_int=strlen(line_S))) {
      c = line_S[i_int-1];
      if (c == 34) togfl_int = 1 - togfl_int;
      if (c == ':' && togfl_int == 0)
      {
 ntok_int = ntok_int + 1;
 tok_int[ntok_int] = i_int;
      }
 if(i_int >= lleng_int - 3)
 {
  goto Lab_901;
 }
      if(memcmp(&line_S[i_int-1],"IF ",3)==0 && !togfl_int) tmpfl_int=1;
      if((memcmp(&line_S[i_int-1],"GOTO",4)==0 || memcmp(&line_S[i_int-1],"GOSUB",5)==0) && !togfl_int && tmpfl_int) {
 sprintf(line_S,"%s%s%s",LEFT_S(line_S, i_int - 1),"THEN ",MID_S(line_S, i_int, LMAX));
 i_int = i_int - 1;
 tmpfl_int = 0;
 goto Lab_901;
      }
      if(memcmp(&line_S[i_int-1],"THEN",4)==0 && !togfl_int) {
 strcpy(f_S,MID_S(line_S, i_int + 4, LMAX));
 gulix(f_S);
 tmpfl_int = 0;
 if(strcmp(f_S, "") == 0)   /* Not inline */
 {
  goto Lab_902;
 }
 if(VAL(f_S) == 0)
 {
  sprintf(line_S,"%s%s%s",LEFT_S(line_S, i_int + 3),":",MID_S(line_S, i_int + 4, LMAX));
 }
 else
 {
  sprintf(line_S,"%s%s%s",LEFT_S(line_S, i_int + 3),": GOTO",MID_S(line_S, i_int + 4, LMAX));
 }
 thnfl_int = thnfl_int + 1;
 i_int = i_int + 3;
 goto Lab_901;
      }
      if(memcmp(&line_S[i_int-1],"ELSE ",5)==0 && !togfl_int) {
 strcpy(f_S,MID_S(line_S, i_int + 4, LMAX));
 gulix(f_S);
 if(VAL(f_S) == 0)
 {
  sprintf(line_S,"%s%s%s%s%s",LEFT_S(line_S, i_int - 2),":",MID_S(line_S, i_int - 1, 5),":",MID_S(line_S, i_int + 4, LMAX));
 }
 else
 {
  sprintf(line_S,"%s%s%s%s%s",LEFT_S(line_S, i_int - 2),":",MID_S(line_S, i_int - 1, 5),": GOTO",MID_S(line_S, i_int + 4, LMAX));
 }
 ntok_int = ntok_int + 1;
 tok_int[ntok_int] = i_int - 1;
 i_int = i_int + 4;
 goto Lab_901;
      }
      if(memcmp(&line_S[i_int-1],"REM ",4)==0 && !togfl_int) {
 strcpy(t_S,MID_S(line_S, i_int + 4, LMAX));
 strcpy(line_S,LEFT_S(line_S, i_int - 3));
 gulix(t_S);
 j_int = LEN(line_S);
 lremfl_int = 1;
 goto Lab_902;
      }
Lab_901:
 i_int = i_int + 1;
     } /*LOOP*/
Lab_902:   /* Add eventual END IF's to inlines */
 if(lremfl_int == 1)
 {
  ntok_int = ntok_int - 1;
 }
 for(i_int = 1; i_int <= thnfl_int; i_int++)
 {
  ntok_int = ntok_int + 1;
  tok_int[ntok_int] = LEN(line_S) + 1;
  sprintf(tws__S,"%s%s",line_S,": END IF");
  strcpy(line_S,tws__S);
 }
 ntok_int = ntok_int + 1;
 tok_int[ntok_int] = LEN(line_S) + 1;
Lab_903:   /* split the line in tokens separated by ":" */
 for(i_int = 1; i_int <= ntok_int; i_int++)
 {
  strcpy(b_S,MID_S(line_S, tok_int[i_int - 1] + 1, tok_int[i_int] - tok_int[i_int - 1] - 1));
      if (memcmp(b_S, "LET ", 4) == 0) memmove(b_S, &b_S[4], strlen(b_S)-3);
  gulix(b_S);
  strcpy(linetok_S[i_int],b_S);
 }
 /*  PRINT line$ */
 /*  FOR i% = 1 TO ntok% */
 /*   PRINT linetok$(i%) */
 /*  NEXT i% */
 /*  PRINT t$ */
 /*  PRINT "Izasao 900!" */
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_1000:   /* "SUB name(varlist...)", "FUNCTION name(varlist...)" */
 if(commfl_int == 1)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 if(strcmp(LEFT_S(a_S, 4), "SUB ") == 0)
 {
  xtmpfl_int = 0;
  goto Lab_1001;
 }
 if(strcmp(LEFT_S(a_S, 9), "FUNCTION ") == 0)
 {
  xtmpfl_int = 1;
  funcflag_int = 1;
  nfuncs_int = nfuncs_int + 1;
  goto Lab_1001;
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);
Lab_1001:
 isub_int = isub_int + 1;
 jopn_int = 0;
 lspac_int = 1;
 strcpy(spc_S,SPACE_S(lspac_int));
 statfl_int[isub_int] = 0;
 funcfl_int[isub_int] = xtmpfl_int;
 /* GOSUB Lab_31000 */    /* Make a list of possibly used arrays in the current sub */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_31000;
 leng_int = LEN(a_S);
 for(i_int = 4; i_int <= leng_int; i_int++)
 {
  if(strcmp(RIGHT_S(a_S, 7), " STATIC") == 0)
  {
   strcpy(a_S,LEFT_S(a_S, leng_int - 7));
   gulix(a_S);
   leng_int = LEN(a_S);
   statfl_int[isub_int] = 1;   /* Static variables flag */
  }
 }
 if(nsubvar_int[isub_int] == 0 && strcmp(RIGHT_S(a_S, 2), "()") != 0)
 {
  j_int = leng_int + 2;
  k_int = j_int;
  strcpy(varlist_S,"");
 }
 else
 {
  for(i_int = 4; i_int <= leng_int; i_int++)
  {
   strcpy(b_S,MID_S(a_S, i_int, 1));
   if(strcmp(b_S, "(") == 0)
   {
    j_int = i_int + 1;
   }
   if(strcmp(b_S, ")") == 0)
   {
    k_int = i_int - 1;
   }
  }
  strcpy(varlist_S,MID_S(a_S, j_int, k_int - j_int + 1));
 }
 if(funcfl_int[isub_int] == 0)
 {
  strcpy(prtf_S,MID_S(a_S, 4, j_int - 5));
  gulix(prtf_S);
 }
 else
 {
  strcpy(prtf_S,MID_S(a_S, 9, j_int - 10));
  gulix(prtf_S);
  strcpy(funames_S[nfuncs_int],prtf_S);
  strcpy(funcnam_S,prtf_S);
 }
 if(xtmpfl_int == 0)
 {
  sprintf(tws__S,"%s%s%s","int ",prtf_S,"(");
  strcpy(prtf_S,tws__S);
 }
 else
 {
  vartyp(prtf_S, &typ_int);
  strcpy(z_S,"");
  if(typ_int == 5)
  {
   strcpy(z_S,"*");
  }
  sprintf(tws__S,"%s%s%s%s%s","extern ",atyp_S[typ_int],z_S,prtf_S,"(");
  strcpy(prtf_S,tws__S);
 }
 tokenix(varlist_S, &n_int, ",", "");
 strcpy(c_S,"");
 strcpy(b_S,"");
 /*  IF funcfl%(isub%) = 0 THEN b$ = "*" Instead of this below is... */
 /*  a trashy solution for string argument to function (no copy to temp) */
 for(i_int = 1; i_int <= n_int; i_int++)
 {
  strcpy(d_S,tmp_S[i_int]);   /* type determination */
  /* GOSUB Lab_1010 */ 
  if (setjmp(j__buf[j__lev++])==0) goto Lab_1010;
      b_S[0] = '\0';
  if(funcfl_int[isub_int] == 0 || funcfl_int[isub_int] && (typ_int == 5 || typ_int == 15 || typ_int == 25))
  {
   strcpy(b_S,"*");
  }
  sprintf(tws__S,"%s%s%s%s%s",prtf_S,e_S,b_S,tmp_S[i_int],", ");
  strcpy(prtf_S,tws__S);
  gulix(e_S);
  sprintf(tws__S,"%s%s%s%s",c_S,e_S,b_S,", ");   /* This is */
  strcpy(c_S,tws__S);
 }
 /*  c$ is a prototyping sequence of types, used only for FUNCTIONs */
 /*  SUBs are declared implicitly (int) */
 if(n_int)
 {
  strcpy(prtf_S,LEFT_S(prtf_S, LEN(prtf_S) - 2));
 }
 if(xtmpfl_int == 1)
 {
  if(strcmp(c_S, "") != 0)
  {
   strcpy(c_S,LEFT_S(c_S, LEN(c_S) - 2));
  }
  strcpy(funtyl_S[nfuncs_int],c_S);
 }
 fprintf(fp_2,"\n");
 fprintf(fp_2,"%s\n","/*- User SUB--Start -*/");   /* Do not change, used in post. 45000 */
 fprintf(fp_2,"%s%s%s\n",prtf_S,")",t_S);
 fprintf(fp_2,"%s\n","{");
 commfl_int = 1;
 usersub_int = 1;
 if(nshtok_int[isub_int] > 0)
 {
  /* comment on shared variables */
  strcpy(b_S,"");
  for(j_int = 1; j_int <= nshtok_int[isub_int]; j_int++)
  {
   sprintf(tws__S,"%s%s%s",b_S,shtok_S[isub_int][j_int],", ");
   strcpy(b_S,tws__S);
  }
  strcpy(b_S,LEFT_S(b_S, LEN(b_S) - 2));
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 3;
  i__s = (i__s + 0 ) % 16;
  splitdec(b_S, &n_int, &w__s[(i__stmp+0)%16]);
  for(j_int = 1; j_int <= n_int; j_int++)
  {
   fprintf(fp_2,"%s%s%s\n","/* SHARED: ",tmp_S[j_int]," */");
  }
  fprintf(fp_2,"\n");
 }
 /* lista varijabli: */
 tmpfl_int = 0;
 strcpy(int_S," int  ");
 strcpy(float_S," float ");
 if(longflg_int == 1)
 {
  strcpy(int_S," long ");
 }
 if(doblflg_int == 1)
 {
  strcpy(float_S," double ");
 }
 if(strcmp(vari_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 3;
  i__s = (i__s + 0 ) % 16;
  declarix(int_S, vari_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(strcmp(varr_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 0;
  i__s = (i__s + 0 ) % 16;
  declarix(float_S, varr_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(strcmp(vars_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 1;
  i__s = (i__s + 0 ) % 16;
  declarix(" char ", vars_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(strcmp(varl_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 4;
  i__s = (i__s + 0 ) % 16;
  declarix(" long ", varl_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(strcmp(vard_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 0;
  i__s = (i__s + 0 ) % 16;
  declarix(" double ", vard_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(strcmp(varb_S[isub_int], "") != 0)
 {
  i__stmp = ++i__s % 16;
  w__s[(i__stmp + 0 ) % 16] = 0;
  i__s = (i__s + 0 ) % 16;
  declarix(" unsigned char ", varb_S[isub_int], &w__s[(i__stmp+0)%16]);
  tmpfl_int = 1;
 }
 if(tmpfl_int == 1)
 {
  fprintf(fp_2,"\n");
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_1010:   /* sorting variable types (default) */
 vartyp(d_S, &typ_int);
 if((typ_int == 0 || typ_int > 5) && typ_int != 8)
 {
  printf("%s%s%s% d %s\n","Error at label 1010 of QB2C: vartyp of ",d_S," is",typ_int,"...");
  printf("%s% d %s%s\n","...in line No",nl_int,": ",a_S);
  exit(0);
 }
 else
 {
  strcpy(e_S,atyp_S[typ_int]);
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_1250:   /* "SHARED" - this is already taken care of, just skip */
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_1400:   /* Braces count check */
 lspac_int = lspac_int - 1;
 strcpy(spc_S,SPACE_S(lspac_int));
 if(lspac_int < 0)
 {
  printf("%s% d %s% d %s%s\n","WARNING! Braces count = ",lspac_int," at line: ",nl_int,":",line_S);
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_1500:   /* "END" */
 /* PRINT "1500: END" */
 /* Syntax: END  -> exit(0); END(n) -> exit(n); */
 /* MUST be parsed after END IF, END FUNCTION and END SUB */
     if(strlen(a_S) > 3 && a_S[3] != '(') goto Lab_29000;
     if(a_S[i_int=3]=='(') {
      while(a_S[i_int] && a_S[i_int] != ')') i_int++;
      memcpy(b_S, &a_S[4], i_int-4); b_S[i_int-4]='\0';
 /* PRINT i%, b$ */
 fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"exit(",b_S,");",t_S);
     } else {
 fprintf(fp_2,"%s%s%s\n",spc_S,"exit(0);",t_S);
     }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_2000:   /* "REM" */
 if(commfl_int == 1)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 if(strcmp(LEFT_S(a_S, 3), "REM") == 0)
 {
  if(LEN(a_S) == 3)
  {
   goto Lab_2001;
  }
  sprintf(prtf_S,"%s%s%s","/*",MID_S(a_S, 4, LMAX)," */");
  fprintf(fp_2,"%s%s\n",spc_S,prtf_S);
  if(isub_int == 0)
  {
   ni_int = ni_int + 1;
  }
Lab_2001:
  commfl_int = 1;
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_2500:   /* "DECLARE" */
 commfl_int = 1;
 if(isub_int == 0)
 {
  initline_int = ni_int;
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_2600:   /* "CONST", this has been taken care of in pp 650 */
 strcpy(b_S,MID_S(a_S, 6, LMAX));
 tokenix(b_S, &n_int, ",", "");
 if(n_int == 0)
 {
  fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR in line No",nl_int,":",line_S);
  fprintf(stderr,"%s\n","Missing argument of CONST");
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 if(ncnst_int > NCMX)
 {
  fprintf(stderr,"%s\n","Maximum number of CONStant declarations reached.");
  fprintf(stderr,"%s\n","Enlarge parameter NCMX in qb2c.c, and recompile it !");
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 for(i_int = n_int; i_int >= 1; i_int = i_int-1)
 {
  strcpy(tmp_S[i_int + 2],tmp_S[i_int]);
 }
 for(i_int = 1; i_int <= n_int; i_int++)
 {
  tokenix(tmp_S[i_int + 2], &j_int, "=", "");
  if(j_int != 2)
  {
   fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR in line No",nl_int,":",a_S);
   signal_int = 1;   /* exit(1); */
   goto Lab_9999;
  }
  ncnst_int = ncnst_int + 1;
  sprintf(cnst_S[ncnst_int],"%s%s%s%s%s","#define ",tmp_S[1]," ",tmp_S[2],t_S);
  strcpy(tcnst_S[ncnst_int],tmp_S[1]);
 }
 commfl_int = 1;
 if(isub_int == 0)
 {
  initline_int = ni_int;
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_2750:   /* "DIM " */
 /* Dimension arrays. Syntax: */
 /* DIM [DYNAMIC] array(dim)[, array(dim)[, ...]] */
 /* A dynamic array must be declared before the line where it is used */
 commfl_int = 1;   /* flag set if explicite dynamic */
 flag_int = 0;
 strcpy(b_S,MID_S(a_S, 5, LMAX));
 if(strcmp(LEFT_S(b_S, 7), "DYNAMIC") == 0)
 {
  flag_int = 1;
  strcpy(b_S,MID_S(a_S, 12, LMAX));
 }
 gulix(b_S);
 tokenix(b_S, &n_int, ",", "");
 if(n_int == 0)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 for(i_int = 1; i_int <= n_int; i_int++)
 {
  strcpy(temp_S[i_int],tmp_S[i_int]);
 }
 for(i_int = 1; i_int <= n_int; i_int++)
 {
  strcpy(d_S,temp_S[i_int]);
  dflag_int = 0;   /* set if dynamic (expl. or impl.) */
  if(flag_int)
  {
   dflag_int = 1;
  }
  else
  {
   /* Check for implicitly dynamic arrays: */
   for(j_int = 1; j_int <= ndyna_int[isub_int]; j_int++)
   {
    if(strcmp(dyna_S[isub_int][j_int], d_S) == 0)
    {
     dflag_int = 1;
     j_int = ndyna_int[isub_int];
    }
   }
  }
  arraydim(d_S);
  if(isub_int == 0 && ! dflag_int)
  {
   for(j_int = 1; j_int <= alis_int; j_int++)
   {
    if(strcmp(d_S, darr_S[alist_int[j_int]]) == 0)
    {
     goto Lab_2755;
    }
   }
  }
  else
  {
   /* Tu nesto fali ????? */
  }
  vartyp(d_S, &typ_int);
  /* GOSUB Lab_2760 */    /* Get rid of dimensions & memorize arr. to atmp$() */
  if (setjmp(j__buf[j__lev++])==0) goto Lab_2760;
  if(dflag_int)
  {
   strcpy(b_S,"");
   tokenix(c_S, &L_int, ",", "");
   for(j_int = 1; j_int <= L_int; j_int++)
   {
    sprintf(tws__S,"%s%s%s%s",b_S,"*(",tmp_S[j_int],")");
    strcpy(b_S,tws__S);
   }
   strcpy(c_S,atyp_S[typ_int - 10]);
   gulix(c_S);
   if(typ_int == 15)
   {
    sprintf(tws__S,"%s%s",b_S,"*LMAX");
    strcpy(b_S,tws__S);
   }
   sprintf(prtf_S,"%s%s%s%s%s%s%s%s"," ",LEFT_S(z_S, LEN(z_S) - 1)," = calloc(",MID_S(b_S, 2, LMAX),", sizeof(",c_S,"));",t_S);
  }
  else
  {
   brackets(d_S);
   sprintf(prtf_S,"%s%s%s%s%s"," static ",atyp_S[typ_int - 10],d_S,";",t_S);
  }
  fprintf(fp_2,"%s\n",prtf_S);
  if(isub_int == 0 && ! flag_int)
  {
   ni_int = ni_int + 1;
   initline_int = ni_int;
  }
Lab_2755:
 ;}
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_2760:   /* Get rid of dimensions & memorize arrayname to atmp$() if new */
 /* don't change the d$. c$ is the array argument (list). */
 /* This dynamically fills atmp$() for a current SUB or MAIN */
 strcpy(z_S,"");
 jj_int = 0;
      while (d_S[jj_int]!= '(' && d_S[jj_int] !='\0') jj_int++;
 strcpy(z_S,LEFT_S(d_S, jj_int + 1));
 k_int = jj_int + 1;
      while (d_S[k_int]!= ')' && d_S[k_int] !='\0') k_int++;
 strcpy(c_S,MID_S(d_S, jj_int + 2, k_int - jj_int - 1));
 tmpfl_int = 1;
 for(j_int = 1; j_int <= natmp_int; j_int++)
 {
  if(strcmp(z_S, atmp_S[j_int]) == 0)
  {
   tmpfl_int = 0;
   goto Lab_2761;
  }
 }
Lab_2761:
 if(tmpfl_int == 1)
 {
  natmp_int = natmp_int + 1;
  strcpy(atmp_S[natmp_int],z_S);
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_2800:   /* "ERASE " */
 fprintf(stderr,"%s% d %s%s\n","qb2c: ERASE feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_2850:   /* "REDIM " */
 fprintf(stderr,"%s% d %s%s\n","qb2c: REDIM feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_3000:   /* "IF ... THEN ... [ELSEIF ... THEN] ... ELSE ...END IF" */
 /* Prema QB sintaksi IF, ELSEIF, ELSE i END IF moraju zapocinjati liniju */
 /* osim u dopustenim inline sintaksama. Kod njih, izraz se sijece */
 /* u multilinijski tip i dodaje se END IF na kraju */
 /* Inline se sijeku na nivou line splitera, 900. */
 /* Syntax, inline: */
 /* IF bool THEN expr */
 /* IF bool THEN expr ELSE expr */
 /* IF bool THEN expr ELSE IF expr THEN expr */
 /* IF bool GOTO 100 */
 /* IF bool GOSUB 100 */
 /* In inline syntax, after THEN and ELSE may be only a label,for example: */
 /* IF a = b THEN 100 ELSE 200 */
 /* or multiline: */
 /* IF bool THEN */
 /*  expr */
 /* [[ELSEIF bool THEN */
 /*  expr] */
 /* [ELSE */
 /*  expr]] */
 /* END IF */
 stringx(a_S);   /* String constant preprocessor */
 strcpy(e_S,CHR_S(34));
 togfl_int = 0;
 leng_int = LEN(a_S);
 i1_int = 4;
 i2_int = 0;
 for(j_int = 5; j_int <= leng_int - 3; j_int++)
 {
       if(a_S[j_int-1] == 34) togfl_int = 1 - togfl_int;
       if((memcmp(&a_S[j_int-1],"THEN",4)==0 || memcmp(&a_S[j_int-1],"GOTO",4)==0 || memcmp(&a_S[j_int-1],"GOSUB",5)==0) && !togfl_int)
       { i2_int=j_int-2; goto Lab_3005; }
 }
 fprintf(stderr,"%s% d %s%s\n","qb2c: SYNTAX ERROR in line No",nl_int,":",line_S);
 fprintf(stderr,"%s\n","qb2c: Missing keyword: THEN or GOTO or GOSUB");
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
Lab_3005:
 if(i2_int != 0)
 {
  strcpy(b_S,MID_S(a_S, i1_int, i2_int - i1_int + 1));
  gulix(b_S);
  mathexp(b_S);
  logix(b_S);
  quadrix(b_S);
  sprintf(prtf_S,"%s%s%s","if(",b_S,")");
  fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
  fprintf(fp_2,"%s%s\n",spc_S,"{");
  lspac_int = lspac_int + 1;
  strcpy(spc_S,SPACE_S(lspac_int));
  commfl_int = 1;
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_3100:   /* "ELSEIF " */
 /* Syntax: ELSEIF bool THEN */
 if(strcmp(RIGHT_S(a_S, 4), "THEN") != 0)
 {
  fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR: missing or misplaced THEN at line: ",nl_int,":",line_S);
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 strcpy(b_S,MID_S(a_S, 7, LEN(a_S) - 10));
 gulix(b_S);
 gulix(b_S);
 mathexp(b_S);
 logix(b_S);
 quadrix(b_S);
 fprintf(fp_2,"%s%s\n",SPACE_S(lspac_int - 1),"}");
 fprintf(fp_2,"%s%s%s%s%s\n",SPACE_S(lspac_int - 1),"else if (",b_S,") ",t_S);
 fprintf(fp_2,"%s%s\n",SPACE_S(lspac_int - 1),"{");
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_3250:   /* "ELSE" */
 fprintf(fp_2,"%s%s\n",SPACE_S(lspac_int - 1),"}");
 fprintf(fp_2,"%s%s%s\n",SPACE_S(lspac_int - 1),"else",t_S);
 fprintf(fp_2,"%s%s\n",SPACE_S(lspac_int - 1),"{");
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_3500:   /* "END IF" */
 fprintf(fp_2,"%s%s\n",SPACE_S(lspac_int - 1),"}");
 lspac_int = lspac_int - 1;
 strcpy(spc_S,SPACE_S(lspac_int));
 if(lspac_int < 0)
 {
  fprintf(stderr,"%s% d %s% d %s%s\n","ERROR: Braces count = ",lspac_int," at line: ",nl_int,":",line_S);
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_3750:   /* "DO WHILE" or "WHILE" */
 stringx(a_S);   /* String constant pretprocessor */
      if( memcmp(a_S,"DO WHILE",8)==0 ) { strcpy(b_S,&a_S[8]); goto Lab_3751; }
      if( memcmp(a_S,"WHILE",5)==0 )    { strcpy(b_S,&a_S[5]); goto Lab_3751; }
      if( memcmp(a_S,"DO UNTIL",8)==0 )
      { strcpy(b_S,"NOT ("); strcat(b_S,&a_S[9]); strcat(b_S,")"); }
Lab_3751:
 gulix(b_S);
 mathexp(b_S);
 logix(b_S);
 quadrix(b_S);
 sprintf(prtf_S,"%s%s%s","while(",b_S,")");
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 fprintf(fp_2,"%s%s\n",spc_S,"{");
 lspac_int = lspac_int + 1;
 strcpy(spc_S,SPACE_S(lspac_int));
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_3900:   /* "LOOP" or "WEND" */
 fprintf(fp_2,"%s%s\n",SPACE_S(lspac_int - 1),"}");
 lspac_int = lspac_int - 1;
 strcpy(spc_S,SPACE_S(lspac_int));
 if(lspac_int < 0)
 {
  printf("%s% d %s% d %s%s\n","WARNING! Braces count = ",lspac_int," at line: ",nl_int,":",line_S);
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_4000:   /* "PRINT #" */
 stringx(a_S);   /* String constant pretprocessor */
 leng_int = LEN(a_S);
 commfl_int = 1;
 i_int = 1;
 while(! strcmp(MID_S(a_S, i_int, 1), "#") == 0 && i_int < leng_int)
 {
  i_int = i_int + 1;
 }
 j_int = i_int + 1;
 while(! strcmp(MID_S(a_S, j_int, 1), ",") == 0 && j_int <= leng_int)
 {
  j_int = j_int + 1;
 }
 strcpy(b_S,MID_S(a_S, i_int + 1, j_int - i_int - 1));
 gulix(b_S);
 strcpy(d_S,MID_S(a_S, j_int + 1, leng_int - j_int));
 gulix(d_S);
 if(strcmp(d_S, "") == 0)
 {
  sprintf(prtf_S,"%s%s%s%s%s%s%s","fprintf(fp_",b_S,",",CHR_S(34),"\\n",CHR_S(34),");");
 }
 else
 {
  printfmt(d_S, formt_S, prt_S, &nflag_int);
  quadrix(prt_S);
  if(nflag_int == 1)
  {
   sprintf(tws__S,"%s%s",formt_S,"\\n");
   strcpy(formt_S,tws__S);
  }
  sprintf(prtf_S,"%s%s%s%s%s%s%s%s","fprintf(fp_",b_S,",",CHR_S(34),formt_S,CHR_S(34),prt_S,");");
 }
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_4100:   /* "PRINT USING" */
 strcpy(e_S,CHR_S(34));
 nflag_int = 1;
      if (a_S[strlen(a_S)-1]==';') {nflag_int = 0; a_S[strlen(a_S)-1]='\0';}
      while(a_S[i_int] != ';' && a_S[i_int]) i_int++;
      if (!a_S[i_int]) {
 fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR Missing ';' in line No",nl_int,": ",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
      }
 strcpy(using_S,MID_S(a_S, 12, i_int - 11));
 gulix(using_S);
 strcpy(a_S,MID_S(a_S, i_int + 2, LMAX));
 gulix(a_S);
 strcpy(formt_S,"");
 strcpy(d_S,"");
 tokenix(a_S, &n_int, ",", "");
 for(i_int = 1; i_int <= n_int; i_int++)
 {
  vartyp(tmp_S[i_int], &typ_int);
  if(typ_int >= 10 || typ_int == 6)
  {
   quadrix(tmp_S[i_int]);
  }
  if(typ_int > 10)
  {
   typ_int = typ_int - 10;
  }
  if(typ_int == 5)
  {
   sprintf(tws__S,"%s%s",formt_S,"s");
   strcpy(formt_S,tws__S);
   sprintf(tws__S,"%s%s%s",d_S,",",tmp_S[i_int]);   /* Simplified string treatment */
   strcpy(d_S,tws__S);
  }
  else
  {
   sprintf(tws__S,"%s%s",formt_S,"f");
   strcpy(formt_S,tws__S);
   if(typ_int <= 2 || typ_int == 6)
   {
    sprintf(tws__S,"%s%s%s%s",d_S,",(double)(",tmp_S[i_int],")");
    strcpy(d_S,tws__S);
   }
   else
   {
    sprintf(tws__S,"%s%s%s",d_S,",",tmp_S[i_int]);
    strcpy(d_S,tws__S);
   }
  }
 }
 if(nflag_int == 1)
 {
  sprintf(tws__S,"%s%s",formt_S,"n");
  strcpy(formt_S,tws__S);
 }
 sprintf(prtf_S,"%s%s%s%s%s%s%s%s%s","printf(print__using(",using_S,",",e_S,formt_S,e_S,")",d_S,");");
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 usingff_int = 1;
 extrnfl_int = 1;
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_4200:   /* "GET #" file I/O statment */
 fprintf(stderr,"%s% d %s%s\n","qb2c: GET # feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_4300:   /* "PUT #" file I/O statment */
 fprintf(stderr,"%s% d %s%s\n","qb2c: PUT # feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_4400:   /* "SEEK " file I/O statment */
 fprintf(stderr,"%s% d %s%s\n","qb2c: SEEK feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_4500:   /* "LINE INPUT #" */
 leng_int = LEN(a_S);
 commfl_int = 1;
 i_int = 12;
 strcpy(prtf_S,"fgets(");
 j_int = i_int + 1;
 while(! strcmp(MID_S(a_S, j_int, 1), ",") == 0 && j_int <= leng_int)
 {
  j_int = j_int + 1;
 }
 if(j_int >= leng_int)
 {
  fprintf(stderr,"%s% d %s%s\n","ERROR in line No",nl_int,":",a_S);
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 strcpy(b_S,MID_S(a_S, i_int + 1, j_int - i_int - 1));
 gulix(b_S);
 strcpy(d_S,MID_S(a_S, j_int + 1, leng_int - j_int));
 gulix(d_S);
 quadrix(d_S);
 sprintf(tws__S,"%s%s%s%s%s",prtf_S,d_S,", LMAX, fp_",b_S,");");
 strcpy(prtf_S,tws__S);
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 fprintf(fp_2,"%s%s%s%s%s\n",spc_S,d_S,"[strlen(",d_S,") - 1] = '\\0';");
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_4600:   /* "OUT " I/O statement */
 /* Syntax: OUT port, data */
 strcpy(d_S,MID_S(a_S, 4, LMAX));
 tokenix(d_S, &n_int, ",", "");
 if(n_int != 2)
 {
  goto Lab_29500;
 }
 fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"outb(",tmp_S[2],",",tmp_S[1],");",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_5000:   /* "PRINT" */
      if( a_S[0] == 'E' ) {
 strcpy(prtf_S,"fprintf(stderr,");
      } else {
 strcpy(prtf_S,"printf(");
      }
 if(strcmp(a_S, "PRINT") == 0 || strcmp(a_S, "EPRINT") == 0)
 {
  strcpy(formt_S,"\\n");
  strcpy(prt_S,"");
  goto Lab_5001;
 }
 stringx(a_S);   /* String constant pretprocessor */
 strcpy(a_S,MID_S(a_S, 7, LMAX));
 gulix(a_S);
 printfmt(a_S, formt_S, prt_S, &nflag_int);   /* tokenizacija list varijabli itd. => formt$ */
 quadrix(prt_S);
 if(nflag_int == 1)
 {
  sprintf(tws__S,"%s%s",formt_S,"\\n");
  strcpy(formt_S,tws__S);
 }
Lab_5001:
 sprintf(tws__S,"%s%s%s%s%s%s",prtf_S,CHR_S(34),formt_S,CHR_S(34),prt_S,");");
 strcpy(prtf_S,tws__S);
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_5100:   /* "LOCATE " */
 strcpy(d_S,MID_S(a_S, 8, LMAX));
 tokenix(d_S, &n_int, ",", "");
 if(n_int != 2)
 {
  fprintf(stderr,"%s% d %s%s\n","qb2c: SYNTAX ERROR in line No",nl_int,":",a_S);
  fprintf(stderr,"%s\n","qb2c: Must be two arguments to LOCATE!");
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 strcpy(b_S,tmp_S[1]);
 strcpy(d_S,tmp_S[2]);
 mathexp(b_S);
 mathexp(d_S);
 quadrix(b_S);
 sprintf(prtf_S,"%s%s%s%s%s%s%s%s%s","printf(",CHR_S(34),"\\033[%d;%d;f",CHR_S(34),",(int)(",b_S,"),(int)(",d_S,"));");
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_5200:   /* "COLOR" */
 strcpy(d_S,MID_S(a_S, 6, LMAX));
 gulix(d_S);
 if(strcmp(d_S, "") == 0)
 {
  fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"printf(",CHR_S(34),"\\033[0m",CHR_S(34),");",t_S);
  goto Lab_5201;
 }
 tokenix(d_S, &n_int, ",", "");
 if(n_int > 2)
 {
  fprintf(stderr,"%s% d %s%s\n","qb2c: SYNTAX ERROR in line No",nl_int,":",a_S);
  fprintf(stderr,"%s\n","qb2c: Must be one or two arguments to COLOR!");
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 strcpy(b_S,tmp_S[1]);
 mathexp(b_S);
 quadrix(b_S);
 if(n_int == 1)
 {
  fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"COLOR((int)(",b_S,"), -1);",t_S);
 }
 else
 {
  strcpy(d_S,tmp_S[2]);
  mathexp(d_S);
  quadrix(b_S);
  fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"COLOR((int)(",b_S,"), (int)(",d_S,"));",t_S);
 }
 colorff_int = 1;
 extrnfl_int = 1;
Lab_5201:
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_5300:   /* "CLS" */
 strcpy(b_S,MID_S(a_S, 4, LMAX));
 gulix(b_S);
 if(strcmp(b_S, "") == 0)
 {
  sprintf(prtf_S,"%s%s%s%s%s","printf(",CHR_S(34),"\\033[2J\\033[H",CHR_S(34),");");
 }
 else
 {
  mathexp(b_S);
  quadrix(b_S);
  sprintf(prtf_S,"%s%s%s","CLS((int)(",b_S,"));");
  clsff_int = 1;
  extrnfl_int = 1;
 }
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_5500:   /* "INPUT #" */
 leng_int = LEN(a_S);
 commfl_int = 1;
 i_int = 8;
 strcpy(e_S,CHR_S(34));
 while(! strcmp(MID_S(a_S, i_int, 1), ",") == 0 && i_int < leng_int)
 {
  i_int = i_int + 1;
 }
 if(i_int >= leng_int)
 {
  fprintf(stderr,"%s% d %s%s\n","ERROR in line No",nl_int,":",a_S);
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 strcpy(b_S,MID_S(a_S, 8, i_int - 8));
 gulix(b_S);
 L_int = VAL(b_S);
 strcpy(d_S,MID_S(a_S, i_int + 1, LMAX));
 gulix(d_S);
 if(strcmp(t_S, "") != 0)
 {
  fprintf(fp_2,"%s%s\n",spc_S,t_S);
 }
 i__stmp = ++i__s % 16;
 w__s[(i__stmp + 0 ) % 16] = 0;
 i__s = (i__s + 0 ) % 16;
 inputfmt(d_S, formt_S, prt_S, &n_int, &w__s[(i__stmp+0)%16]);
 quadrix(prt_S);
 /* GOSUB Lab_5505 */    /* get filename */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_5505;
 if(n_int == -1)
 {
  fprintf(fp_2,"%s%s%s%s%s%s\n",spc_S,"while(fgets(",d_S,", LMAX, fp_",b_S,")==NULL)");
  fprintf(fp_2,"%s%s%s%s%s%s%s%s\n",spc_S,"{ printf(",e_S,"Error in reading (probably EOF) file: %s\\n",e_S,",fn",b_S,"__S); exit(0);}");
  fprintf(fp_2,"%s%s%s%s%s\n",spc_S,d_S,"[strlen(",d_S,") - 1] = '\\0';");
 }
 else
 {
  /*    PRINT #2, spc$ + "if(fscanf(fp_" + b$ + "," + e$ + formt$ + " " + e$ + prt$ + ") !=" + STR$(n%) + ")" */
  fprintf(fp_2,"%s%s%s%s\n",spc_S,"fgets(tws__S, LMAX, fp_",b_S,");");
  fprintf(fp_2,"%s%s%s%s%s%s%s%s%s\n",spc_S,"if(sscanf(tws__S,",e_S,formt_S,e_S,prt_S,") !=",STR_S(n_int),")");
  fprintf(fp_2,"%s%s%s%s%s%s%s%s\n",spc_S,"{ printf(",e_S,"Error in reading file: %s\\n",e_S,",fn",b_S,"__S); }");
  twsflg_int = 1;
 }
 chartfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_5505:   /* get filename */
 i_int = 1;
 while(lfopen_int[i_int] != L_int && i_int <= nlopen_int)
 {
  i_int = i_int + 1;
 }
 if(i_int > nlopen_int)
 {
  sprintf(f_S,"%s%s",e_S,e_S);
 }
 else
 {
  strcpy(f_S,lfopen_S[i_int]);
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_5600:   /* "SSCAN " */
 strcpy(e_S,CHR_S(34));
      i_int = 5; c = a_S[i_int];
      while(c != ';' && c != '\0') {
       c = a_S[++i_int];
      }
      if(!c) goto Lab_29000;
 strcpy(b_S,MID_S(a_S, 7, i_int - 6));
 strcpy(d_S,MID_S(a_S, i_int + 2, LMAX));
 quadrix(b_S);
 i__stmp = ++i__s % 16;
 w__s[(i__stmp + 0 ) % 16] = 2;
 i__s = (i__s + 0 ) % 16;
 inputfmt(d_S, formt_S, prt_S, &n_int, &w__s[(i__stmp+0)%16]);
 quadrix(prt_S);
 if(n_int == -1)
 {
  fprintf(fp_2,"%s%s%s%s%s%s\n",spc_S,"strcpy(",b_S,",",d_S,");");
 }
 else
 {
  fprintf(fp_2,"%s%s%s%s\n",spc_S,"SScan(",b_S,");");
  fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s%s\n",spc_S,"if(sscanf(",b_S,",",e_S,formt_S,e_S,prt_S,") !=",STR_S(n_int),")");
  fprintf(fp_2,"%s%s%s%s%s%s%s%s\n",spc_S,"{ printf(",e_S,"Error in scanning string: ",b_S,"\\n",e_S,"); }");
  extrnfl_int = 1;
  SScan_int = 1;
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_5750:   /* "INPUT" */
 if(strcmp(t_S, "") != 0)
 {
  fprintf(fp_2,"%s%s\n",spc_S,t_S);
 }
 leng_int = LEN(a_S);
 strcpy(d_S,CHR_S(34));
 if(leng_int == 5)
 {
  fprintf(fp_2,"%s%s%s%s%s%s\n",spc_S,"INPUT(",d_S,d_S,",1)",t_S);
 }
 i_int = 6;
 g_int = 6;
 while(strcmp(MID_S(a_S, i_int, 1), d_S) != 0 && i_int < leng_int)
 {
  i_int = i_int + 1;
 }
 if(i_int < leng_int)
 {
  j_int = i_int + 1;
  while(strcmp(MID_S(a_S, j_int, 1), d_S) != 0 && j_int < leng_int)
  {
   j_int = j_int + 1;
  }
  strcpy(b_S,MID_S(a_S, i_int, j_int - i_int + 1));
  stringx(b_S);   /* String constant preprocessor */
  g_int = j_int;
 }
 else
 {
  sprintf(b_S,"%s%s",d_S,d_S);
 }
 i_int = g_int + 1;
 strcpy(z_S,MID_S(a_S, i_int, 1));
 strcpy(e_S,",1");
 if(strcmp(z_S, ",") == 0)
 {
  strcpy(e_S,",0");
 }
 while((strcmp(z_S, " ") == 0 || strcmp(z_S, ",") == 0 || strcmp(z_S, ";") == 0) && i_int < leng_int)
 {
  i_int = i_int + 1;
  strcpy(z_S,MID_S(a_S, i_int, 1));
  if(strcmp(z_S, ";") == 0)
  {
   strcpy(e_S,",1");
  }
 }
 strcpy(a_S,RIGHT_S(a_S, leng_int - i_int + 1));   /* CALL gulix(a$) */
 i__stmp = ++i__s % 16;
 w__s[(i__stmp + 0 ) % 16] = 1;
 i__s = (i__s + 0 ) % 16;
 inputfmt(a_S, formt_S, prt_S, &n_int, &w__s[(i__stmp+0)%16]);
 quadrix(prt_S);
 if(n_int == -1)
 {
  sprintf(prtf_S,"%s%s%s%s%s%s%s%s","while(INPUT(",b_S,e_S,") == NULL) printf(",d_S,"Redo from start:\\n",d_S,");");
  fprintf(fp_2,"%s%s\n",spc_S,prtf_S);
  fprintf(fp_2,"%s%s%s%s\n",spc_S,"strcpy(",prt_S,",tws__S);");
 }
 else
 {
  sprintf(prtf_S,"%s%s%s%s%s%s%s%s%s%s%s","while(sscanf(INPUT(",b_S,e_S,"),",d_S,formt_S,d_S,prt_S,") !=",STR_S(n_int)," && tws__S[0] != '\\n')");
  fprintf(fp_2,"%s%s\n",spc_S,prtf_S);
  fprintf(fp_2,"%s%s%s%s%s%s\n",spc_S,"{ printf(",d_S,"Redo from start:\\n",d_S,"); }");
 }
 commfl_int = 1;
 inputff_int = 1;
 extrnfl_int = 1;
 twsflg_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_6000:   /* Labels */
 /* Delete labels in DIM statements before initline% ! */
 if(ntok_int >= 2)
 {
      if(memcmp(linetok_S[2],"DIM ", 4)==0 && nl_int < initline_int) {
  fprintf(stderr,"%s%s%s\n","WARNING: Label ",linetok_S[1]," in DIM statement erased.");
  commfl_int = 1;
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
      }
 }
     if (a_S[0] >= '0' && a_S[0] <= '9') {
 strcpy(labl_S,STR_S(VAL(a_S)));
 sprintf(labl_S,"%s%s",MID_S(labl_S, 2, LEN(labl_S) - 1),":");
 fprintf(fp_2,"%s%s%s\n","Lab_",labl_S,t_S);
 commfl_int = 1;
     }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_6500:   /* "GOTO" */
 leng_int = LEN(a_S);
 strcpy(b_S,MID_S(a_S, 5, leng_int - 4));
 gulix(b_S);
 fprintf(fp_2,"%s%s%s%s%s%s\n",spc_S,"goto ","Lab_",b_S,";",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_7000:   /* "CALL" */
 commfl_int = 1;
 strcpy(e_S,CHR_S(34));
 leng_int = LEN(a_S);
 j_int = 0;
 for(i_int = 5; i_int <= leng_int; i_int++)
 {
  strcpy(b_S,MID_S(a_S, i_int, 1));
  if(strcmp(b_S, "(") == 0)
  {
   j_int = i_int;
   goto Lab_7001;
  }
 }
Lab_7003:
 strcpy(prtf_S,MID_S(a_S, 5, leng_int - 4));
 gulix(prtf_S);
 fprintf(fp_2,"%s%s%s%s\n",spc_S,prtf_S,"();",t_S);
 /* RETURN */
 longjmp(j__buf[--j__lev],1);
Lab_7001:
 strcpy(prtf_S,MID_S(a_S, 5, j_int - 5));
 gulix(prtf_S);
 for(k_int = 1; k_int <= nsub_int; k_int++)
 {
  if(strcmp(prtf_S, subname_S[k_int]) == 0)
  {
   goto Lab_7004;
  }
 }
 printf("%s%s%s\n","WARNING: ",prtf_S," is not a user defined SUBroutine or FUNCTION");
 goto Lab_7003;
Lab_7004:
 strcpy(varlist_S,MID_S(a_S, j_int + 1, leng_int - j_int - 1));
 tokenix(varlist_S, &n_int, ",", "");
 strcpy(varlist_S,"");
 tmp1_int = 0;
 tmp2_int = 0;
 tmp3_int = 0;
 tmp4_int = 0;
 tmp8_int = 0;
 for(i_int = 1; i_int <= n_int; i_int++)
 {
  strcpy(d_S,tmp_S[i_int]);
  vartyp(d_S, &typ_int);
  if(typ_int == 7)
  {
   fprintf(stderr,"%s% d %s\n","ERROR: String expressions not allowed as function parameters in line",nl_int,":");
   fprintf(stderr,"%s\n",line_S);
   signal_int = 1;   /* exit(1); */
   goto Lab_9999;
  }
  minusf_int = 0;
      if (d_S[0]=='-') minusf_int = 1;
  if(constfl_int == 1 || typ_int == 6 || minusf_int)
  {
   tip_int = 0;
   strcpy(b_S,subvar_S[k_int][i_int]);
   vartyp(b_S, &tip_int);
   if(tip_int == 1 || tip_int == 6)
   {
    if(tmp1_int == 0)
    {
     fprintf(fp_2,"%s%s\n",spc_S,"i__stmp = ++i__s % 16;");
    }
    fprintf(fp_2,"%s%s% d %s%s%s\n",spc_S,"w__s[(i__stmp +",tmp1_int,") % 16] = ",d_S,";");
     sprintf(tws__S,"%s%s%d%s",varlist_S,"&w__s[(i__stmp+",tmp1_int,")%16], ");
     strcpy(varlist_S,tws__S);
        tmp1_int++;
    inttfl_int = 1;
   }
   else
   {
    if(tip_int == 2)
    {
     if(tmp2_int == 0)
     {
      fprintf(fp_2,"%s%s\n",spc_S,"i__ltmp = ++i__l % 16;");
     }
     fprintf(fp_2,"%s%s% d %s%s%s\n",spc_S,"w__l[(i__ltmp +",tmp2_int,") % 16] = ",d_S,";");
     sprintf(tws__S,"%s%s%d%s",varlist_S,"&w__l[(i__ltmp+",tmp2_int,")%16], ");
     strcpy(varlist_S,tws__S);
         tmp2_int++;
     longtfl_int = 1;
    }
    else
    {
     if(tip_int == 3)
     {
      if(tmp3_int == 0)
      {
       fprintf(fp_2,"%s%s\n",spc_S,"i__ftmp = ++i__f % 16;");
      }
      fprintf(fp_2,"%s%s% d %s%s%s\n",spc_S,"w__f[(i__ftmp +",tmp3_int,") % 16] = ",d_S,";");
     sprintf(tws__S,"%s%s%d%s",varlist_S,"&w__f[(i__ftmp+",tmp3_int,")%16], ");
     strcpy(varlist_S,tws__S);
          tmp3_int++;
      floattfl_int = 1;
     }
     else
     {
      if(tip_int == 4)
      {
       if(tmp4_int == 0)
       {
        fprintf(fp_2,"%s%s\n",spc_S,"i__dtmp = ++i__d % 16;");
       }
       fprintf(fp_2,"%s%s% d %s%s%s\n",spc_S,"w__d[(i__dtmp +",tmp4_int,") % 16] = ",d_S,";");
     sprintf(tws__S,"%s%s%d%s",varlist_S,"&w__d[(i__dtmp+",tmp4_int,")%16], ");
     strcpy(varlist_S,tws__S);
           tmp4_int++;
       vdblff_int = 1;
      }
      else
      {
       if(tip_int == 5)
       {
        /*         PRINT #2, spc$ + "if(++j__S == 16) j__S=0;" */
        /*         PRINT #2, spc$ + "strcpy(w__S[j__S], " + d$ + ");" */
        /*         varlist$ = varlist$ + "w__S[j__S], " */
        /*         chartfl% = 1 */
        sprintf(tws__S,"%s%s%s",varlist_S,d_S,", ");
        strcpy(varlist_S,tws__S);
       }
       else
       {
        if(tip_int == 8)
        {
         if(tmp8_int == 0)
         {
          fprintf(fp_2,"%s%s\n",spc_S,"i__btmp = ++i__b % 16;");
         }
         fprintf(fp_2,"%s%s% d %s%s%s\n",spc_S,"w__b[(i__btmp +",tmp8_int,") % 16] = ",d_S,";");
     sprintf(tws__S,"%s%s%d%s",varlist_S,"&w__b[(i__btmp+",tmp8_int,")%16], ");
     strcpy(varlist_S,tws__S);
             tmp8_int++;
         byttfl_int = 1;
        }
        else
        {
         fprintf(stderr,"%s%s%s%s\n","ERROR: Unrecognized argument: ",d_S," in subroutine: ",subname_S[k_int]);
         fprintf(stderr,"%s%s%s% d \n","when calling: ",line_S," in line No: ",nl_int);
         signal_int = 1;   /* exit(1); */
         goto Lab_9999;
        }
       }
      }
     }
    }
   }
  }
  else
  {
   if(typ_int == 5 || typ_int == 15)
   {
    sprintf(tws__S,"%s%s%s",varlist_S,d_S,", ");
    strcpy(varlist_S,tws__S);
   }
   else
   {
    sprintf(tws__S,"%s%s%s%s",varlist_S,"&",d_S,", ");
    strcpy(varlist_S,tws__S);
   }
  }
 }
 strcpy(varlist_S,LEFT_S(varlist_S, LEN(varlist_S) - 2));
 quadrix(varlist_S);
 sprintf(tws__S,"%s%s%s%s",prtf_S,"(",varlist_S,");");
 strcpy(prtf_S,tws__S);
 if(tmp1_int)
 {
  fprintf(fp_2,"%s%s% .7G %s\n",spc_S,"i__s = (i__s +",(double)(tmp1_int - 1),") % 16;");
 }
 if(tmp2_int)
 {
  fprintf(fp_2,"%s%s% .7G %s\n",spc_S,"i__l = (i__l +",(double)(tmp2_int - 1),") % 16;");
 }
 if(tmp3_int)
 {
  fprintf(fp_2,"%s%s% .7G %s\n",spc_S,"i__f = (i__f +",(double)(tmp3_int - 1),") % 16;");
 }
 if(tmp4_int)
 {
  fprintf(fp_2,"%s%s% .7G %s\n",spc_S,"i__d = (i__d +",(double)(tmp4_int - 1),") % 16;");
 }
 if(tmp8_int)
 {
  fprintf(fp_2,"%s%s% .7G %s\n",spc_S,"i__b = (i__b +",(double)(tmp8_int - 1),") % 16;");
 }
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_8000:   /* "FOR " */
 leng_int = LEN(a_S);
 ix0_int = 5;
 j_int = ix0_int;
 while(strcmp(MID_S(a_S, j_int, 3), "TO ") != 0 && j_int < leng_int)
 {
  j_int = j_int + 1;
 }
 if(j_int == leng_int)
 {
  fprintf(stderr,"%s% d %s%s\n","ERROR: missing TO in line No",nl_int,":",line_S);
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 strcpy(b_S,MID_S(a_S, ix0_int, j_int - ix0_int - 1));
 gulix(b_S);
 mathexp(b_S);
 quadrix(b_S);
 k_int = 1;
 while(strcmp(MID_S(b_S, k_int, 1), "=") != 0)
 {
  k_int = k_int + 1;
 }
 strcpy(e_S,MID_S(b_S, 1, k_int - 2));
 strcpy(c_S,MID_S(b_S, k_int + 2, LMAX));
 gulix(c_S);
 L_int = j_int + 3;
 while(strcmp(MID_S(a_S, L_int, 4), "STEP") != 0 && L_int <= leng_int)
 {
  L_int = L_int + 1;
 }
 strcpy(d_S,MID_S(a_S, j_int + 3, L_int - j_int - 3));
 gulix(d_S);
 mathexp(d_S);
 quadrix(d_S);
 if(leng_int - L_int - 3 >= 0)
 {
  strcpy(f_S,RIGHT_S(a_S, leng_int - L_int - 3));
  gulix(f_S);
  x = VAL(f_S);
  if((x > 0.))
  {
   sprintf(prtf_S,"%s%s%s%s%s%s%s%s%s%s%s%s%s%s",spc_S,"for(",b_S,"; ",e_S," <= ",d_S,"; ",e_S," = ",e_S," + ",f_S,")");
  }
  else
  {
   if((x < 0.))
   {
    sprintf(prtf_S,"%s%s%s%s%s%s%s%s%s%s%s%s%s",spc_S,"for(",b_S,"; ",e_S," >= ",d_S,"; ",e_S," = ",e_S,f_S,")");
   }
   else
   {
    mathexp(f_S);
    quadrix(f_S);
    fprintf(fp_2,"%s%s%s\n",spc_S,"if(++j__sig == 16) j__sig=0;",t_S);
    strcpy(t_S,"");
    sigiff_int = 1;
    fprintf(fp_2,"%s%s%s%s\n",spc_S,"sig__i[j__sig] = 1; if(",f_S," < 0) sig__i[j__sig] = -1;");
    sprintf(prtf_S,"%s%s%s%s%s%s%s%s%s%s%s%s%s%s",spc_S,"for(",b_S,"; sig__i[j__sig]*",e_S," <= sig__i[j__sig]*",d_S,"; ",e_S," = ",e_S," + ",f_S,")");
   }
  }
 }
 else
 {
  sprintf(prtf_S,"%s%s%s%s%s%s%s%s%s%s",spc_S,"for(",b_S,"; ",e_S," <= ",d_S,"; ",e_S,"++)");
 }
 fprintf(fp_2,"%s%s\n",prtf_S,t_S);
 fprintf(fp_2,"%s%s\n",spc_S,"{");
 lspac_int = lspac_int + 1;
 strcpy(spc_S,SPACE_S(lspac_int));
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_8500:   /* "NEXT" */
 fprintf(fp_2,"%s%s\n",SPACE_S(lspac_int - 1),"}");
 lspac_int = lspac_int - 1;
 strcpy(spc_S,SPACE_S(lspac_int));
 if(lspac_int < 0)
 {
  printf("%s% d %s% d %s%s\n","WARNING! Braces count = ",lspac_int," at line: ",nl_int,":",line_S);
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_9000:   /* "OPEN " */
 /* Open files for I/O. Syntax: */
 /* OPEN filename$ FOR mode [ACCESS access] AS [#]filenumber [LEN=reclen] */
 /* ACCESS and LEN are read but NOT OPERATIONAL YET !!! */
 leng_int = LEN(a_S);
 jopn_int = jopn_int + 1;
 i_int = 3;
 /*   Modes and their temporary found flags: */
 j_int = 0;
 strcpy(mode_S,"");
 k_int = 0;
 strcpy(access_S,"");
 i1_int = 0;
 n_int = 0;
 strcpy(Len_S,"");
      while (a_S[++i_int]) {
       if (memcmp(&a_S[i_int], " FOR ", 5)==0) j_int = i_int;
       if (memcmp(&a_S[i_int], "INPUT ", 6)==0 && j_int) strcpy(mode_S, "r");
       if (memcmp(&a_S[i_int], "OUTPUT ", 7)==0 && j_int) strcpy(mode_S, "w");
       if (memcmp(&a_S[i_int], "APPEND ", 7)==0 && j_int) strcpy(mode_S, "a");
       if (memcmp(&a_S[i_int], "RANDOM ", 7)==0 && j_int) strcpy(mode_S, "r+");
       if (memcmp(&a_S[i_int], "BINARY ", 7)==0 && j_int) strcpy(mode_S, "r+");
       if (memcmp(&a_S[i_int], "ACCESS ", 7)==0) k_int = i_int;
       if (memcmp(&a_S[i_int], "READ ", 5)==0) strcpy(access_S, "r");
       if (memcmp(&a_S[i_int], "WRITE ", 6)==0) strcpy(access_S, "w");
       if (memcmp(&a_S[i_int], "READ WRITE ",11)==0) strcpy(access_S, "rw");
       if (memcmp(&a_S[i_int], " AS ", 4)==0) i1_int = i_int + 2;
      }
      if (!j_int) {
 fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR: missing FOR in line No",nl_int,": ",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
      }
      if (!i1_int) {
 fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR: missing AS in line No",nl_int,": ",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
      }
 if(strcmp(mode_S, "") == 0)
 {
  strcpy(mode_S,"r+");
 }
      memcpy(f_S, &a_S[5], j_int-4); f_S[j_int-4]='\0';
 gulix(f_S);
      if (f_S[0] == '\0') {
 fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR: missing filename in line No",nl_int,": ",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
      }
 quadrix(f_S);
 tokenix(f_S, &n_int, "+", "");
 if(n_int > 1)
 {
  printfmt(f_S, formt_S, prt_S, &nflag_int);
  sprintf(prtf_S,"%s%s%s%s%s%s","sprintf(tws__S,",CHR_S(34),formt_S,CHR_S(34),prt_S,");");
  fprintf(fp_2,"%s%s\n",spc_S,prtf_S);
  strcpy(f_S,"tws__S");
  twsflg_int = 1;
 }
 gulix(f_S);
 n_int = 0;
      while (a_S[++i1_int]) {
       if (n_int=atoi(&a_S[i1_int])) break;
      }
 if(n_int == 0)
 {
  fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR: file number missing or not literal in line No",nl_int,": ",line_S);
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 strcpy(d_S,STR_S(n_int));
 strcpy(n_S,MID_S(d_S, 2, LMAX));
 sprintf(prtf_S,"%s%s%s%s%s%s%s%s%s%s%s","if((fp_",n_S," = fopen(strcpy(fn",n_S,"__S,",f_S,"), ",CHR_S(34),mode_S,CHR_S(34),")) == NULL)");
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 fprintf(fp_2,"%s%s\n",spc_S,"{");
 fprintf(fp_2,"%s%s%s%s%s%s%s%s\n",SPACE_S(lspac_int + 1),"fprintf(stderr,",CHR_S(34),"Can't open file %s\\n",CHR_S(34),",fn",n_S,"__S); exit(1);");
 fprintf(fp_2,"%s%s\n",spc_S,"}");
 commfl_int = 1;
 i_int = 1;
 while(lfopen_int[i_int] != n_int && i_int <= nlopen_int)
 {
  i_int = i_int + 1;
 }
 /*   Save information about open files: */
 if(i_int <= nlopen_int)
 {
  lfopen_int[i_int] = n_int;
  strcpy(lfopen_S[i_int],f_S);
 }
 else
 {
  nlopen_int = nlopen_int + 1;
  lfopen_int[nlopen_int] = n_int;
  strcpy(lfopen_S[nlopen_int],f_S);
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_9500:   /* "CLOSE" */
 /* Syntax: CLOSE [[#]filenumber[,[#] filenumber]...] */
 tokenix(MID_S(a_S, 6, LMAX), &n_int, ",", "");
 for(i_int = 1; i_int <= n_int; i_int++)
 {
       c = tmp_S[i_int][0];
       if ('0' <= c && c <= '9') {
        strcpy(b_S, tmp_S[i_int]);
       } else {
        c = tmp_S[i_int][1];
        if ('0' <= c && c <= '9') {
         strcpy(b_S, &tmp_S[i_int][1]);
        } else {
Lab_9501:
  fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR: invalid argument(s) in line No",nl_int,":",a_S);
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
        }
       }
  g_long = VAL(b_S);
  if(! g_long)
  {
   goto Lab_9501;
  }
  strcpy(n_S,STR_S(g_long));
  strcpy(n_S,MID_S(n_S, 2, LMAX));
  fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"fclose(fp_",n_S,");",t_S);
 }
 if(n_int == 0)
 {
  /* Overkill. Close everything even if not opened yet! */
  for(i_int = 1; i_int <= nopen_int; i_int++)
  {
   strcpy(n_S,STR_S(fopen_int[i_int]));
   strcpy(n_S,MID_S(n_S, 2, LMAX));
   fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"fclose(fp_",n_S,");",t_S);
  }
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_10000:   /* "ENVIRON " */
 fprintf(stderr,"%s% d %s%s\n","qb2c: ENVIRON feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_11000:   /* "GOSUB " */
 leng_int = LEN(a_S);
 strcpy(b_S,MID_S(a_S, 6, leng_int - 5));
 gulix(b_S);
 sprintf(prtf_S,"%s%s%s","if (setjmp(j__buf[j__lev++])==0) goto Lab_",b_S,";");
 fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"/* GOSUB Lab_",b_S," */ ",t_S);
 fprintf(fp_2,"%s%s\n",spc_S,prtf_S);
 retrnfl_int = 1;
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_11500:   /* "RETURN" */
 strcpy(prtf_S,"longjmp(j__buf[--j__lev],1);");
 fprintf(fp_2,"%s%s\n",spc_S,"/* RETURN */");
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 retrnfl_int = 1;
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_12000:   /* "RANDOMIZE" */
 strcpy(b_S,MID_S(a_S, 10, LMAX));
 gulix(b_S);
 quadrix(b_S);
       if (strlen(b_S)==0) {
 strcpy(prtf_S,"RANDOMIZE(32767);");
       } else {
 sprintf(prtf_S,"%s%s%s","RANDOMIZE((long)",b_S,");");
       }
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_12200:   /* "PAUSE " */
 strcpy(b_S,MID_S(a_S, 7, LMAX));
 gulix(b_S);
 if(strcmp(b_S, "") == 0)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 quadrix(b_S);
 fprintf(fp_2,"%s%s%s%s\n",spc_S,"t__.tv_sec = floor(",b_S,");");
 fprintf(fp_2,"%s%s%s%s\n",spc_S,"t__.tv_usec= 1000000*(",b_S,"-t__.tv_sec);");
 fprintf(fp_2,"%s%s%s\n",spc_S,"select(0, (void *)0, (void *)0, (void *)0, &t__);",t_S);
 mathfl_int = 1;
 pausefl_int = 1;
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_17000:   /* "SHELL"  Only explicite form "..." of shell commands is suported. */
 /* eg. "del " + name$ */
 commfl_int = 1;
 if(strcmp(a_S, "SHELL") == 0)
 {
  strcpy(a_S,"");
  goto Lab_17030;
 }
 strcpy(a_S,MID_S(a_S, 6, LMAX));
 stringx(a_S);
 gulix(a_S);
 leng_int = LEN(a_S);
 if(noshell_int == 1)
 {
  goto Lab_17015;
 }
 ii_int = 1;
 togfl_int = 0;
 while(ii_int < leng_int)
 {
  if(ASC(MID_S(a_S, ii_int, 1)) == 34)
  {
   togfl_int = 1 - togfl_int;
  }
  if(togfl_int == 0)
  {
   goto Lab_17010;
  }
  strcpy(b_S,MID_S(a_S, ii_int, 3));
  strcpy(d_S,MID_S(a_S, ii_int, 4));
  strcpy(e_S,MID_S(a_S, ii_int, 6));
       if (ii_int == 1)
       { i1_int=32; }
       else
       { i1_int=a_S[ii_int-2]; }
  if(i1_int != 32 && i1_int != 34)
  {
   goto Lab_17010;
  }
  if(strcmp(d_S, "copy") == 0)
  {
        i2_int=a_S[ii_int-1+4];
        if (i2_int!=32 && i2_int!=34) goto Lab_17010;
   sprintf(a_S,"%s%s%s",LEFT_S(a_S, ii_int - 1),"cp",RIGHT_S(a_S, leng_int - ii_int - 3));
   leng_int = leng_int - 2;
   ii_int = ii_int + 2;
   goto Lab_17010;
  }
  if(strcmp(e_S, "rename") == 0)
  {
        i2_int=a_S[ii_int-1+6];
        if (i2_int!=32 && i2_int!=34) goto Lab_17010;
   sprintf(a_S,"%s%s%s",LEFT_S(a_S, ii_int - 1),"mv",RIGHT_S(a_S, leng_int - ii_int - 5));
   leng_int = leng_int - 4;
   ii_int = ii_int + 2;
   goto Lab_17010;
  }
  if(strcmp(b_S, "del") == 0)
  {
        i2_int=a_S[ii_int-1+3];
        if (i2_int!=32 && i2_int!=34) goto Lab_17010;
   sprintf(a_S,"%s%s%s",LEFT_S(a_S, ii_int - 1),"rm -f",RIGHT_S(a_S, leng_int - ii_int - 2));
   leng_int = leng_int + 2;
   ii_int = ii_int + 5;
   goto Lab_17010;
  }
  if(strcmp(b_S, "dir") == 0)
  {
        i2_int=a_S[ii_int-1+3];
        if (i2_int!=32 && i2_int!=34) goto Lab_17010;
   sprintf(a_S,"%s%s%s",LEFT_S(a_S, ii_int - 1),"ls -l",RIGHT_S(a_S, leng_int - ii_int - 2));
   leng_int = leng_int + 2;
   ii_int = ii_int + 5;
   goto Lab_17010;
  }
  if(strcmp(b_S, "cls") == 0)
  {
        i2_int=a_S[ii_int-1+3];
        if (i2_int!=32 && i2_int!=34) goto Lab_17010;
   sprintf(a_S,"%s%s%s",LEFT_S(a_S, ii_int - 1),"clear",RIGHT_S(a_S, leng_int - ii_int - 2));
   leng_int = leng_int + 2;
   ii_int = ii_int + 5;
   goto Lab_17010;
  }
Lab_17010:
  ii_int = ii_int + 1;
 }
Lab_17015:
 gulix(a_S);
 tokenix(a_S, &n_int, "+", "");
 if(n_int > 1)
 {
  printfmt(a_S, formt_S, prt_S, &nflag_int);
  quadrix(prt_S);
  sprintf(prtf_S,"%s%s%s%s%s%s","sprintf(tws__S,",CHR_S(34),formt_S,CHR_S(34),prt_S,");");
  fprintf(fp_2,"%s%s\n",spc_S,prtf_S);
  strcpy(a_S,"tws__S");
  twsflg_int = 1;
 }
Lab_17030:
 quadrix(a_S);
 sprintf(prtf_S,"%s%s%s","system(",a_S,");");
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_18000:   /* numerical and string expressions */
 if(commfl_int == 1)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 leng_int = LEN(a_S);
 togfl_int = 0;
 i_int = 1;
      while (! (togfl_int == 0 && a_S[i_int-1] == '=') && i_int < leng_int) {
       if (a_S[i_int-1] == '"') togfl_int = 1 - togfl_int;
       i_int++;
      }
 if(i_int == leng_int)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 commfl_int = 1;
 tmpfl_int = 0;
 expflg_int = 1;
 fcond_int = 0;
 togfl_int = 0;
 lmid_int = 0;
 strcpy(e_S,LEFT_S(a_S, i_int - 1));
 gulix(e_S);
 vartyp(e_S, &typ_int);
 if(funcflag_int == 1)
 {
  if(strcmp(e_S, funcnam_S) == 0)   /* Function assignment line */
  {
   fcond_int = 1;
  }
 }
 if(typ_int == 5 || typ_int == 15)
 {
  strcpy(a_S,MID_S(a_S, i_int + 1, LMAX));
  gulix(a_S);
  stringx(a_S);   /* String constant pretprocessor */
  vartyp(a_S, &typ_int);
  printfmt(a_S, formt_S, prt_S, &nflag_int);   /* string expression processing */
       if (memcmp(e_S, "MID$(", 5) == 0) {
  lmid_int = typ_int;
  strcpy(b_S,MID_S(e_S, 6, LEN(e_S) - 6));
  quadrix(b_S);
  tokenix(b_S, &n_int, ",", "");
  if(n_int == 2)
  {
   strcpy(tmp_S[3],"LMAX");
  }
  if(lmid_int == 7)
  {
   fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"sprintf(tws__S,",CHR_S(34),formt_S,CHR_S(34),prt_S,");");
   twsflg_int = 1;
   fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s%s%s\n",spc_S,"strncpy(&",tmp_S[1],"[(int)(",tmp_S[2],"-1)],tws__S,(int)MIN(MIN(",tmp_S[3],",strlen(",tmp_S[1],")-(",tmp_S[2],")+1),strlen(tws__S)));");
  }
  else
  {
   fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",spc_S,"strncpy(&",tmp_S[1],"[(int)(",tmp_S[2],"-1)],",a_S,",(int)MIN(MIN(",tmp_S[3],",strlen(",tmp_S[1],")-(",tmp_S[2],")+1),strlen(",a_S,")));");
  }
  minff_int = 1;
  goto Lab_18009;
       }
  if(typ_int == 7)
  {
   for(j_int = 1; j_int <= nptk_int; j_int++)
   {
    if(strcmp(e_S, tmp_S[j_int]) == 0)
    {
     tmpfl_int = 1;
     goto Lab_18001;
    }
   }
Lab_18001:
   if(tmpfl_int == 1 && fcond_int == 1)
   {
    fprintf(stderr,"%s% d %s%s\n","SYNTAX ERROR in line No",nl_int,":",line_S);
    fprintf(stderr,"%s\n","Function name must be on the left side only");
    signal_int = 1;   /* exit(1); */
    goto Lab_9999;
   }
   if(tmpfl_int == 1 || fcond_int == 1)
   {
    sprintf(prtf_S,"%s%s%s%s%s%s","sprintf(tws__S,",CHR_S(34),formt_S,CHR_S(34),prt_S,");");
    twsflg_int = 1;
    if(fcond_int == 1)
    {
     togfl_int = 1;
    }
   }
   else
   {
    quadrix(e_S);
    sprintf(prtf_S,"%s%s%s%s%s%s%s%s","sprintf(",e_S,",",CHR_S(34),formt_S,CHR_S(34),prt_S,");");
   }
  }
  else
  {
   if(fcond_int == 1)
   {
    sprintf(prtf_S,"%s%s%s","return ",MID_S(prt_S, 2, LMAX),";");
   }
   else
   {
    quadrix(e_S);
    sprintf(prtf_S,"%s%s%s%s","strcpy(",e_S,prt_S,");");
   }
  }
 }
 else
 {
       strcpy(b_S, &a_S[i_int]);
  gulix(b_S);
  if(strcmp(LEFT_S(b_S, 8), "XWINDOW ") == 0)
  {
   xwflag_int = 1;
   strcpy(f_S,e_S);
   quadrix(f_S);
   strcpy(a_S,b_S);
   goto Lab_21000;
  }
  mathexp(a_S);   /* Translating math. functions */
  if(fcond_int == 1)
  {
   sprintf(prtf_S,"%s%s%s","return ",MID_S(a_S, i_int + 1, LMAX),";");
  }
  else
  {
   sprintf(prtf_S,"%s%s",a_S,";");
  }
  expflg_int = 0;
 }
 quadrix(prtf_S);
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 if(tmpfl_int == 1)
 {
  if(! fcond_int)
  {
   quadrix(e_S);
  }
  fprintf(fp_2,"%s%s%s%s\n",spc_S,"strcpy(",e_S,",tws__S);");
 }
 if(togfl_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"return tws__S;");
 }
Lab_18009:
 expflg_int = 0;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_19000:   /* "END SUB"  and "END FUNCTION" */
 fprintf(fp_2,"%s\n","}");
 if(lspac_int != 1)
 {
  if(funcflag_int == 1)
  {
        fprintf(stderr,"ERROR: Brace misscount of %d occured at the end of FUNCTION: %s\n",lspac_int-1, subname_S[isub_int]);
   signal_int = 1;   /* exit(1); */
   goto Lab_9999;
  }
  else
  {
        fprintf(stderr,"ERROR: Brace misscount of %d occured at the end of SUBroutine: %s\n",lspac_int-1, subname_S[isub_int]);
   signal_int = 1;   /* exit(1); */
   goto Lab_9999;
  }
 }
 commfl_int = 1;
 funcflag_int = 0;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_19100:   /* "EXIT SUB" */
 strcpy(prtf_S,"return;");
 fprintf(fp_2,"%s%s%s\n",spc_S,prtf_S,t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_19200:   /* "DEFSTR " */
 flag_int = 0;
      if(memcmp(&a_S[3],"STR",3)==0) flag_int=1;
      if(memcmp(&a_S[3],"INT",3)==0) flag_int=2;
      if(memcmp(&a_S[3],"DBL",3)==0) flag_int=3;
 if(! flag_int)
 {
  fprintf(stderr,"%s\n","Bug in 19200");
  exit(3);
 }
 strcpy(b_S,MID_S(a_S, 8, LMAX));
 tokenix(b_S, &n_int, ",", "");
 if(n_int == 0)
 {
  goto Lab_29000;
 }
 for(i_int = 1; i_int <= n_int; i_int++)
 {
  j_int = LEN(tmp_S[i_int]);   /* IF j% <> 1 OR j% <> 3 THEN GOTO 29000 */
  if(j_int != 1)
  {
        for(k_int=toupper(tmp_S[i_int][0]); k_int<=toupper(tmp_S[i_int][j_int-1]); k_int++) {
         if (flag_int==1) def__str[k_int-'A'] = 1;
         if (flag_int==2) def__int[k_int-'A'] = 1;
         if (flag_int==3) def__dbl[k_int-'A'] = 1;
   /*      PRINT flag%; " k% = "; k% - 'A' */
        }
  }
  else
  {
        if (flag_int==1) def__str[toupper(tmp_S[i_int][0])-'A'] = 1;
        if (flag_int==2) def__int[toupper(tmp_S[i_int][0])-'A'] = 1;
        if (flag_int==3) def__dbl[toupper(tmp_S[i_int][0])-'A'] = 1;
  }
 }
 if(flag_int == 1)
 {
  defstr_int = 1;
 }
 if(flag_int == 2)
 {
  defint_int = 1;
 }
 if(flag_int == 3)
 {
  defdbl_int = 1;
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_19300:   /* "DEF FN" */
 /* Syntax: DEF FNxx(x) = x * x - 5 * x + 6 */
 /* Done in 800. */
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_19400:   /* "SOUND" */
 /* Syntax: SOUND .... NOT YET */
 strcpy(e_S,CHR_S(34));
 fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"printf(",e_S,"\\a",e_S,");",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_19500:   /* "DATA " */
 fprintf(stderr,"%s% d %s%s\n","qb2c: DATA feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_19550:   /* "READ " */
 fprintf(stderr,"%s% d %s%s\n","qb2c: READ feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_19575:   /* "RESTORE [item%]" */
 fprintf(stderr,"%s% d %s%s\n","qb2c: RESTORE feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_20000:   /* "LINE (" or "LINE -" (graphics) statement */
 /* Supported syntax: */
 /* LINE (x1, y1) - (x2, y2)[,[color][,[B[F]][,style]]]   flag% = 0 */
 /* LINE - (x, y)[,[color][,[B[F]][,style]]]              flag% = 1 */
 /* LINE - STEP(x, y)[,[color][,[B[F]][,style]]]          flag% = 2 */
 /* (there may be spaces *after* the STEP keyword) */
 /* Draws a line and sets the new current position x=xy(0,0), y=xy(0,1) */
 flag_int = 0;
 strcpy(b_S,MID_S(a_S, 5, LMAX));
 quadrix(b_S);   /* vraca oguljeno ! */
      if (b_S[0] == '-') {
 flag_int = 1;
 strcpy(b_S,MID_S(b_S, 3, LMAX));
       if (memcmp(b_S, "STEP", 4)==0) {
 strcpy(b_S,MID_S(b_S, 5, LMAX));
 flag_int = 2;
       }
      }
 if(flag_int)
 {
  sprintf(tws__S,"%s%s","(xy__pos[0][0], xy__pos[0][1])-",b_S);
  strcpy(b_S,tws__S);
 }
 tokenix(b_S, &k_int, "-", ",");
 if(k_int > 5)
 {
  fprintf(stderr,"%s% d %s%s\n","ERROR: too many arguments to LINE in line No",nl_int,": ",line_S);
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
      strcpy(b_S,tmp_S[1]+1); b_S[strlen(b_S)-1]='\0';
      strcpy(d_S,tmp_S[2]+1); d_S[strlen(d_S)-1]='\0';
 tokenix(b_S, &n_int, ",", "");
 strcpy(temp_S[1],tmp_S[1]);
 strcpy(temp_S[2],tmp_S[2]);
 tokenix(d_S, &n_int, ",", "");
 strcpy(temp_S[3],tmp_S[1]);
 strcpy(temp_S[4],tmp_S[2]);
 tmpfl_int = 0;
 /* GOSUB Lab_20050 */ 
 if (setjmp(j__buf[j__lev++])==0) goto Lab_20050;
 if(tmpfl_int == 1)
 {
  goto Lab_20009;
 }
 fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"xy__pos[1][0]=",temp_S[1],"; xy__pos[1][1]=",temp_S[2],";",t_S);
 if(flag_int == 2)
 {
  fprintf(fp_2,"%s%s%s%s%s%s\n",spc_S,"xy__pos[0][0]+=",temp_S[3],"; xy__pos[0][1]+=",temp_S[4],";");
 }
 else
 {
  fprintf(fp_2,"%s%s%s%s%s%s\n",spc_S,"xy__pos[0][0]=",temp_S[3],"; xy__pos[0][1]=",temp_S[4],";");
 }
 fprintf(fp_2,"%s%s\n",spc_S,"ixline(2,xy__pos);");
Lab_20009:
 if(updateff_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixupdwi(0);");
 }
 grafflg_int = 1;
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_20050:   /* options handling (color, B[F], style) */
 j_int = 0;
 if(k_int >= 3)
 {
  strcpy(b_S,tmp_S[3]);
       if (b_S[0] != '\0') {
  quadrix(b_S);
  fprintf(fp_2,"%s%s%s%s\n",spc_S,"ixsetlc((int)",b_S,");");
  j_int = 1;
       }
 }
 if(! j_int && colorfl_int)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixsetlc(1);");
 }
 if(k_int == 5)
 {
  fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"ixsetld((int)(",tmp_S[5],"));",t_S);
 }
 if(k_int >= 4 && (strcmp(tmp_S[4], "BF") == 0 || strcmp(tmp_S[4], "B") == 0))
 {
  /* C      if (tmp_S[4][0]=='\0') */
  /* C      { */
  /*        RETURN */
  /* C      } */
  if(strcmp(tmp_S[4], "BF") == 0)
  {
        if (b_S[0] != '\0') {
   fprintf(fp_2,"%s%s%s%s\n",spc_S,"ixsetfc((int)",b_S,"); ixsetfs(1, 1);");
        }
   strcpy(e_S,"),1);");
  }
  else
  {
   strcpy(e_S,"),0);");
  }
  fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s%s\n",spc_S,"ixbox((int)(",temp_S[1],"),(int)(",temp_S[3],"),(int)(",temp_S[2],"),(int)(",temp_S[4],e_S,t_S);
  tmpfl_int = 1;
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_20500:   /* "PSET " (graphics) statement */
 /* Draws a point and sets the new current position x=xy(0,0), y=xy(0,1) */
 strcpy(b_S,MID_S(a_S, 5, LMAX));
 gulix(b_S);
      if (b_S[0] != '(') goto Lab_29000;
 quadrix(b_S);
 tokenix(b_S, &k_int, ",", "");
 if(k_int == 0 || k_int > 2)
 {
  goto Lab_29500;
 }
 if(k_int == 2)
 {
  sprintf(d_S,"%s%s%s","(int)(",tmp_S[2],")");
 }
 else
 {
  if(colorfl_int)
  {
   strcpy(d_S,"1");
  }
  else
  {
   strcpy(d_S,"-1");
  }
 }
      strcpy(b_S,tmp_S[1]+1); b_S[strlen(b_S)-1]='\0';
 tokenix(b_S, &n_int, ",", "");
 fprintf(fp_2,"%s%s%s%s%s%s\n",spc_S,"xy__pos[0][0]=",tmp_S[1],"; xy__pos[0][1]=",tmp_S[2],";");
 fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"ixpset(xy__pos[0][0],xy__pos[0][1],",d_S,");",t_S);
 if(updateff_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixupdwi(0);");
 }
 grafflg_int = 1;
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_21000:   /* "SCREEN " and/or "XWINDOW " (graphics) */
 /* SCREEN: Initialize graphics and open an X-window */
 /* Original syntax:   SCREEN mode */
 /* Additional syntax: SCREEN (x, y)[, w, h[, title$[, Xfont_name$]]] */
 /* XWINDOW: Open a new X-window. SCREEN opens window with ID=0, whereas */
 /* XWINDOW opens ID=1, 2, ... 20. It is NOT a BASIC command. */
 /* Syntax: XWINDOW (x, y)[, w, h[, title$]] */
 /* (x, y)=position, (w, h)=size in pixels */
 /* 819x484 -misc-fixed-medium-r-normal-*-20-140-*-100-c-100-iso8859-1 */
 strcpy(e_S,CHR_S(34));
 twsflg_int = 1;
      if ( memcmp(a_S,"SCREEN ",7)==0 ) {
 fprintf(fp_2,"%s%s\n",spc_S,"/* SCREEN initializations */");
 fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"if (ixopnds(",e_S,e_S,")==-1) exit(0);");
      }
 strcpy(b_S,MID_S(a_S, 8, LMAX));
 gulix(b_S);
 if(strcmp(b_S, "") == 0)
 {
  goto Lab_29000;
 }
 typ_int = 0;   /* Used as a flag */
      c = b_S[0];
 tokenix(b_S, &k_int, ",", "");
      if (c == '(')
      {
       k_int++;
 strcpy(temp_S[6],tmp_S[5]);
 strcpy(temp_S[5],tmp_S[4]);
 strcpy(temp_S[4],tmp_S[3]);
 strcpy(temp_S[3],tmp_S[2]);
       strcpy(b_S,tmp_S[1]+1); b_S[strlen(b_S)-1]='\0';
 tokenix(b_S, &n_int, ",", "");
 if(n_int != 2)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 strcpy(temp_S[2],tmp_S[2]);
 strcpy(temp_S[1],tmp_S[1]);

 vartyp(temp_S[5], &typ_int);
 if(typ_int == 7)
 {
  printfmt(temp_S[5], formt_S, prt_S, &nflag_int);
  sprintf(prtf_S,"%s%s%s%s%s%s","sprintf(tws__S,",CHR_S(34),formt_S,CHR_S(34),prt_S,");");
  /*     PRINT #2, spc$ + prtf$ */
  strcpy(temp_S[5],"tws__S");
  twsflg_int = 1;
 }
      }
 sprintf(b_S,"%s%s%s",e_S,"QB2C",e_S);
 strcpy(d_S,"-misc-fixed-medium-r-normal-*-20-140-*-100-c-100-iso8859-1");
 sprintf(tws__S,"%s%s%s",e_S,d_S,e_S);
 strcpy(d_S,tws__S);
 if(k_int > 4)   /* title */
 {
  strcpy(b_S,temp_S[5]);
 }
 if(k_int > 5)   /* font */
 {
  strcpy(d_S,temp_S[6]);
 }
      if (k_int == 1 && c != '(')
      {
 if(strcmp(tmp_S[1], "10") == 0)
 {
  sprintf(prt_S,"%s%s%s%s%s",spc_S,"ixopnwi(100,100,819,484,",b_S,",0);",t_S);
  commfl_int = 1;
 }
 else
 {
  if(strcmp(tmp_S[1], "0") == 0)
  {
   printf("%s\n","WARNING! SCREEN 0 is obsolete, ignored since");
   printf("%s\n","there is no need to switch to tty mode.");
   commfl_int = 1;
   /* RETURN */
   longjmp(j__buf[--j__lev],1);
  }
  else
  {
   printf("%s%s%s\n","WARNING: ",a_S," not supported! Using mode 10 instead.");
   sprintf(prt_S,"%s%s%s%s%s",spc_S,"ixopnwi(100,100,819,484,",b_S,",0);",t_S);
   commfl_int = 1;
  }
 }
      }
      else
      {
 if(k_int == 2)
 {
  strcpy(temp_S[3],"819");
  strcpy(temp_S[4],"484");
 }
 else
 {
  if(k_int < 4)
  {
   /* RETURN */
   longjmp(j__buf[--j__lev],1);
  }
 }
 sprintf(prt_S,"%s%s%s%s%s%s%s%s%s%s%s%s","ixopnwi((int)",temp_S[1],",(int)",temp_S[2],",(int)",temp_S[3],",(int)",temp_S[4],",",b_S,",0);",t_S);
      }
      if ( memcmp(a_S,"SCREEN ",7)==0 ) {
 fprintf(fp_2,"%s%s\n",spc_S,"ixsetfs(0,0); ixsetfc(1); ixsettc(1); ixsetta(0,0); ixsetms(0,5,xy__pos);");
 fprintf(fp_2,"%s%s%s%s\n",spc_S,"strcpy(tws__S,",d_S,");");
 fprintf(fp_2,"%s%s\n",spc_S,"if(ixsettf(1,tws__S)==1)");
 fprintf(fp_2,"%s%s%s%s%s%s\n",spc_S,"{ fprintf(stderr,",e_S,"Requested Xfont not found: %s\\n",e_S,",tws__S); }");
      }
 if(typ_int == 7)
 {
  fprintf(fp_2,"%s%s\n",spc_S,prtf_S);
 }
 if(xwflag_int)
 {
  fprintf(fp_2,"%s%s%s%s\n",spc_S,f_S,"=",prt_S);
  xwflag_int = 0;
 }
 else
 {
  fprintf(fp_2,"%s%s\n",spc_S,prt_S);
 }
 grafflg_int = 1;
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_21500:   /* "SET " (graphics) statement */
 strcpy(e_S,CHR_S(34));
 j_int = LEN(a_S);
      i_int = 4; while(a_S[i_int] != ' ' && i_int < j_int) i_int++;
 if(i_int == j_int)
 {
  fprintf(stderr,"%s% d %s%s\n","ERROR: Syntax error in line No",nl_int,": ",a_S);
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 strcpy(d_S,MID_S(a_S, 5, i_int - 4));   /* Opcija od SET */
 strcpy(b_S,MID_S(a_S, i_int + 2, LMAX));
 quadrix(b_S);
 tokenix(b_S, &k_int, ",", "");
 if(k_int == 1)
 {
  sprintf(prt_S,"%s%s%s%s","((int)(",tmp_S[1],")); ",t_S);
 }
 else
 {
  if(k_int == 2)
  {
   sprintf(prt_S,"%s%s%s%s%s%s","((int)(",tmp_S[1],") ,(int)(",tmp_S[2],"));",t_S);
  }
 }
 if(strcmp(d_S, "PLCI") == 0 || strcmp(d_S, "LCOL") == 0)
 {
  if(k_int != 1)
  {
   goto Lab_29000;
  }
  fprintf(fp_2,"%s%s%s\n",spc_S,"ixsetlc",prt_S);
  commfl_int = 1;
 }
 else
 {
  if(strcmp(d_S, "LWID") == 0)
  {
   if(k_int != 1)
   {
    goto Lab_29000;
   }
   fprintf(fp_2,"%s%s%s\n",spc_S,"ixsetln",prt_S);
   commfl_int = 1;
  }
  else
  {
   if(strcmp(d_S, "PMTS") == 0)
   {
    if(k_int != 2)
    {
     goto Lab_29000;
    }
    fprintf(fp_2,"%s%s%s\n",spc_S,"ixsetmts",prt_S);
    commfl_int = 1;
   }
   else
   {
    if(strcmp(d_S, "PMCI") == 0)
    {
     if(k_int != 1)
     {
      goto Lab_29000;
     }
     fprintf(fp_2,"%s%s%s\n",spc_S,"ixsetmc",prt_S);
     commfl_int = 1;
    }
    else
    {
     if(strcmp(d_S, "FASI") == 0)
     {
      if(k_int > 2)
      {
       goto Lab_29000;
      }
      if(k_int == 1)
      {
       sprintf(prt_S,"%s%s%s%s","((int)(",tmp_S[1],"), 0); ",t_S);
      }
      fprintf(fp_2,"%s%s%s\n",spc_S,"ixsetfs",prt_S);
      commfl_int = 1;
     }
     else
     {
      if(strcmp(d_S, "FACI") == 0)
      {
       if(k_int != 1)
       {
        goto Lab_29000;
       }
       fprintf(fp_2,"%s%s%s\n",spc_S,"ixsetfc",prt_S);
       commfl_int = 1;
      }
      else
      {
       if(strcmp(d_S, "TXCI") == 0)
       {
        if(k_int != 1)
        {
         goto Lab_29000;
        }
        fprintf(fp_2,"%s%s%s\n",spc_S,"ixsettc",prt_S);
        commfl_int = 1;
       }
       else
       {
        if(strcmp(d_S, "TFON") == 0)
        {
         if(k_int == 1)
         {
          strcpy(siz_S,"14");
         }
         if(k_int == 2)
         {
          strcpy(siz_S,tmp_S[2]);
          strcpy(enc_S,"iso8859-1");
         }
         if(k_int == 3)
         {
          strcpy(enc_S,tmp_S[3]);
         }
         if(k_int > 3)
         {
          goto Lab_29000;
         }
         vartyp(tmp_S[1], &typ_int);
         if(! (LEN(tmp_S[1]) <= 5 && (typ_int == 3 || typ_int == 4)))
         {
          goto Lab_21505;
         }
         strcpy(f_S,"p");
         strcpy(b_S,LEFT_S(tmp_S[1], 3));
         if(strcmp(b_S, "Hel") == 0)
         {
          strcpy(fam_S,"-adobe-helvetica");
          goto Lab_21503;
         }
         if(strcmp(b_S, "Tim") == 0)
         {
          strcpy(fam_S,"-adobe-times");
          goto Lab_21503;
         }
         if(strcmp(b_S, "Sym") == 0)
         {
          strcpy(fam_S,"-adobe-symbol");
          goto Lab_21503;
         }
         if(strcmp(b_S, "Fix") == 0)
         {
          strcpy(fam_S,"-misc-fixed");
          strcpy(f_S,"c");
          goto Lab_21503;
         }
         fprintf(stderr,"%s%s%s\n","qb2c: Special font name ",tmp_S[1]," undefined");
         goto Lab_29000;
Lab_21503:
         strcpy(b_S,MID_S(tmp_S[1], 4, LMAX));
         if(strcmp(b_S, "") == 0)
         {
          strcpy(b_S,"-medium-r");
         }
         if(strcmp(b_S, "B") == 0)
         {
          strcpy(b_S,"-bold-r");
         }
         if(strcmp(b_S, "I") == 0)
         {
          strcpy(b_S,"-medium-o");
         }
         if(strcmp(b_S, "BI") == 0)
         {
          strcpy(b_S,"-bold-o");
         }
Lab_21504:
         sprintf(tmp_S[1],"%s%s%s%s%s%s%s%s%s%s",e_S,fam_S,b_S,"-normal-*-",siz_S,"-*-100-100-",f_S,"-*-",enc_S,e_S);
Lab_21505:
         fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"if(ixsettf(1, strcpy(tws__S,",tmp_S[1],"))==1)",t_S);
         fprintf(fp_2,"%s%s%s%s%s%s\n",spc_S,"{ fprintf(stderr,",e_S,"Requested Xfont not found: %s\\n",e_S,",tws__S); }");
         commfl_int = 1;
        }
        else
        {
         if(strcmp(d_S, "TXAL") == 0)
         {
          if(k_int != 2)
          {
           goto Lab_29000;
          }
          fprintf(fp_2,"%s%s%s\n",spc_S,"ixsetta",prt_S);
          commfl_int = 1;
         }
         else
         {
          if(strcmp(d_S, "BG") == 0)
          {
           fprintf(fp_2,"%s%s%s\n",spc_S,"ixsetbg",prt_S);
           commfl_int = 1;
          }
          else
          {
           if(strcmp(d_S, "DRMD") == 0)
           {
            if(k_int != 1)
            {
             goto Lab_29000;
            }
            fprintf(fp_2,"%s%s%s\n",spc_S,"ixdrmde",prt_S);
            commfl_int = 1;
           }
           else
           {
            if(strcmp(d_S, "DMOD") == 0)
            {
             if(k_int > 16)
             {
              fprintf(stderr,"%s\n","Too many arguments to DMOD (>16)");
              signal_int = 1;   /* exit(1); */
              goto Lab_9999;
             }
             if(k_int == 1)
             {
              fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"ixsetls(-",tmp_S[1],", D__);",t_S);
             }
             else
             {
              if(k_int >= 2)
              {
                    strcpy(b_S,"D__[0]=");
                    strcat(b_S,tmp_S[1]); strcat(b_S,"; ");
               for(i_int = 2; i_int <= k_int; i_int++)
               {
                     strcat(b_S,"D__["); c='0'+i_int-1; strncat(b_S,&c,1);
                     strcat(b_S,"]="); strcat(b_S,tmp_S[i_int]);
                     strcat(b_S,"; ");
               }
               fprintf(fp_2,"%s%s%s\n",spc_S,b_S,t_S);
               fprintf(fp_2,"%s%s%s%s\n",spc_S,"ixsetls((int)",STR_S(k_int),", D__);");
              }
              else
              {
               fprintf(fp_2,"%s%s%s\n",spc_S,"ixsetls(0, D__);",t_S);
              }
             }
             grafflg_int = 1;
             commfl_int = 1;
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_22000:   /* "SAVEGIF ", "SAVEPS ", "SAVEEPS ", "SAVEPSL " (graphics) statements */
 /* save the picture into the file */
 /* Syntax: SAVExxx filename$ */
 strcpy(c_S,"0");
       if (a_S[4]=='P') { strcpy(d_S, "0"); goto Lab_22001;}
 fprintf(stderr,"%s% d %s%s\n","qb2c: This SAVExxx feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
Lab_22001:
 strcpy(b_S,MID_S(a_S, 8, LMAX));
 gulix(b_S);
 stringx(b_S);
 vartyp(b_S, &typ_int);
 if(typ_int == 7)
 {
  printfmt(b_S, formt_S, prt_S, &nflag_int);
  sprintf(prtf_S,"%s%s%s%s%s%s","sprintf(tws__S,",CHR_S(34),formt_S,CHR_S(34),prt_S,");");
  fprintf(fp_2,"%s%s\n",spc_S,prtf_S);
  strcpy(b_S,"tws__S");
  twsflg_int = 1;
 }
 fprintf(fp_2,"%s%s%s%s%s%s%s%s%s\n",spc_S,"ixdogif(",b_S,", ",d_S,", ",c_S,");",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_22500:   /* "LOADGIF " (graphics) statement */
 /* load a picture from the file */
 /* Syntax: LOADGIF (x%, y%), filename$[, ipal%], bgcolor%] */
 strcpy(b_S,MID_S(a_S, 8, LMAX));
 gulix(b_S);
      if (b_S[0] != '(') goto Lab_22509;
 quadrix(b_S);
 tokenix(b_S, &k_int, ",", "");
 if(k_int < 2)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 strcpy(b_S,tmp_S[1]);
 strcpy(d_S,tmp_S[2]);
 stringx(d_S);
 quadrix(d_S);
      strcpy(b_S,tmp_S[1]+1); b_S[strlen(b_S)-1]='\0';
 tokenix(b_S, &n_int, ",", "");
 if(k_int >= 3)
 {
  strcpy(b_S,tmp_S[3]);
  quadrix(b_S);
 }
 else
 {
  strcpy(b_S,"0");   /* default for ipal */
 }
 if(k_int >= 4)
 {
  strcpy(f_S,tmp_S[4]);
  quadrix(f_S);
 }
 else
 {
  strcpy(f_S,"-1");   /* default for bgcolor */
 }
 strcpy(temp_S[1],tmp_S[1]);
 strcpy(temp_S[2],tmp_S[2]);

 tokenix(d_S, &n_int, "+", "");
 if(n_int > 1)
 {
  printfmt(d_S, formt_S, prt_S, &nflag_int);
  sprintf(prtf_S,"%s%s%s%s%s%s","sprintf(tws__S,",CHR_S(34),formt_S,CHR_S(34),prt_S,");");
  fprintf(fp_2,"%s%s\n",spc_S,prtf_S);
  strcpy(d_S,"tws__S");
  twsflg_int = 1;
 }

 fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s%s%s%s\n",spc_S,"ixldgif((int)(",temp_S[1],"),(int)(",temp_S[2],"),",d_S,",(int)(",b_S,"),(int)(",f_S,"));",t_S);
 grafflg_int = 1;
 commfl_int = 1;
 if(updateff_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixupdwi(0);");
 }
Lab_22509:
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_22600:   /* "GIFINFO " (graphics) statement */
 /* Obtain width, height and ncol of a GIF */
 /* Syntax: GIFINFO file$, width[, height[, ncol]] */
 strcpy(b_S,MID_S(a_S, 8, LMAX));
 gulix(b_S);
 quadrix(b_S);
 tokenix(b_S, &k_int, ",", "");
 if(k_int < 2)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 sprintf(prt_S,"%s%s%s",spc_S,tmp_S[2]," = GInf__[0]; ");
 if(k_int >= 3)
 {
  sprintf(tws__S,"%s%s%s",prt_S,tmp_S[3]," = GInf__[1]; ");
  strcpy(prt_S,tws__S);
 }
 if(k_int >= 4)
 {
  sprintf(tws__S,"%s%s%s",prt_S,tmp_S[4]," = GInf__[2];");
  strcpy(prt_S,tws__S);
 }
 fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"gifinfo(",tmp_S[1],", GInf__);",t_S);
 fprintf(fp_2,"%s\n",prt_S);
 grafflg_int = 1;
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_22100:   /* "GET " OR "XGETGE " (graphics) statements */
 /* GET: get image in an array of pixels */
 /* Syntax: GET (x%, y%), array?, w%, h% */
 /* XGETGE: get window (win% >= 0) or the root window (win% < 0) geometry */
 /* Syntax: XGETGE (x%, y%), w%, h%, win% */
 tmpfl_int = 0;
      if (a_S[0] == 'G') tmpfl_int = 1;
 if(tmpfl_int)
 {
  strcpy(b_S,MID_S(a_S, 4, LMAX));
  gulix(b_S);
 }
 if(! tmpfl_int)
 {
  strcpy(b_S,MID_S(a_S, 7, LMAX));
  gulix(b_S);
 }
 quadrix(b_S);
 tokenix(b_S, &k_int, ",", "");
      if (b_S[0] != '(' || k_int != 4) {
 fprintf(stderr,"%s%s%s\n","ERROR in line",STR_S(nl_int)," probably wrong number of arguments:");
 fprintf(stderr,"%s\n",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
      }
 strcpy(b_S,tmp_S[1]);
 strcpy(d_S,tmp_S[2]);
      strcpy(b_S,tmp_S[1]+1); b_S[strlen(b_S)-1]='\0';
 tokenix(b_S, &n_int, ",", "");
 if(n_int != 2)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 if(tmpfl_int)
 {
  fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s%s%s%s\n",spc_S,"ixpicget((int)(",tmp_S[1],"),(int)(",tmp_S[2],"),(int)(",tmp_S[3],"),(int)(",tmp_S[4],"),",d_S,");",t_S);
 }
 else
 {
  fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s%s%s%s\n",spc_S,"ixgetge(",tmp_S[4],",&",tmp_S[1],",&",tmp_S[2],",&",d_S,",&",tmp_S[3],");",t_S);
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_22200:   /* "PUT " and/or "XANIM "(graphics) statement */
 /* Put array of pixels on window: */
 /* Syntax: PUT (x%, y%), array?, w%, h%[, (xs%, ys%)[, sw%, sh%]] */
 /* Animate series of arrays: */
 /* Syntax: XANIM (x%, y%), array?, w%, h%[, (xs%, ys%)[, sw%, sh%]] */
 flag_int = 1;
      if (memcmp(a_S,"XANIM ",6)==0) flag_int = 0;
 if(flag_int)
 {
  strcpy(b_S,MID_S(a_S, 4, LMAX));
 }
 else
 {
  strcpy(b_S,MID_S(a_S, 6, LMAX));
 }
 gulix(b_S);
 quadrix(b_S);
 tokenix(b_S, &k_int, ",", "");
      if (b_S[0] != '(' || (k_int != 4 && k_int != 5 && k_int != 7)) {
 goto Lab_29500;   /* Error message on No of args and exit */
      }
 strcpy(d_S,tmp_S[2]);
 strcpy(b_S,tmp_S[1]);
      strcpy(b_S,tmp_S[1]+1); b_S[strlen(b_S)-1]='\0';
 tokenix(b_S, &n_int, ",", "");
 if(n_int != 2)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 strcpy(temp_S[1],tmp_S[1]);
 strcpy(temp_S[2],tmp_S[2]);
 if(k_int > 4)
 {
  strcpy(b_S,tmp_S[5]);
       strcpy(b_S,tmp_S[5]+1); b_S[strlen(b_S)-1]='\0';
  tokenix(b_S, &n_int, ",", "");
  if(n_int != 2)
  {
   /* RETURN */
   longjmp(j__buf[--j__lev],1);
  }
 }
 if(k_int == 5)
 {
  sprintf(tmp_S[6],"%s%s%s",tmp_S[3],"-",tmp_S[1]);
  sprintf(tmp_S[7],"%s%s%s",tmp_S[4],"-",tmp_S[2]);
 }
 if(k_int == 4)
 {
  strcpy(tmp_S[1],"0");
  strcpy(tmp_S[2],"0");
  strcpy(tmp_S[6],tmp_S[3]);
  strcpy(tmp_S[7],tmp_S[4]);
 }
 sprintf(prt_S,"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s","((int)(",temp_S[1],"),(int)(",temp_S[2],"),",d_S,",(int)(",tmp_S[3],"),(int)(",tmp_S[4],"),(int)(",tmp_S[1],"),(int)(",tmp_S[2],"),(int)(",tmp_S[6],"),(int)(",tmp_S[7],"));");
 if(flag_int)
 {
  fprintf(fp_2,"%s%s%s%s\n",spc_S,"ixpicput",prt_S,t_S);
 }
 else
 {
  fprintf(fp_2,"%s%s%s%s\n",spc_S,"ixpicanim",prt_S,t_S);
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_23000:   /* "XUPDATE" (graphics) statement */
 /* update (refresh) the X-window */
 fprintf(fp_2,"%s%s%s\n",spc_S,"ixupdwi(0); ",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_23200:   /* "XCLS" (graphics) statement */
 /* Clear the current window according to the current background or */
 /* change background color and then clear. */
 strcpy(b_S,MID_S(a_S, 6, LMAX));
 gulix(b_S);
 quadrix(b_S);
 if(strcmp(b_S, "") == 0)
 {
  fprintf(fp_2,"%s%s%s\n",spc_S,"ixclrwi(); ",t_S);
 }
 else
 {
  fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"ixsetbg((int)",b_S,"); ixclrwi();",t_S);
 }
 commfl_int = 1;
 if(updateff_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixupdwi(0);");
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_23300:   /* "GETCOL " (graphics) statement */
 /* get color components */
 /* getcol index%, r%, g%, b%  Input: index%, Output r%,g%,b%<=255 */
 strcpy(b_S,MID_S(a_S, 7, LMAX));
 quadrix(b_S);
 tokenix(b_S, &n_int, ",", "");
 if(n_int == 4)
 {
  sprintf(prt_S,"%s%s%s%s%s%s%s",tmp_S[1],"),&",tmp_S[2],",&",tmp_S[3],",&",tmp_S[4]);
  fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"ixgetcol((int)(",prt_S,");",t_S);
 }
 else
 {
  goto Lab_29500;   /* Error message on No of args and exit */
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_23400:   /* "XSELWI" and/or "XCLOSE" and/or "XCURSOR" and/or "XCLOSEDS" */
 /* (graphics) statement */
 /* select and raise window to which subseq. output is sent D=current */
 strcpy(b_S,MID_S(a_S, 8, LMAX));
 gulix(b_S);
 quadrix(b_S);
 if(strcmp(b_S, "") == 0)
 {
  strcpy(prt_S,"(-1); ");
 }
 else
 {
  sprintf(prt_S,"%s%s%s","((int)(",b_S,")); ");
 }
       if ( memcmp(a_S,"XSELWI",6)==0 ) {
 strcpy(d_S,"ixselwi");
       } else {
        if ( memcmp(a_S,"XCLOSEDS",8)==0 ) {
 strcpy(d_S,"ixclsds");
 strcpy(prt_S,"(); ");
        } else {
         if ( memcmp(a_S,"XCLOSE",6)==0 ) {
 strcpy(d_S,"ixclswi");
         } else {
 strcpy(d_S,"ixcursor");
         }
        }
       }
 fprintf(fp_2,"%s%s%s%s\n",spc_S,d_S,prt_S,t_S);
 commfl_int = 1;
 grafflg_int = 1;
 if(updateff_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixupdwi(0);");
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_23500:   /* "PALETTE " (graphics) statement */
 /* palette index,#hex_color   or */
 /* palette index,r,g,b  where r,g,b<=255 */
 strcpy(b_S,MID_S(a_S, 9, LMAX));
 quadrix(b_S);
 tokenix(b_S, &n_int, ",", "");
 if(n_int == 4)
 {
  sprintf(prt_S,"%s%s%s%s%s%s%s",tmp_S[1],"),",tmp_S[2],",",tmp_S[3],",",tmp_S[4]);
  fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"ixsetco((int)(",prt_S,");",t_S);
 }
 else
 {
  goto Lab_29500;   /* Error message on No of args and exit */
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_23600:   /* "XTITLE " (graphics) statement */
 /* xtitle title$[, win%]  Set window title */
 strcpy(b_S,MID_S(a_S, 7, LMAX));
 quadrix(b_S);
 tokenix(b_S, &n_int, ",", "");
 strcpy(b_S,tmp_S[1]);
 if(n_int == 1)
 {
  strcpy(d_S,"-1");
 }
 else
 {
  if(n_int == 2)
  {
   sprintf(d_S,"%s%s%s","(int)(",tmp_S[2],")");
  }
  else
  {
   goto Lab_29500;   /* Error message on No of args and exit */
  }
 }
 vartyp(b_S, &typ_int);
 if(typ_int == 7)
 {
  printfmt(b_S, formt_S, prt_S, &nflag_int);
  sprintf(prtf_S,"%s%s%s%s%s%s","sprintf(tws__S,",CHR_S(34),formt_S,CHR_S(34),prt_S,");");
  fprintf(fp_2,"%s%s\n",spc_S,prtf_S);
  strcpy(b_S,"tws__S");
  twsflg_int = 1;
 }
 fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"ixtitle(",b_S,",",d_S,");",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_23700:   /* "XREQST " (graphics) statement */
 /* xreqst (x%, y%), test$, status% - request string at the postition */
 /* and return status 0 = <Esc>, 1 = <Return> */
 strcpy(b_S,MID_S(a_S, 7, LMAX));
 quadrix(b_S);
 tokenix(b_S, &n_int, ",", "");
 if(n_int != 3)
 {
  goto Lab_29500;   /* Error message on No of args and exit */
 }
 strcpy(temp_S[2],tmp_S[2]);
       strcpy(d_S,tmp_S[1]+1); d_S[strlen(d_S)-1]='\0';
 tokenix(d_S, &n_int, ",", "");
 fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s\n",spc_S,tmp_S[3]," = ixreqst((int)(",tmp_S[1],"),(int)(",tmp_S[2],"),",temp_S[2],");",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_23800:   /* "XCLIP " (graphics) statement */
 /* xclip (x1%, y1%)-(x2%, y2%), win% - set clipping rectangle in */
 /* the window win% */
 strcpy(b_S,MID_S(a_S, 6, LMAX));
 quadrix(b_S);
 tokenix(b_S, &k_int, "-", ",");
 if(k_int != 3)
 {
  goto Lab_29500;   /* Error message on No of args and exit */
 }
       strcpy(b_S,tmp_S[1]+1); b_S[strlen(b_S)-1]='\0';
       strcpy(d_S,tmp_S[2]+1); d_S[strlen(d_S)-1]='\0';
 tokenix(b_S, &n_int, ",", "");
 strcpy(temp_S[1],tmp_S[1]);
 strcpy(temp_S[2],tmp_S[2]);
 tokenix(d_S, &n_int, ",", "");
 strcpy(temp_S[3],tmp_S[1]);
 strcpy(temp_S[4],tmp_S[2]);
 fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s%s%s%s\n",spc_S,"ixclip1((int)(",tmp_S[3],"),(int)(",temp_S[1],"),(int)(",temp_S[2],"),(int)(",temp_S[3],"),(int)(",temp_S[4],"));",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_23900:   /* "XNOCLI " (graphics) statement */
 /* xnocli win% - set no clipping for win% */
 strcpy(b_S,MID_S(a_S, 7, LMAX));
 quadrix(b_S);
 fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"ixnocli((int)(",b_S,"));",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_23950:   /* "XWARP " (graphics) statement */
 /* xwarp (x%, y%) - move graphical cursor (pointer) to the position */
 /* (x%, y%) in the current window */
 strcpy(b_S,MID_S(a_S, 6, LMAX));
 quadrix(b_S);
       b_S[0]=' '; b_S[strlen(b_S)-1]='\0';
 tokenix(b_S, &n_int, ",", "");
 if(n_int != 2)
 {
  goto Lab_29500;   /* Error message on No of args and exit */
 }
 fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"ixwarp((int)(",tmp_S[1],"),(int)(",tmp_S[2],"));",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_24000:   /* "MARKER " (graphics) statement */
 strcpy(b_S,MID_S(a_S, 8, LMAX));
 gulix(b_S);
       if (b_S[0] != '(') goto Lab_24009;
 quadrix(b_S);
 tokenix(b_S, &k_int, ",", "");
 if(k_int >= 2)
 {
  fprintf(fp_2,"%s%s%s%s\n",spc_S,"ixsetmc(",tmp_S[2],");");
 }
       strcpy(b_S,tmp_S[1]+1); b_S[strlen(b_S)-1]='\0';
 tokenix(b_S, &n_int, ",", "");
 fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"xy__pos[0][0]=",tmp_S[1],"; xy__pos[0][1]=",tmp_S[2],";",t_S);
 fprintf(fp_2,"%s%s\n",spc_S,"ixmarke(1,xy__pos);");
 if(updateff_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixupdwi(0);");
 }
 grafflg_int = 1;
 commfl_int = 1;
Lab_24009:
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_24500:   /* "PLINE " (graphics) statement */
 strcpy(b_S,MID_S(a_S, 7, LMAX));
 tokenix(b_S, &n_int, ",", "");
 quadrix(tmp_S[1]);
 quadrix(tmp_S[2]);
 if(n_int > 2)
 {
  quadrix(tmp_S[3]);
  fprintf(fp_2,"%s%s%s%s\n",spc_S,"ixsetlc(",tmp_S[3],");");
 }
 fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"ixline(",tmp_S[1],",",tmp_S[2],");",t_S);
 if(updateff_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixupdwi(0);");
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_25000:   /* "PMARKER " (graphics) statement */
 strcpy(b_S,MID_S(a_S, 9, LMAX));
 tokenix(b_S, &n_int, ",", "");
 quadrix(tmp_S[1]);
 quadrix(tmp_S[2]);
 if(n_int > 2)
 {
  quadrix(tmp_S[3]);
  fprintf(fp_2,"%s%s%s%s\n",spc_S,"ixsetmc(",tmp_S[3],");");
 }
 fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"ixmarke(",tmp_S[1],",",tmp_S[2],");",t_S);
 if(updateff_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixupdwi(0);");
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_25500:   /* "XTEXT " (graphics) statement */
 strcpy(b_S,MID_S(a_S, 7, LMAX));
 quadrix(b_S);
 tokenix(b_S, &k_int, ",", "");
 strcpy(b_S,tmp_S[2]);   /* CALL stringix(d$) */
 strcpy(temp_S[5],tmp_S[4]);
 strcpy(temp_S[4],tmp_S[3]);
       strcpy(d_S,tmp_S[1]+1); d_S[strlen(d_S)-1]='\0';
 tokenix(d_S, &n_int, ",", "");
 strcpy(temp_S[2],tmp_S[2]);
 strcpy(temp_S[1],tmp_S[1]);
 if(k_int  == 2)
 {
  strcpy(temp_S[4],"0.");
 }
 if(k_int <= 3)
 {
  strcpy(temp_S[5],"1.");
 }
 vartyp(b_S, &typ_int);
 if(typ_int == 7)
 {
  printfmt(b_S, formt_S, prt_S, &nflag_int);
  sprintf(prtf_S,"%s%s%s%s%s%s","sprintf(tws__S,",CHR_S(34),formt_S,CHR_S(34),prt_S,");");
  fprintf(fp_2,"%s%s\n",spc_S,prtf_S);
  strcpy(b_S,"tws__S");
  twsflg_int = 1;
 }
 fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s%s%s%s\n",spc_S,"ixtext(0,(int)(",temp_S[1],"),(int)(",temp_S[2],"),(float)(",temp_S[4],"),(float)(",temp_S[5],"),",b_S,");",t_S);
 if(updateff_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixupdwi(0);");
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_26000:   /* "FAREA " (graphics) statement */
 strcpy(b_S,MID_S(a_S, 7, LMAX));
 quadrix(b_S);
 tokenix(b_S, &n_int, ",", "");
 if(n_int > 2)
 {
  quadrix(tmp_S[3]);
  fprintf(fp_2,"%s%s%s%s\n",spc_S,"ixsetfc(",tmp_S[3],");");
 }
 fprintf(fp_2,"%s%s%s%s%s%s%s\n",spc_S,"ixflare(",tmp_S[1],",",tmp_S[2],");",t_S);
 if(updateff_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixupdwi(0);");
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_26500:   /* "CIRCLE " (graphics) statement */
 strcpy(b_S,MID_S(a_S, 8, LMAX));
 quadrix(b_S);
       tmp_S[3][0] = '\0';
       tmp_S[4][0] = '\0';
       tmp_S[5][0] = '\0';
       tmp_S[6][0] = '\0';
 tokenix(b_S, &k_int, ",", "");
 strcpy(tmp_S[0],tmp_S[2]);
       strcpy(d_S,tmp_S[1]+1); d_S[strlen(d_S)-1]='\0';
 tokenix(d_S, &n_int, ",", "");
 sprintf(prt_S,"%s%s%s%s%s%s","ixcirc((int)(",tmp_S[1],"),(int)(",tmp_S[2],"),(int)(",tmp_S[0]);
 flag_int = 0;
       if (tmp_S[3][0]!='\0')
       {
 fprintf(fp_2,"%s%s%s%s\n",spc_S,"ixsetlc(",tmp_S[3],");");
 flag_int = 1;
       }
 if(! flag_int && colorfl_int)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixsetlc(1);");
 }
       if (tmp_S[4][0]=='\0')
       {
 strcpy(tmp_S[4],"0.");
       }
       if (tmp_S[5][0]=='\0')
       {
 strcpy(tmp_S[5],"6.2832");
       }
       if (tmp_S[6][0]=='\0')
       {
 strcpy(tmp_S[6],"1.");
       }
 sprintf(tws__S,"%s%s%s%s%s%s%s%s",prt_S,"),",tmp_S[4],",",tmp_S[5],",",tmp_S[6],");");
 strcpy(prt_S,tws__S);
 fprintf(fp_2,"%s%s%s\n",spc_S,prt_S,t_S);
 if(updateff_int == 1)
 {
  fprintf(fp_2,"%s%s\n",spc_S,"ixupdwi(0);");
 }
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_27000:   /* "GCGET " (graphics) statement */
 /* Request mouse position: gcget (x%, y%), answ%[, typ%[, mode%]] */
 strcpy(b_S,MID_S(a_S, 7, LMAX));
 gulix(b_S);
 quadrix(b_S);
 tokenix(b_S, &k_int, ",", "");
 if(k_int < 2 || k_int > 4)
 {
  goto Lab_29000;
 }
 if(k_int < 3)   /* Default ityp */
 {
  strcpy(tmp_S[3],"0");
 }
 if(k_int < 4)   /* Default mode */
 {
  strcpy(tmp_S[4],"1");
 }
 strcpy(tmp_S[0],tmp_S[2]);
 strcpy(d_S,tmp_S[1]);
       strcpy(d_S,tmp_S[1]+1); d_S[strlen(d_S)-1]='\0';
 tokenix(d_S, &n_int, ",", "");
 if(n_int != 2)
 {
  goto Lab_29000;
 }
 fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s%s%s\n",spc_S,tmp_S[0],"=ixreqlo((int)",tmp_S[4],",(int)",tmp_S[3],",&",tmp_S[1],",&",tmp_S[2],");",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_27500:   /* "XPOINTER " (graphics) statement */
 /* Request mouse position:xpointer (x%, y%), win%, answ%[, typ%[, mode%]] */
 strcpy(b_S,MID_S(a_S, 10, LMAX));
 gulix(b_S);
 quadrix(b_S);
 tokenix(b_S, &k_int, ",", "");
 if(k_int < 3 || k_int > 5)
 {
  goto Lab_29000;
 }
 if(k_int < 4)   /* Default ityp */
 {
  strcpy(tmp_S[4],"1");
 }
 if(k_int < 5)   /* Default mode */
 {
  strcpy(tmp_S[5],"1");
 }
 strcpy(tmp_S[0],tmp_S[2]);
 strcpy(d_S,tmp_S[1]);
       strcpy(d_S,tmp_S[1]+1); d_S[strlen(d_S)-1]='\0';
 tokenix(d_S, &n_int, ",", "");
 if(n_int != 2)
 {
  goto Lab_29000;
 }
 fprintf(fp_2,"%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",spc_S,tmp_S[3],"=ixwptrq(&",tmp_S[1],",&",tmp_S[2],",&",tmp_S[0],",(int)",tmp_S[4],",(int)",tmp_S[5],");",t_S);
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_28000:   /* "XROT " (graphics) statement */
 fprintf(stderr,"%s% d %s%s\n","qb2c: XROT feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_28100:   /* "XTRAN " (graphics) statement */
 fprintf(stderr,"%s% d %s%s\n","qb2c: XTRAN feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_28200:   /* "XSCAL " (graphics) statement */
 fprintf(stderr,"%s% d %s%s\n","qb2c: XSCAL feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_28300:   /* "MRESET" (graphics) statement */
 fprintf(stderr,"%s% d %s%s\n","qb2c: MRESET feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_28400:   /* "XBUF" (graphics) statement */
 fprintf(stderr,"%s% d %s%s\n","qb2c: XBUF feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_28500:   /* "XRMBUF" (graphics) statement */
 fprintf(stderr,"%s% d %s%s\n","qb2c: XRMBUF feature available in pay version only.",nl_int,":",line_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_29000:   /* Anything else not covered yet */
 if(commfl_int == 1)
 {
  /* RETURN */
  longjmp(j__buf[--j__lev],1);
 }
 fprintf(stderr,"%s%s%s%s\n","ERROR in line",STR_S(nl_int),": ",line_S);
 fprintf(stderr,"%s%s%s%s\n","'",a_S,"'"," cannot be translated ! Please see the manual.");
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;
 commfl_int = 1;
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_29500:   /* Error message on number of arguments */
 fprintf(stderr,"%s%s%s\n","ERROR on line",STR_S(nl_int)," probably wrong number of arguments in:");
 fprintf(stderr,"%s\n",a_S);
 signal_int = 1;   /* exit(1); */
 goto Lab_9999;


Lab_30000:   /* for nicer 'REM' placements */
 /* input: lremfl%, itok%, ntok% */
 if(lremfl_int == 1 && itok_int == 1)
 {
  sprintf(tws__S,"%s%s%s%s",SPACE_S(3),"/* ",t_S," */");
  strcpy(t_S,tws__S);
  lremfl_int = 0;
 }
 else
 {
  strcpy(t_S,"");
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_31000:   /* Called before every sub (and MAIN) makes a list of possibly used */
 /*   arrays "name(" which are converted to C format in 28000 */
 /* Inputs: */
 /* 1) list of shared     vars. & arrs. shtok$(isub%,i%), nsthok%(isub%) */
 /* 2) list of used local vars. & arrs. vlist$(isub%,i%), nvlist%(isub%) */
 /* 3) list of SUB arguments (NOT YET ! arrays cannot be passed yet) */
 /* Outputs: */
 /* atmp$(), natmp% */
 natmp_int = 0;   /* Extracting all array names */
 for(i_int = 1; i_int <= nshtok_int[isub_int]; i_int++)
 {
  strcpy(z_S,shtok_S[isub_int][i_int]);
  if(strcmp(RIGHT_S(z_S, 1), ")") == 0)
  {
   natmp_int = natmp_int + 1;
   strcpy(atmp_S[natmp_int],LEFT_S(z_S, LEN(z_S) - 1));
  }
 }
 /*   Not needed since DIM fills dynamycally arrays of this class */
 /*   FOR i% = 1 TO nvlist%(isub%) */
 /*    z$ = vlist$(isub%, i%) */
 /*    IF RIGHT$(z$, 1) = ")" THEN */
 /*      natmp% = natmp% + 1 */
 /*      atmp$(natmp%) = LEFT$(z$, LEN(z$) - 1) */
 /*    END IF */
 /*   NEXT i% */
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_40000:   /* postprocessing i% -> i_int, i& -> i_long, c$ -> c_S */
 /* and array brackets (except in declarations which is done). */
 /* Also handles MID$(a$,i%) -> MID_S(a_S,i_int,LMAX) */
 if((fp_3 = fopen(strcpy(fn3__S,outf_S), "r")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn3__S); exit(1);
 }
 if((fp_2 = fopen(strcpy(fn2__S,tmpfile_S), "w")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn2__S); exit(1);
 }
 /* GOSUB Lab_41000 */    /* Writing out headers and global declarations */
 if (setjmp(j__buf[j__lev++])==0) goto Lab_41000;
 strcpy(e_S,CHR_S(34));
 togfl_int = 0;
 while(! eof(fp_3))
 {
  fgets(line_S, LMAX, fp_3);
  line_S[strlen(line_S) - 1] = '\0';
       if (togfl_int == 1) goto Lab_40001;
       if (strncmp(line_S,"/* Trans",8) == 0)
       { if (strncmp(line_S,"/* Translates of used QB's intrinsic functions: */",50) == 0)
         togfl_int = 1; goto Lab_40001; }
       if (cflag_int==1 && line_S[0] == 'C')
       {
        if (line_S[1]==' ' || line_S[1]=='\0' || line_S[1]=='\t') line_S[0]=' ';
       }
       else
       {
  varpost(line_S);   /* Postprocessing variable names */
       }
Lab_40001:
  fprintf(fp_2,"%s\n",line_S);
 }
 fclose(fp_3);
 fclose(fp_2);
 sprintf(tws__S,"%s%s%s%s","mv -f ",tmpfile_S," ",outf_S);
 system(tws__S);
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_41000:   /* Writes out headers: #include files and global declarations */
 /* before the 'main(...)' */
 if(debug_int)
 {
  printf("%s% .7G \n","Postprocess 41000. Headers and global declarations: ",(double)(TIMER() - T0));
 }
 lspac_int = 0;   /* dirty... */
 isub_int = 0;
 statfl_int[isub_int] = 1;
 strcpy(spc_S,SPACE_S(lspac_int));
 fprintf(fp_2,"%s\n","#include <stdio.h>");
 fprintf(fp_2,"%s\n","#include <string.h>");
 fprintf(fp_2,"%s\n","#include <stddef.h>");
 fprintf(fp_2,"%s\n","#include <stdlib.h>");
 if(retrnfl_int == 1)
 {
  fprintf(fp_2,"%s\n","#include <setjmp.h>");
 }
 if(timefl_int == 1)
 {
  fprintf(fp_2,"%s\n","#include <time.h>");
 }
 if(systimefl_int == 1)
 {
  fprintf(fp_2,"%s\n","#include <sys/time.h>");
 }
 if(unistdfl_int == 1)
 {
  fprintf(fp_2,"%s\n","#include <unistd.h>");
 }
 if(mathfl_int == 1)
 {
  fprintf(fp_2,"%s\n","#include <math.h>");
 }
 if(grafflg_int == 1)
 {
  fprintf(fp_2,"%s\n","#include <X11/cursorfont.h>");
 }
 fprintf(fp_2,"%s\n","#include <ctype.h>");
 if(inkeyff_int == 1 && tflg_int == 0)
 {
  fprintf(fp_2,"%s\n","#include <fcntl.h>");
  fprintf(fp_2,"%s\n","#include <sys/ioctl.h>");
  fprintf(fp_2,"%s\n","#include <termio.h>");
  fprintf(fp_2,"%s\n","#include <termios.h>");
  if(Iflag_int && ! pausefl_int)
  {
   fprintf(fp_2,"%s\n","#include <sys/time.h>");
   fprintf(fp_2,"%s\n","#include <sys/types.h>");
  }
 }
 if(pausefl_int)
 {
  fprintf(fp_2,"%s\n","#include <sys/types.h>");
  fprintf(fp_2,"%s\n","#include <sys/time.h>");
 }
 if(lofff_int)
 {
  fprintf(fp_2,"%s\n","#include <sys/stat.h>");
  if(! pausefl_int)
  {
   fprintf(fp_2,"%s\n","#include <sys/types.h>");
  }
 }
 fprintf(fp_2,"\n");
 fprintf(fp_2,"%s\n","/* This file was generated by QuasiBASIC to C translator */");
 fprintf(fp_2,"%s%s%s\n","/* qb2c  ver.",Version_S,"                            */");
 fprintf(fp_2,"\n");
 /* Global constants: */
 /* PRINT #2, "#define LMAX 32767" */
 fprintf(fp_2,"%s%s%s\n","#define LMAX",STR_S(Lmax_int)," /* Max strig length */");   /* Max. in/out line length (max 32767) */
 if(minff_int == 1)
 {
  fprintf(fp_2,"%s\n","#define MIN(a,b) ((a) < (b) ? (a) : (b))");
 }
 if(maxff_int == 1)
 {
  fprintf(fp_2,"%s\n","#define MAX(a,b) ((a) > (b) ? (a) : (b))");
 }
 if(ncnst_int > 0)
 {
  for(i_int = 1; i_int <= ncnst_int; i_int++)
  {
   strcpy(prtf_S,cnst_S[i_int]);
   varpost(prtf_S);
   fprintf(fp_2,"%s\n",prtf_S);
  }
 }
 if(ncg_int > 0)
 {
  for(i_int = 1; i_int <= ncg_int; i_int++)
  {
   fprintf(fp_2,"%s\n",cg_S[i_int]);
  }
 }
 fprintf(fp_2,"\n");
 fprintf(fp_2,"%s\n","/* Function declarations */");
 /*   Intrinsic QB functions: */
 if(extrnfl_int == 1)
 {
  qbfdecl();
 }
 /*   User SUBs and FUNCTIONs: */
 for(i_int = 1; i_int <= nfuncs_int; i_int++)
 {
  strcpy(b_S,funames_S[i_int]);
  vartyp(b_S, &typ_int);
  varpost(b_S);
  strcpy(z_S,"");
  if(typ_int == 5)
  {
   strcpy(z_S,"*");
  }
  fprintf(fp_2,"%s%s%s%s%s%s%s\n","extern ",atyp_S[typ_int],z_S,b_S,"(",funtyl_S[i_int],");");
 }
 fprintf(fp_2,"\n");
 tmpfl_int = 0;
 fprintf(fp_2,"%s\n","/* Shared variables and arrays declarations */");
 if(retrnfl_int == 1)
 {
  fprintf(fp_2,"%s% .7G %s\n","static jmp_buf j__buf[",(double)(GMAX),"];");
  fprintf(fp_2,"%s\n","static int  j__lev=0;");
  tmpfl_int = 1;
 }
 /*   DATA block: */
 if(datalin_int)
 {
  fprintf(fp_2,"%s%s%s\n","static int  data__c_int=0, data__M_int=",STR_S(datacnt_int),";");
  fprintf(fp_2,"%s\n","static char *DATA__S[]={  /* DATA block */");
       data_S[datalin_int][strlen(data_S[datalin_int])-1]='\0';
  for(i_int = 1; i_int <= datalin_int; i_int++)
  {
   fprintf(fp_2,"%s\n",data_S[i_int]);
  }
  fprintf(fp_2,"%s\n","};");
  tmpfl_int = 1;
 }
 if(grafflg_int == 1)
 {
  fprintf(fp_2,"%s\n","static short xy__pos[3][2], D__[16], GInf__[3];");
  tmpfl_int = 1;
 }
 if(inkeyff_int == 1 && tflg_int == 0)
 {
  fprintf(fp_2,"%s\n","static struct termio term_orig;");
  fprintf(fp_2,"%s\n","static int  kbdflgs;");
  fprintf(fp_2,"%s\n","static char keyb__S[30][9], keyq__S[30][4];");
  tmpfl_int = 1;
 }
 if(pausefl_int)
 {
  fprintf(fp_2,"%s\n","static struct timeval t__;");
 }
 if(lofff_int)
 {
  fprintf(fp_2,"%s\n","static struct stat stbuf;");
 }
 /* Declaring SHARED arrays in MAIN */
 if(alis_int > 0)
 {
  for(i_int = 1; i_int <= alis_int; i_int++)
  {
   strcpy(d_S,darr_S[alist_int[i_int]]);
   vartyp(d_S, &typ_int);
   brackets(d_S);
   if(dynaf__int[alist_int[i_int]])
   {
    fprintf(stderr,"%s% d %s%s\n","qb2c: DIM DYNAMIC feature available in pay version only.",nl_int,":",line_S);
    signal_int = 1;   /* exit(1); */
    goto Lab_9999;
   }
   else
   {
    /* Static arrays */
    sprintf(prtf_S,"%s%s%s",atyp_S[typ_int - 10],d_S,";");
   }
   varpost(prtf_S);
   fprintf(fp_2,"%s%s\n","static ",prtf_S);
   tmpfl_int = 1;
  }
 }
 if(chartfl_int == 1)
 {
  fprintf(fp_2,"%s\n","static char   w__S[16][LMAX];");
  fprintf(fp_2,"%s\n","static int    j__S = 0, j__Stmp;");
  tmpfl_int = 1;
 }
 if(inttfl_int == 1)
 {
  fprintf(fp_2,"%s\n","static int    w__s[16];");
  fprintf(fp_2,"%s\n","static int    i__s = 0, i__stmp;");
  tmpfl_int = 1;
 }
 if(longtfl_int == 1)
 {
  fprintf(fp_2,"%s\n","static long   w__l[16];");
  fprintf(fp_2,"%s\n","static int    i__l = 0, i__ltmp;");
  tmpfl_int = 1;
 }
 if(floattfl_int == 1)
 {
  fprintf(fp_2,"%s\n","static float  w__f[16];");
  fprintf(fp_2,"%s\n","static int    i__f = 0, i__ftmp;");
  tmpfl_int = 1;
 }
 if(vdblff_int == 1)
 {
  fprintf(fp_2,"%s\n","static double w__d[16];");
  fprintf(fp_2,"%s\n","static int    i__d = 0, i__dtmp;");
  tmpfl_int = 1;
 }
 if(byttfl_int == 1)
 {
  fprintf(fp_2,"%s\n","static unsigned char w__b[16];");
  fprintf(fp_2,"%s\n","static int    i__b = 0, i__btmp;");
  tmpfl_int = 1;
 }
 if(sigiff_int == 1)
 {
  fprintf(fp_2,"%s\n","static int  sig__i[16];");
  fprintf(fp_2,"%s\n","static int  j__sig = 0;");
  tmpfl_int = 1;
 }
 if(twsflg_int == 1)
 {
  tmpfl_int = 1;
  fprintf(fp_2,"%s\n","static char tws__S[LMAX];");
 }
 if(nSHRDtk_int > 0)
 {
  strcpy(int_S," int  ");
  strcpy(float_S," float ");
  if(longflg_int == 1)
  {
   strcpy(int_S," long ");
  }
  if(doblflg_int == 1)
  {
   strcpy(float_S," double ");
  }
  if(strcmp(sint_S, "") != 0)
  {
   i__stmp = ++i__s % 16;
   w__s[(i__stmp + 0 ) % 16] = 3;
   i__s = (i__s + 0 ) % 16;
   declarix(int_S, sint_S, &w__s[(i__stmp+0)%16]);
   tmpfl_int = 1;
  }
  if(strcmp(srea_S, "") != 0)
  {
   i__stmp = ++i__s % 16;
   w__s[(i__stmp + 0 ) % 16] = 0;
   i__s = (i__s + 0 ) % 16;
   declarix(float_S, srea_S, &w__s[(i__stmp+0)%16]);
   tmpfl_int = 1;
  }
  if(strcmp(ssss_S, "") != 0)
  {
   i__stmp = ++i__s % 16;
   w__s[(i__stmp + 0 ) % 16] = 1;
   i__s = (i__s + 0 ) % 16;
   declarix(" char ", ssss_S, &w__s[(i__stmp+0)%16]);
   tmpfl_int = 1;
  }
  if(strcmp(slin_S, "") != 0)
  {
   i__stmp = ++i__s % 16;
   w__s[(i__stmp + 0 ) % 16] = 4;
   i__s = (i__s + 0 ) % 16;
   declarix(" long ", slin_S, &w__s[(i__stmp+0)%16]);
   tmpfl_int = 1;
  }
  if(strcmp(sdbl_S, "") != 0)
  {
   i__stmp = ++i__s % 16;
   w__s[(i__stmp + 0 ) % 16] = 0;
   i__s = (i__s + 0 ) % 16;
   declarix(" double ", sdbl_S, &w__s[(i__stmp+0)%16]);
   tmpfl_int = 1;
  }
 }
 fprintf(fp_2,"\n");
 fprintf(fp_2,"%s\n","/* Open files pointers */");
 if(nopen_int > 0)
 {
  fprintf(fp_2,"%s%s%s\n","FILE ",fff_S,";");
  fprintf(fp_2,"%s%s%s\n","char ",fn_S,";");
  tmpfl_int = 1;
 }
 if(tmpfl_int == 1)
 {
  fprintf(fp_2,"\n");
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);



Lab_45000:   /* Adding pointer prefixes '*' to variables in SUBs (postprocess) */
 /* except in FUNCTIONs */
 /* Also handles Labels to override HP compiler problem, 45050 */
 /* Must be done *before* 40000 post. */
 /* Does not change comment lines ???? */
 /* writes out initializations in MAIN that appear after declarations */
 if(debug_int)
 {
  printf("%s% .7G \n","Postprocess 45000. Adding pointer prefixes '*' etc: ",(double)(TIMER() - T0));
 }
 isub_int = 0;
 lbfl_int = 0;
 nl_int = 0;
 tmpfl_int = 0;
 if((fp_2 = fopen(strcpy(fn2__S,outf_S), "r")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn2__S); exit(1);
 }
 if((fp_3 = fopen(strcpy(fn3__S,tmpfile_S), "w")) == NULL)
 {
  fprintf(stderr,"Can't open file %s\n",fn3__S); exit(1);
 }
 while(! eof(fp_2))
 {
  fgets(line_S, LMAX, fp_2);
  line_S[strlen(line_S) - 1] = '\0';
  nl_int = nl_int + 1;
  if(tmpfl_int == 1)
  {
   goto Lab_45010;
  }
  /* GOSUB Lab_45050 */    /* Handle HP Labels problem */
  if (setjmp(j__buf[j__lev++])==0) goto Lab_45050;
  lleng_int = LEN(line_S);
  togfl_int = 0;
  if(lleng_int <= 2)
  {
   goto Lab_45010;
  }
  strcpy(b_S,LEFT_S(line_S, 18));
  if(strcmp(b_S, "/*- User SUBs--End") == 0)
  {
   tmpfl_int = 1;
   goto Lab_45010;
  }
  if(strcmp(b_S, "/*- User SUB--Star") == 0)
  {
   isub_int = isub_int + 1;
   fprintf(fp_3,"%s\n",line_S);
   fgets(line_S, LMAX, fp_2);
   line_S[strlen(line_S) - 1] = '\0';
   fprintf(fp_3,"%s\n",line_S);
   goto Lab_45015;
  }
  if(funcfl_int[isub_int] == 1)
  {
   goto Lab_45010;
  }
  if(isub_int > 0)
  {
   /*     Processing will pass here only for all non-empty lines within a SUB */
        if (cflag_int==1 && line_S[0] == 'C') {
         if(line_S[1]==' ' || line_S[1]=='\0' || line_S[1]=='\t') goto Lab_45010;
        }
   if(nsubvar_int[isub_int] > 0)
   {
    for(i_int = 1; i_int <= nsubvar_int[isub_int]; i_int++)
    {
     strcpy(z_S,subvar_S[isub_int][i_int]);
     vartyp(z_S, &typ_int);
     if(typ_int == 5 || typ_int == 15)
     {
      goto Lab_45005;
     }
     j_int = 0;
     lz_int = LEN(z_S);
     togfl_int = 0;
     flag_int = 0;
     leng_int = LEN(line_S);
     g_int = 0;
Lab_45001:
     flag_int = 0;
     while((! flag_int) && j_int <= leng_int)
     {
           if (line_S[j_int] == '"') togfl_int = 1 - togfl_int;
           if (!togfl_int) {
            if (memcmp(&line_S[j_int], "/* ", 3) == 0) flag_int=1;
            if (memcmp(&line_S[j_int], z_S, lz_int) == 0) flag_int = 2;
           }
      j_int = j_int + 1;
     }
     if(flag_int == 1)
     {
      goto Lab_45005;
     }
     if(flag_int == 2)
     {
           c = line_S[j_int + lz_int - 1];
           if (c==' ' || c==',' || c==')' || c==';' || c==']') {
      if(j_int > 1)
      {
       g_int = ASC(MID_S(line_S, j_int - 1, 1));
      }
      if(j_int == 1 || ! (g_int > 96 && g_int < 123 || g_int > 64 && g_int < 91))
      {
       sprintf(line_S,"%s%s%s",LEFT_S(line_S, j_int - 1),"*",MID_S(line_S, j_int, LMAX));
       leng_int = 1 + leng_int;
       j_int = j_int + lz_int;
      }
           }
     }
     j_int = j_int + 1;
     if(j_int < leng_int)
     {
      goto Lab_45001;
     }
Lab_45005:
    ;}
   }
  }
Lab_45010:
  fprintf(fp_3,"%s\n",line_S);
Lab_45011:
  if(nl_int == initline_int)
  {
   if(commff_int == 1)
   {
    fprintf(fp_3,"%s\n"," n_arg_int--;");
   }
   if(inkeyff_int == 1 && tflg_int == 0)
   {
    fprintf(fp_3,"%s\n"," keybd__init();");
   }
  }
Lab_45015:
 ;}
 fclose(fp_3);
 fclose(fp_2);
 sprintf(tws__S,"%s%s%s%s","mv -f ",tmpfile_S," ",outf_S);
 system(tws__S);
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_45050:   /* Handle HP Labeling style */
 if(lbfl_int)
 {
  strcpy(t_S,line_S);
  gulix(t_S);
       if (t_S[0] == '}')
       {
        k_int=0; while(line_S[k_int] != '}') k_int++;
        strncpy(t_S,line_S,k_int); t_S[k_int]='\0'; strcat(t_S,";"); strcat(t_S,&line_S[k_int]);
  strcpy(line_S,t_S);
  lbfl_int = 0;
       }
 }
      if (memcmp(line_S, "Lab_", 4) == 0)
      {
 lbfl_int = 1;
      } else {
 lbfl_int = 0;
      }
Lab_45051:
 /* RETURN */
 longjmp(j__buf[--j__lev],1);


Lab_50000:   /* COMMAND$ line tokenization and options handling */
 /* -i or -int => implicit integers i*,j*,k*,l*,m*,n* or upper case */
 /* -d or -double => all floats -> double */
 /* -c64 or -C64 => C-64 specific syntax, switches on -b flag also */
 /* -p or -post => do not perform postprocessing varnames */
 /* -l or -long => all integers (except short)-> long */
 /* -b or -bcpp => insensitive to case & spacing in QBASIC text */
 /* -a or -ansi => OBSOLETE and NOT USED */
 /* -c or -C    => allows C text lines commented with 'C ' */
 /* -m or -M    => disallow logical expr. in math. expression */
 /* -w          => AND, OR operate bitwise */
 /* -t or -T    => INKEY_S is dead (<termios.h> etc. not specified) */
 /* -I          => INKEY_S is of sample type (no internal loop) */
 /* -n or -N    => To supress SHELL command interpreter: all cmds literal */
 /* -u          => Do not update SCREEN after every LINE, PSET, etc. */
 /* -s          => Strip type sufixes from variable and function names */
 /* -D          => implicit doubles d*, D* */
 /* -r          => integer fractions became double: '/' -> '/ (double)' */
 /* -v          => print version and exit */
 /* -g          => print debug messages (expert) */
 /* -A          => convert array arguments to integer as in true BASIC */
 /* -L          => set LMAX other than default (1024), must be 1-32767 */
 /* -P          => treat PRINT as print to the current graphics screen */
 /* -col        => default color is foreground (else the last set color) */
 /* -B          => maximum compliance with BASIC: -A -r -b -P -I -col */
 /* -Ox         => optimization option(s) passed to the C compiler */
 intflg_int = 0;
 c64flg_int = 0;
 postflg_int = 1;
 longflg_int = 0;
 cflag_int = 0;
 Dflg_int = 0;
 doblflg_int = 0;
 bcppflg_int = 0;
 ansiflg_int = 0;
 mflg_int = 1;
 rflag_int=0;
 tflg_int = 0;   /* default flags */
 noshell_int = 0;
 updateff_int = 1;
 stripff_int = 0;
 debug_int = 0;
 Arrfl_int = 0;
 Lmax_int = 1025;
 prnfl_int = 0;
 Iflag_int = 0;
 bwfl_int = 0;
 colorfl_int = 0;
 strcpy(optim_S,"");
 for(i_int = 1; i_int <= n_arg_int; i_int++)
 {
  strcpy(d_S,argv_S[i_int]);
  if(strcmp(d_S, "-v") == 0 || strcmp(d_S, "-V") == 0)
  {
   fprintf(stderr,"%s%s\n","Version: ",Version_S);
   exit(0);
  }
  if(strcmp(d_S, "-h") == 0 || strcmp(d_S, "-?") == 0)
  {
   helpm();
   exit(0);
  }
  if(strcmp(d_S, "-i") == 0 || strcmp(d_S, "-int") == 0)
  {
   intflg_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-C64") == 0 || strcmp(d_S, "-c64") == 0)
  {
   c64flg_int = 1;
   bcppflg_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-p") == 0 || strcmp(d_S, "-post") == 0)
  {
   postflg_int = 0;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-l") == 0 || strcmp(d_S, "-long") == 0)
  {
   longflg_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-d") == 0 || strcmp(d_S, "-double") == 0)
  {
   doblflg_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-b") == 0 || strcmp(d_S, "-bcpp") == 0)
  {
   bcppflg_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-a") == 0 || strcmp(d_S, "-ansi") == 0)
  {
   ansiflg_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-c") == 0 || strcmp(d_S, "-C") == 0)
  {
   cflag_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-m") == 0 || strcmp(d_S, "-M") == 0)
  {
   mflg_int = 0;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-w") == 0)
  {
   bwfl_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-t") == 0 || strcmp(d_S, "-T") == 0)
  {
   tflg_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-I") == 0)
  {
   Iflag_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-n") == 0 || strcmp(d_S, "-N") == 0)
  {
   noshell_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-u") == 0)
  {
   updateff_int = 0;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-s") == 0)
  {
   stripff_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-D") == 0)
  {
   Dflg_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-r") == 0)
  {
   rflag_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-g") == 0)
  {
   debug_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-A") == 0)
  {
   Arrfl_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-L") == 0)
  {
   i_int = i_int + 1;
   Lmax_int = 1 + VAL(argv_S[i_int]);
   goto Lab_50005;
  }
  if(strcmp(d_S, "-P") == 0)
  {
   prnfl_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-col") == 0)
  {
   colorfl_int = 1;
   goto Lab_50005;
  }
  if(strcmp(d_S, "-B") == 0)
  {
   Arrfl_int = 1;
   bcppflg_int = 1;
   rflag_int = 1;
   prnfl_int = 1;
   Iflag_int = 1;
   colorfl_int = 1;
   bwfl_int = 1;
   goto Lab_50005;
  }
  if(strcmp(LEFT_S(d_S, 2), "-O") == 0)
  {
   strcpy(optim_S,d_S);
   goto Lab_50005;
  }
  if(strcmp(LEFT_S(d_S, 1), "-") == 0)
  {
   fprintf(stderr,"%s%s\n","qb2c: Unrecognized option, ignored: ",d_S);
   fprintf(stderr,"%s\n","type 'qb2c -h' to see the list of options");
   goto Lab_50005;
  }
  strcpy(inpf_S,argv_S[i_int]);
Lab_50005:
 ;}
 if(n_arg_int == 0)
 {
  fprintf(stderr,"QuasiBASIC to C translator (QB2C), version: 3.41 04 May 2000\n");
  fprintf(stderr,"By Mario Stipcevic, Zagreb, Croatia (C)1997-\n");
  fprintf(stderr,"%s\n","Usage: qb2c [-option [...]] input_file[.bas] [output_file]");
  signal_int = 1;   /* exit(1); */
  goto Lab_9999;
 }
 else
 {
  strcpy(b_S,inpf_S);
  if(LEN(inpf_S) > 4)
  {
   strcpy(d_S,RIGHT_S(inpf_S, 4));
   if(strcmp(d_S, ".bas") == 0 || strcmp(d_S, ".BAS") == 0)
   {
    sprintf(outf_S,"%s%s",LEFT_S(inpf_S, LEN(inpf_S) - 4),".c");
   }
   else
   {
    sprintf(outf_S,"%s%s",inpf_S,".c");
    sprintf(inpf_S,"%s%s",b_S,".bas");
   }
  }
  else
  {
   sprintf(outf_S,"%s%s",b_S,".c");
   sprintf(inpf_S,"%s%s",b_S,".bas");
   /*      IF NOT EXISTS(inpf$) THEN inpf$ = b$ + ".BAS" */
   /*      IF NOT EXISTS(inpf$) THEN */
   /*       EPRINT "Can not open files " + b$ + ".bas nor " + b$ + ".BAS": END */
   /*      END IF */
  }
 }
 strcpy(ime_S,inpf_S);
 if(! EXISTS(ime_S))
 {
  fprintf(stderr,"%s%s%s\n",argv_S[0],": can't open file ",ime_S);
  signal_int = 1;
  goto Lab_9999;
 }
 printf("%s%s%s%s\n","qb2c: translating  ",inpf_S,"  -->  ",outf_S);
 if(bcppflg_int == 1)
 {
  strcpy(z_S,"");
  if(c64flg_int == 1)
  {
   sprintf(tws__S,"%s%s",z_S," -C64");
   strcpy(z_S,tws__S);
  }
  if(cflag_int == 1)
  {
   sprintf(tws__S,"%s%s",z_S," -C");
   strcpy(z_S,tws__S);
  }
  if(rflag_int == 1)
  {
   sprintf(tws__S,"%s%s",z_S," -r");
   strcpy(z_S,tws__S);
  }
  sprintf(tws__S,"%s%s%s%s","bcpp",z_S," -q ",inpf_S);
  system(tws__S);
  sprintf(inpf_S,"%s%s",b_S,".bcp");
  strcpy(bcp_S,inpf_S);
 }
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_9999:   /* End Main */
 /* Cleanup */
 if(bcppflg_int == 1)
 {
  sprintf(tws__S,"%s%s","rm -f ",bcp_S);
  system(tws__S);
 }
 sprintf(tws__S,"%s%s%s%s","rm -f ",tmpfile_S," ",tmpfil0_S);
 system(tws__S);
 /*     IF optim$ <> "" THEN ENVIRON "BCC_OPTIONS" = optim$ */
     if (signal_int) exit(1);
 printf("%s% .7G %s\n","Translation done in",(double)(Nint(100 * (TIMER() - T0)) / 100.),"sec.");
 exit(0);

} /* End of MAIN */

/*- User SUB--Start -*/
int arraydim(char  *h_S)
{
/* SHARED: tmp$() */

  int  i_int, ntok_int, itok_int;
  char b_S[LMAX], d_S[LMAX], e_S[LMAX];
  long j_long;

  char c;
 /*  Translates array dimensions from QB to C standard (partly, see 800) */
 /*  h$ mora biti 'oguljen' (gulix) */
 /*  Misfeature: |100 -> |100+1 instead of |101 */
 i_int = 1;
     while (h_S[i_int] != '(') i_int++;
 strcpy(b_S,MID_S(h_S, i_int + 2, LEN(h_S) - i_int - 2));
 tokenix(b_S, &ntok_int, ",", "");
 strcpy(d_S,"");
 for(itok_int = 1; itok_int <= ntok_int; itok_int++)
 {
  j_long = VAL(tmp_S[itok_int]);
      c = tmp_S[itok_int][0];
  if(j_long > 0 || c == '0')
  {
   strcpy(e_S,STR_S(j_long + 1));
   sprintf(tws__S,"%s%s%s",d_S,RIGHT_S(e_S, LEN(e_S) - 1),", ");
   strcpy(d_S,tws__S);
  }
  else
  {
   sprintf(tws__S,"%s%s%s",d_S,tmp_S[itok_int],"+1, ");
   strcpy(d_S,tws__S);
  }
 }
 sprintf(h_S,"%s%s%s",LEFT_S(h_S, i_int + 1),LEFT_S(d_S, LEN(d_S) - 2),")");
}


/*- User SUB--Start -*/
int brackets(char  *h_S)
{
/* SHARED: tmp$() */

  int  i_int, n_int, typ_int;
  char a_S[LMAX];

    char b, c;
 /* Converts array brackets from QB to C standard in DIM statement */
 /* Eg. a(10) -> a[10], b(10, 15) -> b[10][15], a$(10) -> a$[10][LMAX] */
 /* Assumes that the last char is ")" eg. xxxx(...) */
 i_int = 1;
    while (h_S[i_int] != '(') i_int++;
    b=h_S[i_int-1]; /* Unused: $ if string, but not for DEFSTR, check type */
 strcpy(a_S,MID_S(h_S, i_int + 2, LEN(h_S) - i_int - 2));
 tokenix(a_S, &n_int, ",", "");
 strcpy(h_S,LEFT_S(h_S, i_int));
 vartyp(h_S, &typ_int);
    c = 0;
 for(i_int = 1; i_int <= n_int; i_int++)
 {
     if(tmp_S[i_int][0]=='|')
     { c = 1; }
     else
     {
  sprintf(tws__S,"%s%s%s%s",h_S,"[",tmp_S[i_int],"]");
  strcpy(h_S,tws__S);
     }
 }
    if (typ_int==5)
    {
     if (!c)
     { strcat(h_S, "[LMAX]"); }
     else
     { strcat(h_S, "["); strcat(h_S, &tmp_S[n_int][1]); strcat(h_S, "]"); }
    }
}


/*- User SUB--Start -*/
int declarix(char  *typ_S, char  *varlist_S, int   *dn_int)
{
/* SHARED: tmp$(), isub%, ni%, spc$, statfl%() */

  int  ntok_int, i_int;
  char prtf_S[LMAX];

 /* Declares variables (+ splits long lines with splitdec) */
 /* Variable names ran through varpost() name postprocessor */
 splitdec(varlist_S, &ntok_int, &*dn_int);
 for(i_int = 1; i_int <= ntok_int; i_int++)
 {
  strcpy(prtf_S,tmp_S[i_int]);
  varpost(prtf_S);
  if(statfl_int[isub_int] == 1)
  {
   fprintf(fp_2,"%s%s%s%s%s\n",spc_S,"static",typ_S,prtf_S,";");
  }
  else
  {
   fprintf(fp_2,"%s%s%s%s\n",spc_S,typ_S,prtf_S,";");
  }
  if(isub_int == 0)
  {
   ni_int = ni_int + 1;
  }
 }
}


/*- User SUB--Start -*/
int gulix(char  *h_S)
{
  int  leng_int, i_int, j_int;

 /* Strip off leading and trailing spaces */
 leng_int = LEN(h_S);
 if(leng_int != 0)
 {
  i_int = 0;
   while((h_S[i_int]==' ' || h_S[i_int]=='\t') && i_int < leng_int) ++i_int;
  if(i_int == leng_int)
  {
   strcpy(h_S,"");
   goto Lab_99;
  }
  j_int = leng_int - 1;
   while(h_S[j_int] == ' ' && j_int > 0) --j_int;
   memmove(h_S,&h_S[i_int],(leng_int=j_int-i_int+1)); h_S[leng_int]='\0';
 }
Lab_99:
;}


/*- User SUB--Start -*/
int inputfmt(char  *list_S, char  *formt_S, char  *prt_S, int   *ntok_int, int   *flag_int)
{
/* SHARED: tmp$(), nl% */

  int  ltyp_int, typ_int, i_int;
  char b_S[LMAX], z_S[LMAX];

 /* Solves argument lists in "INPUT #", "INPUT" and "SSCAN" input statements */
 /* 'list$' is the input list and is not changed. */
 /* 'formt$' is format string and 'prt$' is complete argument list */
 /* to sscanf at the output. */
 /* ntok% is number of found tokens, set to -1 if input is a single string */
 /* Input flag% defines typ of delimiter in the output: 0=" ", 1=" ,", 2="\t" */
 strcpy(formt_S,"");
 strcpy(prt_S,"");
 ltyp_int = 0;
 tokenix(list_S, &*ntok_int, ",", ";");
 if(*ntok_int == 1)
 {
  strcpy(b_S,tmp_S[1]);
  vartyp(b_S, &typ_int);
  if(typ_int == 5 || typ_int == 15)
  {
   strcpy(prt_S,list_S);
   *ntok_int = -1;
   goto Lab_315;
  }
 }
 for(i_int = 1; i_int <= *ntok_int; i_int++)
 {
  strcpy(b_S,tmp_S[i_int]);
  vartyp(b_S, &typ_int);
  if(typ_int == 0)
  {
   printf("%s%s%s% d \n","qb2c: inputfmt: Error in input format of ",b_S,"in line No",nl_int);
  }
  if(typ_int > 10)
  {
   typ_int = typ_int - 10;
  }
  if(typ_int <= 2 || typ_int == 8)
  {
   strcpy(z_S,"%d");
  }
  else
  {
   if(typ_int == 3)
   {
    strcpy(z_S,"%f");
   }
   else
   {
    if(typ_int == 4)
    {
     strcpy(z_S,"%le");
    }
    else
    {
     if(typ_int == 5)
     {
      strcpy(z_S,"%s");
     }
     else
     {
      fprintf(stderr,"%s%s%s% d \n","qb2c: inputfmt: ERROR in input format of `",b_S,"' in line No",nl_int);
     }
    }
   }
  }
  if(*flag_int == 0)
  {
   sprintf(tws__S,"%s%s%s",formt_S,"  ",z_S);
   strcpy(formt_S,tws__S);
  }
  if(*flag_int == 1)
  {
   sprintf(tws__S,"%s%s%s",formt_S," ,",z_S);
   strcpy(formt_S,tws__S);
  }
  if(*flag_int == 2)
  {
   sprintf(tws__S,"%s%s%s",formt_S,"\\t",z_S);
   strcpy(formt_S,tws__S);
  }
  if(typ_int != 5)
  {
   sprintf(tws__S,"%s%s%s",prt_S,",&",b_S);
   strcpy(prt_S,tws__S);
  }
  else
  {
   sprintf(tws__S,"%s%s%s",prt_S,",",b_S);
   strcpy(prt_S,tws__S);
  }
  ltyp_int = typ_int;
 }
 strcpy(formt_S,MID_S(formt_S, 3, LMAX));
Lab_315:
;}


/*- User SUB--Start -*/
int logix(char  *h_S)
{
/* SHARED: bwfl% */

  int  leng_int, i_int, j_int;
  char z_S[LMAX];

 /* Handles logical expressions */
  char c, k, flagc, flagk, a3_S[4];
 leng_int = LEN(h_S);
 i_int = 1;
 while(i_int <= leng_int)
 {
  strncpy(a3_S, &h_S[i_int-1], 3); a3_S[3]='\0';
  if (a3_S[0] == '=') {
  if(strcmp(MID_S(h_S, i_int - 1, 1), " ") != 0)
  {
   goto Lab_115;
  }
  sparser(h_S, &i_int, "=");   /* String logical expression handler */
  leng_int = LEN(h_S);
  goto Lab_115;
  }
  if (memcmp(a3_S, "<>", 2) == 0) {
  sparser(h_S, &i_int, "<>");   /* String logical expression handler */
  leng_int = LEN(h_S);
  goto Lab_115;
  }
  c = ' '; if (i_int > 1) c = tolower(h_S[i_int-2]);
  if (c<'a' || c>'z') { flagc = 1; } else { flagc = 0; }
  k = ' '; if (i_int+1 < leng_int) k = tolower(h_S[i_int+1]);
  if (k<'a' || k>'z') { flagk = 1; } else { flagk = 0; }
  if ( memcmp(a3_S, "OR", 2) == 0 && flagc && flagk) {
  if(bwfl_int)
  {
   sprintf(h_S,"%s%s%s",MID_S(h_S, 1, i_int - 1),"|",MID_S(h_S, i_int + 2, leng_int - i_int - 1));
  }
  else
  {
   sprintf(h_S,"%s%s%s",MID_S(h_S, 1, i_int - 1),"||",MID_S(h_S, i_int + 2, leng_int - i_int - 1));
   i_int = i_int + 1;
  }
  leng_int = LEN(h_S);
  goto Lab_115;
  }
  k = ' '; if (i_int+2 < leng_int) k = tolower(h_S[i_int+2]);
  if (k<'a' || k>'z') { flagk = 1; } else { flagk = 0; }
  if ( memcmp(a3_S, "AND", 3) == 0 && flagc && flagk) {
  if(bwfl_int)
  {
   sprintf(h_S,"%s%s%s",MID_S(h_S, 1, i_int - 1),"&",MID_S(h_S, i_int + 3, leng_int - i_int - 1));
  }
  else
  {
   sprintf(h_S,"%s%s%s",MID_S(h_S, 1, i_int - 1),"&&",MID_S(h_S, i_int + 3, leng_int - i_int - 1));
   i_int = i_int + 1;
  }
  leng_int = leng_int - 1;
  i_int = i_int + 1;
  goto Lab_115;
  }
  if ( memcmp(a3_S, "NOT", 3) == 0 && flagc && flagk) {
  sprintf(h_S,"%s%s%s",MID_S(h_S, 1, i_int - 1),"!",MID_S(h_S, i_int + 3, leng_int - i_int - 1));
  leng_int = leng_int - 2;
  goto Lab_115;
  }
  if ( memcmp(a3_S, "EOF", 3) == 0 && flagc && flagk) {
  j_int = i_int + 4;
  while(strcmp(MID_S(h_S, j_int, 1), ")") != 0 && j_int < leng_int)
  {
   j_int = j_int + 1;
  }
  strcpy(z_S,MID_S(h_S, i_int + 4, j_int - i_int - 4));
  gulix(z_S);
  sprintf(h_S,"%s%s%s%s",MID_S(h_S, 1, i_int - 1),"eof(fp_",z_S,MID_S(h_S, j_int, leng_int - j_int + 1));
  leng_int = LEN(h_S);
  goto Lab_115;
  }
  if ( memcmp(a3_S, " @ ", 3) == 0 || memcmp(a3_S, "XOR", 3) == 0) {
   h_S[i_int] = '^';
  goto Lab_115;
  }
Lab_115:
  i_int = i_int + 1;
 }
}


/*- User SUB--Start -*/
int mathexp(char  *h_S)
{
/* SHARED: mathfl%, mflg%, expflg%, extrnfl% */

  int  leng_int, i_int, togfl_int;
  char b_S[LMAX];

    char d, pd='\0';
 /* Translates mathematical and logical expressions, including math. functions: */
 /* ^ -> pow(,), MOD */

 sprintf(tws__S,"%s%s"," ",h_S);
 strcpy(h_S,tws__S);
 leng_int = LEN(h_S);
 i_int = 1;
 togfl_int = 0;
 while(i_int <= leng_int)
 {
     d = h_S[i_int-1];
     if (i_int>=2) pd = h_S[i_int-2];
     if (d == 34) togfl_int = 1 - togfl_int;
  if(togfl_int == 1)
  {
   goto Lab_114;
  }
     if (pd) { if (d == '!' && pd >= '0' && pd <= '9') h_S[i_int-1] = '.'; }
  if(i_int > leng_int - 2)
  {
   goto Lab_114;
  }
     if (h_S[i_int-1] == '^')
     {
  sparser(h_S, &i_int, "^");   /* Finds left and right operands in binary ops. */
  leng_int = LEN(h_S);   /* Caution both h$ and i% are changed */
  mathfl_int = 1;
  goto Lab_114;
     }
     if (memcmp(&h_S[i_int-1], " MOD ", 5)==0) {
  i_int = 1 + i_int;
  sparser(h_S, &i_int, "MOD");
  goto Lab_114;
     }
Lab_114:
  i_int = i_int + 1;
 }
 strcpy(h_S,MID_S(h_S, 2, LMAX));
 if(mflg_int == 1 && expflg_int == 1)
 {
  i_int = 1;
  leng_int = LEN(h_S);
     while (h_S[i_int-1] != '=' && i_int != leng_int) i_int++;
  if(i_int == leng_int)
  {
   logix(h_S);
  }
  else
  {
   strcpy(b_S,MID_S(h_S, i_int + 2, LMAX));
   logix(b_S);
   sprintf(h_S,"%s%s",LEFT_S(h_S, i_int + 1),b_S);
  }
 }
}



/*- User SUB--Start -*/
int printfmt(char  *in_S, char  *formt_S, char  *prt_S, int   *nflag_int)
{
/* SHARED: tmp$(), isub%, vdblff%, nptk%, extrnfl%, defstr% */

  int  zarfl_int, tzarfl_int, leng_int, togfl_int, brfl_int, i_int, j_int, typ_int, g_int;
  char h_S[LMAX], d_S[LMAX], z_S[LMAX];

 /* Solves argument lists in "PRINT #" and "PRINT" output statements */
 /* From 4.04 logical expressions are allowed */
 /* 'in$' is the input expression and is not changed. */
 /* 'formt$' is format string and 'prt$' is complete argument list */
 /* to sprintf or printf at the output. nflag% is set if newline required. */
  char b;
 /* tokenizacija list varijabli itd. => formt$ */
 *nflag_int = 1;
 strcpy(prt_S,"");
 zarfl_int = 0;
 tzarfl_int = 0;
 strcpy(h_S,in_S);
 if(strcmp(RIGHT_S(h_S, 1), ";") == 0)
 {
  *nflag_int = 0;
 }
 if(*nflag_int == 1)
 {
  sprintf(tws__S,"%s%s",h_S,";");
  strcpy(h_S,tws__S);
 }
 leng_int = LEN(h_S);
 togfl_int = 0;
 brfl_int = 0;
 i_int = 1;
 j_int = 1;
 strcpy(formt_S,"");
 while(j_int <= leng_int)
 {
        b = h_S[j_int - 1];
        if (b == 34) togfl_int = 1 - togfl_int;
  if(togfl_int == 0)
  {
         if (b == '(') brfl_int++;
         if (b == ')') brfl_int--;
  }
        if (!togfl_int && !brfl_int && (b == ';' || b == ',')) {
         zarfl_int = 0; if (b == ',') zarfl_int = 1;
         tzarfl_int = 0; if (b == ';') tzarfl_int = 1;
  strcpy(d_S,MID_S(h_S, i_int, j_int - i_int));
  gulix(d_S);
  vartyp(d_S, &typ_int);
  if(typ_int != 5 && typ_int != 7 && typ_int != 15)   /* Novo, umjesto dolje */
  {
   mathexp(d_S);
   logix(d_S);
  }
  if(typ_int == 1 || typ_int == 2 || typ_int == 8 || typ_int == 10 || typ_int == 11 || typ_int == 12 || typ_int == 18)
  {
   strcpy(z_S,"% d");
   if(zarfl_int == 1)
   {
    strcpy(z_S," %-14d");
   }
   if(tzarfl_int == 1)
   {
    strcpy(z_S,"% d ");
   }
   sprintf(tws__S,"%s%s",formt_S,z_S);
   strcpy(formt_S,tws__S);
   goto Lab_195;
  }
  if(typ_int != 5 && typ_int != 7 && typ_int != 15)
  {
   if(zarfl_int == 1)
   {
    strcpy(z_S," %-14G");
   }
   else
   {
    if(typ_int == 14)
    {
     strcpy(z_S,"% .16G");
     if(tzarfl_int == 1)
     {
      strcpy(z_S,"% .16G ");
     }
    }
    else
    {
     strcpy(z_S,"% .7G");
     if(tzarfl_int == 1)
     {
      strcpy(z_S,"% .7G ");
     }
    }
   }
   sprintf(tws__S,"%s%s",formt_S,z_S);
   strcpy(formt_S,tws__S);
   if(typ_int == 6 || 11 <= typ_int && typ_int <= 14)
   {
    /*        CALL mathexp(d$): REM Novo, sada je gore */
    if(typ_int <= 12)
    {
     /*         d$ = "DBL(" + d$ + ")" */
     /*         vdblff% = 1: extrnfl% = 1 */
     sprintf(tws__S,"%s%s%s","(double)(",d_S,")");
     strcpy(d_S,tws__S);
    }
   }
   else
   {
    if(typ_int == 20)
    {
     /*         d$ = "DBL(" + d$ + ")" */
     /*         vdblff% = 1: extrnfl% = 1 */
     sprintf(tws__S,"%s%s%s","(double)(",d_S,")");
     strcpy(d_S,tws__S);
    }
   }
  }
  else
  {
   strcpy(z_S,"%s");
   if(zarfl_int == 1)
   {
    strcpy(z_S,"%-14s");
   }
   if(typ_int == 7)
   {
    tokenix(d_S, &nptk_int, "+", "");
    strcpy(d_S,"");
    for(g_int = 1; g_int <= nptk_int; g_int++)
    {
     if(isub_int == 0)
     {
      if(strcmp(tmp_S[g_int], "COMMAND$") == 0)
      {
       strcpy(tmp_S[g_int],"COMMAND$(n_arg_int, argv_S)");
      }
     }
     sprintf(tws__S,"%s%s%s",d_S,tmp_S[g_int],",");
     strcpy(d_S,tws__S);
     sprintf(tws__S,"%s%s",formt_S,"%s");
     strcpy(formt_S,tws__S);
    }
    strcpy(d_S,LEFT_S(d_S, LEN(d_S) - 1));
   }
   else
   {
    if(isub_int == 0)
    {
     if(strcmp(d_S, "COMMAND$") == 0)
     {
      strcpy(d_S,"COMMAND$(n_arg_int, argv_S)");
     }
    }
    sprintf(tws__S,"%s%s",formt_S,z_S);
    strcpy(formt_S,tws__S);
   }
  }
Lab_195:
  sprintf(tws__S,"%s%s%s",prt_S,",",d_S);
  strcpy(prt_S,tws__S);
  i_int = j_int + 1;
        }
  j_int = j_int + 1;
 }
}



/*- User SUB--Start -*/
int qbfdecl()
{
/* SHARED: spacff%, midff%, leftff%, rightff%, strff% */
/* SHARED: chrff%, ascff%, valff%, lenff%, sgnff% */
/* SHARED: intff%, nintff%, eofff%, commff%, vdblff% */
/* SHARED: rndff%, srndff%, timerff%, dateff%, timeff% */
/* SHARED: inkeyff%, inputff%, colorff%, clsff%, lcaseff% */
/* SHARED: ucaseff%, envff%, lofff%, hexff%, octff% */
/* SHARED: SScan%, stringf%, datalin%, txlen%, usingff% */


 if(spacff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *SPACE_S(int);");
 }
 if(midff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *MID_S(char *, int, int);");
 }
 if(leftff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *LEFT_S(char *, int);");
 }
 if(rightff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *RIGHT_S(char *, int);");
 }
 if(lcaseff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *LCASE_S(char *);");
 }
 if(ucaseff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *UCASE_S(char *);");
 }
 if(envff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *ENVIRON_S(char *);");
 }
 if(strff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *STR_S(double);");
 }
 if(chrff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *CHR_S(int);");
 }
 if(ascff_int)
 {
  fprintf(fp_2,"%s\n","extern long   ASC(char *);");
 }
 if(valff_int)
 {
  fprintf(fp_2,"%s\n","extern double VAL(char *);");
 }
 if(lenff_int)
 {
  fprintf(fp_2,"%s\n","extern int    LEN(char *);");
 }
 if(txlen_int)
 {
  fprintf(fp_2,"%s\n","extern int    XLEN(char *);");
 }
 if(sgnff_int)
 {
  fprintf(fp_2,"%s\n","extern double SGN(double);");
 }
 if(intff_int)
 {
  fprintf(fp_2,"%s\n","extern long   Int(double);");
 }
 if(nintff_int)
 {
  fprintf(fp_2,"%s\n","extern long   Nint(double);");
 }
 if(eofff_int)
 {
  fprintf(fp_2,"%s\n","extern int    eof(FILE *);");
 }
 if(commff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *COMMAND_S(int, char *argv_S[]);");
 }
 if(rndff_int)
 {
  fprintf(fp_2,"%s\n","extern double  RND(double);");
 }
 if(srndff_int)
 {
  fprintf(fp_2,"%s\n","extern void    RANDOMIZE(long);");
 }
 if(timerff_int)
 {
  fprintf(fp_2,"%s\n","extern double  TIMER(void);");
 }
 if(vdblff_int)
 {
  fprintf(fp_2,"%s\n","extern double DBL(double);");
 }
 if(dateff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *DATE_S(int);");
 }
 if(timeff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *TIME_S(int);");
 }
 if(inkeyff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *INKEY_S(void);");
 }
 if(inputff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *INPUT(const char*, int);");
 }
 if(colorff_int)
 {
  fprintf(fp_2,"%s\n","extern int    COLOR(int fg, int bg);");
 }
 if(clsff_int)
 {
  fprintf(fp_2,"%s\n","extern int    CLS(int n_int);");
 }
 if(lofff_int)
 {
  fprintf(fp_2,"%s\n","extern long   LOF(char *);");
 }
 if(hexff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *HEX_S(unsigned long);");
 }
 if(octff_int)
 {
  fprintf(fp_2,"%s\n","extern char  *OCT_S(unsigned long);");
 }
 if(SScan_int)
 {
  fprintf(fp_2,"%s\n","extern int   SScan(char *);");
 }
 if(stringf_int)
 {
  fprintf(fp_2,"%s\n","extern char *STRING_S(int, int);");
 }
 if(datalin_int)
 {
  fprintf(fp_2,"%s\n","extern char *READ__S(int);");
 }
 if(usingff_int)
 {
  fprintf(fp_2,"%s\n","extern char *print__using(char *, char *);");
 }
}


/*- User SUB--Start -*/
int qbfunc()
{
/* SHARED: spacff%, midff%, leftff%, rightff%, strff% */
/* SHARED: chrff%, ascff%, valff%, lenff%, sgnff% */
/* SHARED: intff%, nintff%, eofff%, commff%, vdblff% */
/* SHARED: rndff%, srndff%, timerff%, dateff%, timeff% */
/* SHARED: inkeyff%, inputff%, tflg%, colorff%, clsff% */
/* SHARED: existff%, lcaseff%, ucaseff%, envff%, lofff% */
/* SHARED: hexff%, octff%, SScan%, stringf%, datalin% */
/* SHARED: txlen%, usingff%, Iflag% */

  char d_S[LMAX];


 strcpy(d_S,CHR_S(34));   /* Quotes */
 if(spacff_int == 1)
 {
  /*  Calls: SPACE_S(j), SPACE_S(2) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *SPACE_S(int n)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int i;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s\n"," if (n < 0) n = 0;");
  fprintf(fp_2,"%s%s%s%s\n"," strcpy(w__S[j__S],",CHR_S(34),CHR_S(34),");");
  fprintf(fp_2,"%s\n"," for(i = 1; i <= n; i++)");
  fprintf(fp_2,"%s\n"," {");
  fprintf(fp_2,"%s%s%s%s%s\n","  strcat(w__S[j__S],",d_S," ",d_S,");");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(midff_int == 1)
 {
  /*  Calls: eg. MID_S(a_S,2,j) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *MID_S(char *a_S, int start, int length)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s\n"," if(length < 0) { ");
  fprintf(fp_2,"%s%s%s%s%s\n","  printf(",CHR_S(34),"Error: in MID_S: length < 0\\n",CHR_S(34),");");
  fprintf(fp_2,"%s\n","  exit(0); }");
  fprintf(fp_2,"%s\n"," if(start  < 0) {");
  fprintf(fp_2,"%s%s%s%s%s\n","  printf(",CHR_S(34),"Error: in MID_S: start < 1\\n",CHR_S(34),");");
  fprintf(fp_2,"%s\n","  exit(0); }");
  fprintf(fp_2,"%s\n"," if(start > strlen(a_S)) ");
  fprintf(fp_2,"%s\n"," { w__S[j__S][0]='\\0'; }");
  fprintf(fp_2,"%s\n"," else");
  fprintf(fp_2,"%s\n"," { strncpy(w__S[j__S], &a_S[start-1], length);");
  fprintf(fp_2,"%s\n","   w__S[j__S][length]='\\0'; }");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(leftff_int == 1)
 {
  /* Calls:  LEFT_S(a_S,j), LEFT_S(a_S,3) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *LEFT_S(char *a_S, int length)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s\n"," if(length < 0) { ");
  fprintf(fp_2,"%s%s%s%s%s\n","  printf(",CHR_S(34),"Error: in LEFT_S: length < 0\\n",CHR_S(34),");");
  fprintf(fp_2,"%s\n","  exit(0); }");
  fprintf(fp_2,"%s\n"," strncpy(w__S[j__S], a_S, length);");
  fprintf(fp_2,"%s\n"," w__S[j__S][length]='\\0';");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(rightff_int == 1)
 {
  /* Calls:  RIGHT_S(a_S,j), RIGHT_S(a_S,3) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *RIGHT_S(char *a_S, int length)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int  start;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s\n"," if ((start = strlen(a_S) - length) < 0) start = 0;");
  fprintf(fp_2,"%s\n"," if (length < 0) {");
  fprintf(fp_2,"%s%s%s%s%s\n","  printf(",CHR_S(34),"Error: in RIGHT_S: length < 0\\n",CHR_S(34),");");
  fprintf(fp_2,"%s\n","  exit(0); }");
  fprintf(fp_2,"%s\n"," strncpy(w__S[j__S], &a_S[start], length);");
  fprintf(fp_2,"%s\n"," w__S[j__S][length]='\\0';");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(strff_int == 1)
 {
  /* Calls: STR_S(j), STR_S(123.5) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *STR_S(double d)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s%s%s%s%s\n"," sprintf(w__S[j__S],",d_S,"% G",d_S,",d);");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(chrff_int == 1)
 {
  /* Calls: CHR_S(j), CHR_S(65) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *CHR_S(int i)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s\n"," w__S[j__S][0]=i;");
  fprintf(fp_2,"%s\n"," w__S[j__S][1]='\\0';");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(ascff_int == 1)
 {
  /* Calls: i=ASC(a_S), i=ASC("ABCD") */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern long ASC(char *c_S)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," if (++i__l == 16) i__l=0;");
  fprintf(fp_2,"%s\n"," if((w__l[i__l]=c_S[0]) < 0) w__l[i__l]=256+w__l[i__l];");
  fprintf(fp_2,"%s\n"," return w__l[i__l];");
  fprintf(fp_2,"%s\n","}");
 }
 if(valff_int == 1)
 {
  /*  Calls: VAL(a_S), VAL("1234.5abcd") */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern double VAL(char *a_S)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," if (++i__d == 16) i__d = 0;");
  fprintf(fp_2,"%s\n"," w__d[i__d] = atof(a_S);");
  fprintf(fp_2,"%s\n"," return w__d[i__d];");
  fprintf(fp_2,"%s\n","}");
 }
 if(lenff_int == 1)
 {
  /*  Calls: LEN(a_S), LEN("1234.5abcd") */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern int LEN(char *a_S)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," if (++i__d == 16) i__d = 0;");
  fprintf(fp_2,"%s\n"," w__d[i__d] = strlen(a_S);");
  fprintf(fp_2,"%s\n"," return w__d[i__d];");
  fprintf(fp_2,"%s\n","}");
 }
 if(txlen_int == 1)
 {
  /*  Calls: XLEN(a_S), XLEN("1234.5abcd") */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern int XLEN(char *a_S)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int length, height;");
  fprintf(fp_2,"%s\n","  ixtxtl( &length, &height, a_S );");
  fprintf(fp_2,"%s\n"," return length;");
  fprintf(fp_2,"%s\n","}");
 }
 if(sgnff_int == 1)
 {
  /*  Calls: SGN(x), SGN(-123.4) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern double SGN(double x)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," if (++i__d == 16) i__d = 0;");
  fprintf(fp_2,"%s\n"," if(x == (double) 0) {");
  fprintf(fp_2,"%s\n","  w__d[i__d] = 0.; }");
  fprintf(fp_2,"%s\n"," else {");
  fprintf(fp_2,"%s\n","  w__d[i__d] = x / fabs(x); }");
  fprintf(fp_2,"%s\n"," return w__d[i__d];");
  fprintf(fp_2,"%s\n","}");
 }
 if(intff_int == 1)
 {
  /*  Calls: Int(x), Int(-123.4) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern long Int(double x)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," return floor(x);");
  fprintf(fp_2,"%s\n","}");
 }
 if(nintff_int == 1)
 {
  /*  Calls: Nint(x), Nint(-123.4) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern long Nint(double x)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," return floor(0.5 + x); ");
  fprintf(fp_2,"%s\n","}");
 }
 if(eofff_int == 1)
 {
  /*  Calls:  while ( ! eof(fp_n) ) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern int eof(FILE *stream)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," static int c, istat;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," istat=((c=fgetc(stream))==EOF);");
  fprintf(fp_2,"%s\n"," ungetc(c,stream);");
  fprintf(fp_2,"%s\n"," return istat; ");
  fprintf(fp_2,"%s\n","}");
 }
 if(commff_int == 1)
 {
  /*  Calls:  COMMAND_S(n_arg_int, argv_S); */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *COMMAND_S(int n_arg_int, char *argv_S[])");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int i;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s\n"," for(i = 1; i <= n_arg_int; i++)");
  fprintf(fp_2,"%s\n"," {");
  fprintf(fp_2,"%s\n","  strcat(w__S[j__S],argv_S[i]);");
  fprintf(fp_2,"%s%s%s%s%s\n","  strcat(w__S[j__S],",d_S," ",d_S,");");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n"," w__S[j__S][strlen(w__S[j__S])-1]='\\0';");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(vdblff_int == 1)
 {
  /*  Calls: DBL(num_expression) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern double DBL(double d)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," if (++i__d == 16) i__d = 0;");
  fprintf(fp_2,"%s\n"," w__d[i__d] = d;");
  fprintf(fp_2,"%s\n"," return w__d[i__d];");
  fprintf(fp_2,"%s\n","}");
 }
 if(rndff_int == 1)
 {
  /*  Calls: RND(num_expression) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern double RND(double d)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," static double y;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," if(d == 0) {");
  fprintf(fp_2,"%s\n","  return y;");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n"," else {");
  fprintf(fp_2,"%s\n","  return (y = rand()/((double) RAND_MAX));");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n","}");
 }
 if(srndff_int == 1)
 {
  /*  Calls: RANDOMIZE(num_expression) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern void RANDOMIZE(long n)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," srand(n % 65536);");
  fprintf(fp_2,"%s\n","}");
 }
 if(timerff_int == 1)
 {
  /*  Calls: x = TIMER() */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern double TIMER()");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," struct timeval tv;");
  fprintf(fp_2,"%s\n"," struct timezone tz;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," gettimeofday(&tv, &tz);");
  fprintf(fp_2,"%s\n"," return ((tv.tv_sec % 86400)+tv.tv_usec/(double)1000000);");
  fprintf(fp_2,"%s\n","}");
 }
 if(dateff_int == 1)
 {
  /*  Calls: a_S = DATE_S[(i)] */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *DATE_S(int i)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," static struct tm *tp;");
  fprintf(fp_2,"%s\n"," long elapse_time;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s\n"," time(&elapse_time);");
  fprintf(fp_2,"%s\n"," tp=localtime(&elapse_time);");
  fprintf(fp_2,"%s\n"," switch (i) {");
  fprintf(fp_2,"%s%s%s%s%s\n","  case 1:  strftime(w__S[j__S],LMAX,",d_S,"%d.%m.%Y",d_S,",tp);");
  fprintf(fp_2,"%s\n","  break;");
  fprintf(fp_2,"%s%s%s%s%s\n","  case 2:  strftime(w__S[j__S],LMAX,",d_S,"%d/%m/%Y",d_S,",tp);");
  fprintf(fp_2,"%s\n","  break;");
  fprintf(fp_2,"%s%s%s%s%s\n","  case 3:  strftime(w__S[j__S],LMAX,",d_S,"%d-%b-%Y",d_S,",tp);");
  fprintf(fp_2,"%s\n","  break;");
  fprintf(fp_2,"%s\n","  case 4:  strcpy(w__S[j__S],asctime(tp));");
  fprintf(fp_2,"%s\n","           w__S[j__S][strlen(w__S[j__S])-1]='\\0';");
  fprintf(fp_2,"%s\n","  break;");
  fprintf(fp_2,"%s%s%s%s%s\n","  default: strftime(w__S[j__S],LMAX,",d_S,"%m-%d-%Y",d_S,",tp);");
  fprintf(fp_2,"%s\n","  break;");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(timeff_int == 1)
 {
  /*  Calls: a_S = TIME_S[(i)] */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *TIME_S(int i)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," static struct tm *tp;");
  fprintf(fp_2,"%s\n"," long elapse_time;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s\n"," time(&elapse_time);");
  fprintf(fp_2,"%s\n"," tp=localtime(&elapse_time);");
  fprintf(fp_2,"%s%s%s%s%s\n"," strftime(w__S[j__S],LMAX,",d_S,"%H:%M:%S",d_S,",tp);");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(inkeyff_int == 1 && tflg_int == 0)
 {
  /*  Calls:  INKEY_S() */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char  *INKEY_S(void)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int  i, len;");
  fprintf(fp_2,"%s\n"," static char b[33];");
  if(Iflag_int)
  {
   fprintf(fp_2,"%s\n"," fd_set rfds;");
   fprintf(fp_2,"%s\n"," struct timeval tv;");
   fprintf(fp_2,"%s\n"," int retval;");
  }
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," input_mode();");
  if(Iflag_int)
  {
   fprintf(fp_2,"%s\n"," FD_ZERO(&rfds);");
   fprintf(fp_2,"%s\n"," FD_SET(0, &rfds);");
   fprintf(fp_2,"%s\n"," tv.tv_sec = 0;");
   fprintf(fp_2,"%s\n"," tv.tv_usec = 10000;");
   fprintf(fp_2,"%s\n"," retval = select(1, &rfds, NULL, NULL, &tv);");
   fprintf(fp_2,"%s\n"," if (retval) {");
   fprintf(fp_2,"%s\n","  len=read(0,b,32);");
   fprintf(fp_2,"%s\n"," } else {");
   fprintf(fp_2,"%s\n","  b[0]='\\0';");
   fprintf(fp_2,"%s\n","  system_mode();");
   fprintf(fp_2,"%s\n","  return (b);");
   fprintf(fp_2,"%s\n"," }");
  }
  else
  {
   fprintf(fp_2,"%s\n"," while((len=read(0,b,32)) < 1);");
  }
  fprintf(fp_2,"%s\n"," b[len]='\\0';");
  fprintf(fp_2,"%s\n"," system_mode();");
  fprintf(fp_2,"%s\n"," if(b[0] == 3) exit(0);");
  fprintf(fp_2,"%s\n"," i = 1;");
  fprintf(fp_2,"%s\n"," while (b[i] != 27 && b[i] != '\\0' && i < len) i++;");
  fprintf(fp_2,"%s\n"," if (b[i] == 27) len = i;");
  fprintf(fp_2,"%s\n"," b[len]='\\0';");
  fprintf(fp_2,"%s\n"," for(i = 0; i <= 21; i++)");
  fprintf(fp_2,"%s\n"," if(memcmp(b, keyb__S[i], len) == 0) return (keyq__S[i]);");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," return (b);");
  fprintf(fp_2,"%s\n","}");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","int system_mode(void)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n","    if (ioctl(0, TCSETA, &term_orig) == -1) {");
  fprintf(fp_2,"%s\n","        return (0);");
  fprintf(fp_2,"%s\n","    }");
  fprintf(fp_2,"%s\n","    fcntl(0, F_SETFL, kbdflgs);");
  fprintf(fp_2,"%s\n","}");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","int input_mode(void)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n","    static struct termio term;");
  fprintf(fp_2,"%s\n","    static int flags;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","    if (ioctl(0, TCGETA, &term) == -1) {");
  fprintf(fp_2,"%s\n","        return (-1);");
  fprintf(fp_2,"%s\n","    }");
  fprintf(fp_2,"%s\n","    (void) ioctl(0, TCGETA, &term_orig);");
  fprintf(fp_2,"%s\n","    term.c_iflag = 0;");
  fprintf(fp_2,"%s\n","    term.c_oflag = 0;");
  fprintf(fp_2,"%s\n","    term.c_lflag = 0;");
  fprintf(fp_2,"%s\n","    term.c_cc[VMIN] = 1;");
  fprintf(fp_2,"%s\n","    term.c_cc[VTIME] = 0;");
  fprintf(fp_2,"%s\n","    if (ioctl(0, TCSETA, &term) == -1) {");
  fprintf(fp_2,"%s\n","        return (-1);");
  fprintf(fp_2,"%s\n","    }");
  fprintf(fp_2,"%s\n","    kbdflgs = fcntl(0, F_GETFL, 0);");
  fprintf(fp_2,"%s\n","    flags = fcntl(0, F_GETFL);");
  fprintf(fp_2,"%s\n","    flags &= ~O_NDELAY;");
  fprintf(fp_2,"%s\n","    fcntl(0, F_SETFL, flags);");
  fprintf(fp_2,"%s\n","    return (0);");
  fprintf(fp_2,"%s\n","}");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","int keybd__init(void)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," FILE *filep;");
  fprintf(fp_2,"%s\n"," int i;");
  fprintf(fp_2,"%s\n"," char w_S[LMAX];");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s%s%s%s%s\n"," strcpy(w_S,getenv(",d_S,"HOME",d_S,"));");
  fprintf(fp_2,"%s%s%s%s%s\n"," strcat(w_S,",d_S,"/.kbcalib",d_S,");");
  fprintf(fp_2,"%s%s%s%s%s\n"," if((filep=fopen(w_S, ",d_S,"r",d_S,")) == NULL)");
  fprintf(fp_2,"%s%s%s%s%s\n"," { printf(",d_S,"Cant open file %s ! No default !\\n",d_S,", w_S);");
  fprintf(fp_2,"%s\n","   return -1; }");
  fprintf(fp_2,"%s\n"," for(i = 0; i <= 21; i++) {");
  fprintf(fp_2,"%s\n","  fgets(keyb__S[i], 8, filep);");
  fprintf(fp_2,"%s\n","  keyb__S[i][strlen(keyb__S[i])-1]='\\0';");
  fprintf(fp_2,"%s\n","  keyq__S[i][0]=1; }");
  fprintf(fp_2,"%s\n"," for(i = 0; i <= 9; i++) {");
  fprintf(fp_2,"%s\n","  keyq__S[i][1]=59+i; }");
  fprintf(fp_2,"%s\n"," keyq__S[10][1]=133; keyq__S[11][1]=134; keyq__S[12][1]=82;");
  fprintf(fp_2,"%s\n"," keyq__S[13][1]=71;  keyq__S[14][1]=73;  keyq__S[15][1]=83;");
  fprintf(fp_2,"%s\n"," keyq__S[16][1]=79;  keyq__S[17][1]=81;  keyq__S[18][1]=72;");
  fprintf(fp_2,"%s\n"," keyq__S[19][1]=75;  keyq__S[20][1]=80;  keyq__S[21][1]=77;");
  fprintf(fp_2,"%s\n"," return fclose(filep);");
  fprintf(fp_2,"%s\n","}");
 }
 if(inputff_int == 1)
 {
  /*  Calls: a_S = INPUT("Prompt...",0) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *INPUT(const char *a_S, int i)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s%s%s%s%s\n"," if(i == 0) printf(",d_S,"%s",d_S,",a_S);");
  fprintf(fp_2,"%s%s%s%s%s\n"," if(i == 1) printf(",d_S,"%s? ",d_S,",a_S);");
  fprintf(fp_2,"%s\n"," fgets(tws__S,255,stdin);");
  fprintf(fp_2,"%s\n"," tws__S[strlen(tws__S)-1]='\\0';");
  fprintf(fp_2,"%s\n"," return tws__S;");
  fprintf(fp_2,"%s\n","}");
 }
 if(colorff_int == 1)
 {
  /*  Calls: COLOR((int) fg, (int) bg) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern int COLOR(int fg, int bg)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int col, att;");
  fprintf(fp_2,"%s\n"," char a_S[32];");
  fprintf(fp_2,"%s%s%s%s%s\n"," if (bg>=0) { printf(",d_S,"\\033[0;%dm",d_S,",40+(bg % 8));}");
  fprintf(fp_2,"%s%s%s%s%s\n"," else { printf(",d_S,"\\033[0m",d_S,");}");
  fprintf(fp_2,"%s\n"," fg = fg % 32;");
  fprintf(fp_2,"%s%s%s%s%s\n"," if (fg <= 7) { printf(",d_S,"\\033[%dm",d_S,",30+fg); }");
  fprintf(fp_2,"%s%s%s%s%s\n"," if ( 7 < fg && fg <= 15) { printf(",d_S,"\\033[1;%dm",d_S,",22+fg); }");
  fprintf(fp_2,"%s%s%s%s%s\n"," if (15 < fg && fg <= 23) { printf(",d_S,"\\033[5;%dm",d_S,",14+fg); }");
  fprintf(fp_2,"%s%s%s%s%s\n"," if (23 < fg) { printf(",d_S,"\\033[1;5;%dm",d_S,",6+fg); }");
  fprintf(fp_2,"%s\n","}");
 }
 if(clsff_int == 1)
 {
  /*  Calls: CLS((int) n_int) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern int CLS(int n)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int i;");
  fprintf(fp_2,"%s%s%s%s%s\n"," if (n == 0) printf(",d_S,"\\033[2J\\033[H",d_S,");");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s%s%s%s%s\n"," { printf(",d_S,"\\033[H",d_S,");");
  fprintf(fp_2,"%s%s%s%s%s\n","   for (i=1; i<=24; i++) printf(",d_S,"\\033[%d;0;f\\033[K",d_S,",i);");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n","}");
 }
 if(existff_int == 1)
 {
  /*  Calls: EXISTS( file$ ) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern int EXISTS(char *file_S)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s%s%s%s%s\n"," if(fopen(file_S, ",d_S,"r",d_S,") == NULL) return 0;");
  fprintf(fp_2,"%s\n"," return 1;");
  fprintf(fp_2,"%s\n","}");
 }
 if(lcaseff_int == 1)
 {
  /*  Calls: LCASE$( text$ ) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *LCASE_S(char *text_S)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int i=0; char c;");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s\n"," while((c=text_S[i]) != '\\0') {");
  fprintf(fp_2,"%s\n","  w__S[j__S][i++] = tolower(c);");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n"," w__S[j__S][i] = '\\0';");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(ucaseff_int == 1)
 {
  /*  Calls: UCASE$( text$ ) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *UCASE_S(char *text_S)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int i=0; char c;");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s\n"," while((c=text_S[i]) != '\\0') {");
  fprintf(fp_2,"%s\n","  w__S[j__S][i++] = toupper(c);");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n"," w__S[j__S][i] = '\\0';");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(envff_int)
 {
 }
 if(lofff_int)
 {
 }
 if(hexff_int)
 {
  /* Calls: a$ = HEX$(1024) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *HEX_S(unsigned long kc)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," unsigned long k, mask = 15;");
  fprintf(fp_2,"%s\n"," int c, i = 0;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," k = kc; if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s%s%s%s%s\n"," if(k == 0) { strcpy(w__S[j__S],",d_S,"0",d_S,"); }");
  fprintf(fp_2,"%s\n"," else {");
  fprintf(fp_2,"%s\n","  while(k > 0) {");
  fprintf(fp_2,"%s\n","   if((c = k & mask) <= 9) { w__S[j__S][15-i] = '0'+c; }");
  fprintf(fp_2,"%s\n","   else { w__S[j__S][15-i] = 'A'+c-10; }");
  fprintf(fp_2,"%s\n","   k = k / 16; i++;");
  fprintf(fp_2,"%s\n","  }");
  fprintf(fp_2,"%s\n","  memmove(w__S[j__S], &w__S[j__S][16-i], i+1);");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(octff_int)
 {
  /* Calls: a$ = OCT$(1024) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *OCT_S(unsigned long kc)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int i = 0;");
  fprintf(fp_2,"%s\n"," unsigned long k;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," k = kc; if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s%s%s%s%s\n"," if(k == 0) { strcpy(w__S[j__S],",d_S,"0",d_S,"); }");
  fprintf(fp_2,"%s\n"," else {");
  fprintf(fp_2,"%s\n","  w__S[j__S][16] = '\\0';");
  fprintf(fp_2,"%s\n","  while(k > 0) {");
  fprintf(fp_2,"%s\n","   w__S[j__S][15-i] = '0'+(k & (unsigned long)7);");
  fprintf(fp_2,"%s\n","   k = k / 8; i++;");
  fprintf(fp_2,"%s\n","  }");
  fprintf(fp_2,"%s\n","  memmove(w__S[j__S], &w__S[j__S][16-i], i+1);");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(SScan_int)
 {
  /* Calls (from C only): SScan(h_S); */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern int SScan(char *h_S)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int i=0, togfl=0, l;");
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n"," l=strlen(h_S);");
  fprintf(fp_2,"%s\n"," while(h_S[i] != '\\0') {");
  fprintf(fp_2,"%s%s%s\n","  if(h_S[i]=='",d_S,"') {");
  fprintf(fp_2,"%s\n","   togfl = 1 - togfl;");
  fprintf(fp_2,"%s\n","   memmove(&h_S[i], &h_S[i+1], l-i);");
  fprintf(fp_2,"%s\n","  } else {");
  fprintf(fp_2,"%s\n","   if(!togfl && h_S[i]==',') h_S[i]='\\t';");
  fprintf(fp_2,"%s\n","   i++;");
  fprintf(fp_2,"%s\n","  }");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n","}");
 }
 if(stringf_int)
 {
  /*  Calls: a$ = STRING$(n%, asc%) */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *STRING_S(int n, int asc)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," int i;");
  fprintf(fp_2,"%s\n"," if (++j__S == 16) j__S=0;");
  fprintf(fp_2,"%s\n"," for(i=0; i<n; i++) w__S[j__S][i] = asc;");
  fprintf(fp_2,"%s\n"," w__S[j__S][n] = '\\0';");
  fprintf(fp_2,"%s\n"," return w__S[j__S];");
  fprintf(fp_2,"%s\n","}");
 }
 if(datalin_int)
 {
  /*  Calls: System only, strcpy(a_S,READ__S(data__c_int++)); */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *READ__S(int n)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s%s%s%s%s\n"," if (n >= data__M_int) { fprintf(stderr,",d_S,"ERROR: READ passed the end of DATA !\\n",d_S,"); exit(-1); }");
  fprintf(fp_2,"%s\n"," return (DATA__S[n]);");
  fprintf(fp_2,"%s\n","}");
 }
 if(usingff_int)
 {
  /*  Calls: System only, print__using(using_S, format_S); */
  fprintf(fp_2,"\n");
  fprintf(fp_2,"%s\n","extern char *print__using(char *using_S, char *format_S)");
  fprintf(fp_2,"%s\n","{");
  fprintf(fp_2,"%s\n"," static char fmt[256], tmp[256];");
  fprintf(fp_2,"%s\n"," int i,h=0,d=0,flag=0;");
  fprintf(fp_2,"%s\n"," char c;");
  fprintf(fp_2,"%s\n"," i=0;");
  fprintf(fp_2,"%s\n"," while(c=using_S[i]) {");
  fprintf(fp_2,"%s\n","  if(c=='#') h++;");
  fprintf(fp_2,"%s\n","  if(c=='.') {flag=1; h++;}");
  fprintf(fp_2,"%s\n","  if(c=='#' && flag) d++;");
  fprintf(fp_2,"%s\n","  i++;");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n"," i=0; fmt[0]='\\0';");
  fprintf(fp_2,"%s\n"," while(c=format_S[i]) {");
  fprintf(fp_2,"%s%s%s%s%s%s%s%s%s\n","  if(c=='f') {sprintf(tmp,",d_S,"%s%s%d.%df",d_S,",fmt,",d_S,"%",d_S,",h,d); strcpy(fmt,tmp);}");
  fprintf(fp_2,"%s%s%s%s%s%s%s%s%s\n","  if(c=='s') {sprintf(tmp,",d_S,"%s%s%ds",d_S,",fmt,",d_S,"%",d_S,",h); strcpy(fmt,tmp);}");
  fprintf(fp_2,"%s%s%s%s%s\n","  if(c=='n') strcat(fmt,",d_S,"\\n",d_S,");");
  fprintf(fp_2,"%s\n","  i++;");
  fprintf(fp_2,"%s\n"," }");
  fprintf(fp_2,"%s\n"," return fmt;");
  fprintf(fp_2,"%s\n","}");
 }
}


/*- User SUB--Start -*/
int quadrix(char  *h_S)
{
/* SHARED: atmp$(), natmp%, Arrfl%, nl%, line$, isub% */
/* SHARED: dyna$(), ndyna%(), tmp$(), temp$() */

  int  i_int, togfl_int, c_int, L_int, g_int, j_int, k_int, brfl_int, brfl1_int, n_int, i1_int;
  char b_S[LMAX], d_S[LMAX], z_S[LMAX], e_S[LMAX];

  char e;
 /* Converts brackets in used arrays to square brackets. */
 /* Input string h$ is changed at the exit. */
 /* Arrfl% set -> convert parameter into integer (-A option) */
 /* If array is dynamic, change brackets accordingly */
Lab_175:   /* changes Array variable brackets from QB to C convention */
 /* 31000 must be called before, once per SUB (or MAIN) */
 /* hmm.... SUB and SHARED must be executed before; most of the others after */
 /* Improved - it will not change exp( if an array xp( is declared ! */
 sprintf(tws__S,"%s%s"," ",h_S);
 strcpy(h_S,tws__S);
 strcpy(b_S,"");
 strcpy(d_S,"");
 i_int = 1;
 togfl_int = 0;
 c_int = 0;
 L_int = 0;
 g_int = 0;
      while (i_int < strlen(h_S))
      {
       if (h_S[i_int-1] == '"') togfl_int=1-togfl_int;
       if ((c_int=h_S[i_int-1]) == '(' && togfl_int == 0)
       {
 for(j_int = 1; j_int <= natmp_int; j_int++)
 {
  strcpy(z_S,atmp_S[j_int]);
         L_int = strlen(z_S);
  if(i_int > L_int)
  {
   k_int = i_int - L_int + 1;
          if (memcmp(&h_S[k_int-1], z_S, L_int)==0) {
           g_int=0; if(k_int >= 2) g_int = h_S[k_int - 2];
   if(! (g_int > 96 && g_int < 123 || g_int > 64 && g_int < 91))
   {
    for(k_int = 1; k_int <= ndyna_int[isub_int]; k_int++)
    {
             if (memcmp(z_S, dyna_S[isub_int][k_int], L_int)==0) {
     /* GOSUB Lab_186 */ 
     if (setjmp(j__buf[j__lev++])==0) goto Lab_186;
     goto Lab_172;
             }
    }
    /* GOSUB Lab_176 */    /* GOTO 172 Done anyway */
    if (setjmp(j__buf[j__lev++])==0) goto Lab_176;
   }
          }
  }
Lab_172:
 ;}
       }
       ++i_int;
      }

 /*   Process again if flag Arrfl% set: Convert array arguments to integer. */
 /*   Based on fact [] is NOT used in BASIC. */
 if(Arrfl_int)
 {
  i_int = 0;
  togfl_int = 0;
       while ((e=h_S[++i_int]) != '\0') {
        if (e=='"') togfl_int=1-togfl_int;
        if (e=='[' && !togfl_int) {
  sprintf(h_S,"%s%s%s",LEFT_S(h_S, i_int + 1),"(int)(",MID_S(h_S, i_int + 2, LMAX));
  i_int = i_int + 7;
  brfl_int = 1;
  g_int = i_int;
         while (brfl_int && e!='\0') {
          e = h_S[++g_int];
          if (e == '[') brfl_int++;
          if (e == ']') brfl_int--;
         }
         if (e=='\0') {
  fprintf(stderr,"%s\n","qb2c: quadrix: ERROR in translation caused by -A option in");
  fprintf(stderr,"%s% d %s%s\n","line No",nl_int,":",line_S);
          exit(1);
         }
  sprintf(h_S,"%s%s%s",LEFT_S(h_S, g_int),")",MID_S(h_S, g_int + 1, LMAX));
        }
       }
 }
 gulix(h_S);
 return;

Lab_176:   /* Ugradnja kvadratnih zagrada u polja u izrazima (ne u DIM) */
 /* Ulaz: h$, i%, Izlaz: izmijenjena linija h$ i (eventualno) novi i% */
 sprintf(h_S,"%s%s%s",LEFT_S(h_S, i_int - 1),"[",MID_S(h_S, i_int + 1, LMAX));
 g_int = i_int;
 brfl1_int = 1;
      e = h_S[g_int-1];
 while(brfl1_int != 0)
 {
       if (e == ',') {
  sprintf(h_S,"%s%s%s",LEFT_S(h_S, g_int - 1),"][",MID_S(h_S, g_int + 2, LMAX));
  g_int = g_int + 1;
       }
  g_int = g_int + 1;
       e = h_S[g_int-1];
       if (e == '(') brfl1_int++;
       if (e == ')') brfl1_int--;
 }
 sprintf(h_S,"%s%s%s",LEFT_S(h_S, g_int - 1),"]",MID_S(h_S, g_int + 1, LMAX));
 /* RETURN */
 longjmp(j__buf[--j__lev],1);

Lab_186:   /* Ugradnja kvadratnih zagrada u izrazima za dinamicka polja */
 /* Ulaz: h$, i%, Izlaz: izmijenjena linija h$ i (eventualno) novi i% */
 g_int = i_int;
 brfl1_int = 1;
 while(brfl1_int != 0)
 {
       e = h_S[g_int++];
       if (e == '(') brfl1_int++;
       if (e == ')') brfl1_int--;
 }
      strcpy(b_S, &dyna_S[isub_int][k_int][L_int]); b_S[strlen(b_S)-1]='\0';
 strcpy(d_S,MID_S(h_S, i_int + 1, g_int - i_int - 1));
 tokenix(d_S, &n_int, ",", "");
 for(i1_int = 1; i1_int <= n_int; i1_int++)
 {
  strcpy(temp_S[i1_int],tmp_S[i1_int]);
 }
 tokenix(b_S, &n_int, ",", "");
 strcpy(d_S,temp_S[n_int]);
 strcpy(e_S,"");
 for(i1_int = n_int - 1; i1_int >= 1; i1_int = i1_int-1)
 {
  sprintf(tws__S,"%s%s%s%s%s",d_S,"+(",tmp_S[i1_int + 1],")*(",temp_S[i1_int]);
  strcpy(d_S,tws__S);
  sprintf(tws__S,"%s%s",e_S,")");
  strcpy(e_S,tws__S);
 }
 sprintf(h_S,"%s%s%s%s%s%s",LEFT_S(h_S, i_int - 1),"[",d_S,e_S,"]",MID_S(h_S, g_int + 1, LMAX));
 /* RETURN */
 longjmp(j__buf[--j__lev],1);
}


/*- User SUB--Start -*/
int sparser(char  *h_S, int   *z_int, char  *bin_S)
{
/* SHARED: nl% */

  int  leng_int, olen_int, i_int, bcnt_int, togfl_int, j_int, j0_int, j1_int, typ_int;
  char L_S[LMAX], R_S[LMAX], prt_S[LMAX];

  char c;
 /* finds left and right operands of binary operation 'bin$': */
 /* eg. (a + b) ^ ((a - 1) * 2) */
 /* On input z% is the position where the leftmost character of operator */
 /* appears in h$. Both h$ and z% are changed at the exit, according to bin$. */

 strcpy(L_S,"");
 strcpy(R_S,"");
 strcpy(prt_S,"");
 leng_int = LEN(h_S);
 olen_int = LEN(bin_S);
 /* Left: */
 i_int = *z_int - 1;   /* Bracket & quotes counters */
 bcnt_int = 0;
 togfl_int = 0;
 while(strcmp(MID_S(h_S, i_int, 1), " ") == 0 && i_int >= 1)
 {
  i_int = i_int - 1;
 }
 if(i_int <= 0)
 {
  fprintf(stderr,"%s%s%s% d \n","ERROR in parsing math expression: ",h_S," in line No",nl_int);
      exit(1);
 }
 j_int = i_int;
     c = h_S[j_int-1];
     if (c == '"') togfl_int = 1 - togfl_int;
     if (c == ')' && togfl_int == 0) bcnt_int++;
     while ((!(c==' ' && bcnt_int==0 || c=='(' && bcnt_int<0) || togfl_int==1) && j_int<=leng_int) {
 j_int = j_int - 1;
 if(j_int == 0)
 {
  goto Lab_197;
 }
      c = h_S[j_int-1];
      if (c == '"') togfl_int = 1 - togfl_int;
 if(togfl_int == 0)
 {
       if (c == ')') bcnt_int++;
       if (c == '(') bcnt_int--;
 }
     }
Lab_197:
 strcpy(L_S,MID_S(h_S, j_int + 1, i_int - j_int));
 j0_int = j_int;
 /* Right: */
 i_int = *z_int + olen_int;   /* Bracket & quotes counters */
 bcnt_int = 0;
 togfl_int = 0;
 while(strcmp(MID_S(h_S, i_int, 1), " ") == 0 && i_int < leng_int)
 {
  i_int = i_int + 1;
 }
 j_int = i_int;
     c = h_S[j_int-1];
     if (c == '"') togfl_int = 1 - togfl_int;
     if (c == '(') bcnt_int++;
     while ((!(c==' ' && bcnt_int==0 || c==')' && bcnt_int<0) || togfl_int==1) && j_int<=leng_int) {
 j_int = j_int + 1;
      c = h_S[j_int-1];
      if (c == '"') togfl_int = 1 - togfl_int;
 if(togfl_int == 0)
 {
       if (c == '(') bcnt_int++;
       if (c == ')') bcnt_int--;
 }
     }
 strcpy(R_S,MID_S(h_S, i_int, j_int - i_int));
 j1_int = j_int;

 /* math ^ */
 if(strcmp(bin_S, "^") == 0)
 {
  sprintf(prt_S,"%s%s%s%s%s","pow(",L_S,",",R_S,")");
  sprintf(h_S,"%s%s%s",LEFT_S(h_S, j0_int),prt_S,RIGHT_S(h_S, leng_int - j1_int + 1));
  *z_int = j0_int + LEN(prt_S);
  goto Lab_199;
 }

 /* logical = */
 if(strcmp(bin_S, "=") == 0)
 {
  vartyp(L_S, &typ_int);
  if(typ_int == 7)
  {
   fprintf(stderr,"%s% d \n","ERROR in line No",nl_int);
   fprintf(stderr,"%s%s\n","string expressions not (yet) allowed in logical: ",h_S);
       exit(1);
  }
  if(typ_int == 5 || typ_int == 15)
  {
   sprintf(h_S,"%s%s%s%s%s%s%s",LEFT_S(h_S, j0_int),"strcmp(",L_S,", ",R_S,") == 0",RIGHT_S(h_S, leng_int - j1_int + 1));
   *z_int = *z_int + 14 + LEN(R_S);
  }
  else
  {
   sprintf(h_S,"%s%s%s",LEFT_S(h_S, *z_int - 1),"==",RIGHT_S(h_S, leng_int - *z_int));
   *z_int = *z_int + 1;
  }
  goto Lab_199;
 }

 /* logical <> */
 if(strcmp(bin_S, "<>") == 0)
 {
  vartyp(L_S, &typ_int);
  if(typ_int == 7)
  {
   fprintf(stderr,"%s% d \n","ERROR in line No",nl_int);
   fprintf(stderr,"%s%s\n","string expressions not (yet) allowed in logical: ",h_S);
       exit(1);
  }
  if(typ_int == 5 || typ_int == 15)
  {
   sprintf(h_S,"%s%s%s%s%s%s%s",LEFT_S(h_S, j0_int),"strcmp(",L_S,", ",R_S,") != 0",RIGHT_S(h_S, leng_int - j1_int + 1));
   *z_int = *z_int + 14 + LEN(R_S);
  }
  else
  {
   sprintf(h_S,"%s%s%s",LEFT_S(h_S, *z_int - 1),"!=",RIGHT_S(h_S, leng_int - *z_int - 1));
   *z_int = *z_int + 1;
  }
  goto Lab_199;
 }

 if(strcmp(bin_S, "MOD") == 0)
 {
  sprintf(prt_S,"%s%s%s%s%s","((int)(.5+",L_S,")) % ((int)(.5+",R_S,"))");
  sprintf(h_S,"%s%s%s",LEFT_S(h_S, j0_int),prt_S,RIGHT_S(h_S, leng_int - j1_int + 1));
  *z_int = j0_int + LEN(prt_S);
  goto Lab_199;
 }

Lab_199:   /* End sparser */
;}


/*- User SUB--Start -*/
int splitdec(char  *varlist_S, int   *ntok_int, int   *dn_int)
{
/* SHARED: tmp$() */

  int  maxl_int, i_int, n_int, lb_int;
  char b_S[LMAX];

 /* Split too long declaration lines into pieces not longer than maxl% chars */
 /* Declaration lines are strings of tokens delimited by "," */
 maxl_int = 64;
 i_int = 1;
 *ntok_int = 0;
 *dn_int = *dn_int + 2;
 if(LEN(varlist_S) > maxl_int)
 {
  tokenix(varlist_S, &n_int, ",", "");
Lab_119:
  strcpy(b_S,"");
  lb_int = *dn_int;
  while(lb_int + LEN(tmp_S[i_int]) <= maxl_int && i_int <= n_int)
  {
   sprintf(tws__S,"%s%s%s",b_S,", ",tmp_S[i_int]);
   strcpy(b_S,tws__S);
   lb_int = lb_int + LEN(tmp_S[i_int]) + *dn_int;
   i_int = i_int + 1;
  }
  *ntok_int = *ntok_int + 1;
  strcpy(tmp_S[*ntok_int],MID_S(b_S, 3, LEN(b_S) - 2));
  if(i_int <= n_int)
  {
   goto Lab_119;
  }
 }
 else
 {
  *ntok_int = 1;
  strcpy(tmp_S[1],varlist_S);
 }
}


/*- User SUB--Start -*/
int stringx(char  *h_S)
{
  int  i_int, togfl_int, leng_int;
  char b_S[LMAX];

 /* String constants pretprocessor "...\.." --> "...\\..." */
 /* Called from the following processors/translators: */
 /* DO WHILE, WHILE, IF.., PRINT, PRINT #, INPUT, exp */
 i_int = 1;
 togfl_int = 0;
 leng_int = LEN(h_S);
 while(i_int <= leng_int - 1)
 {
  strcpy(b_S,MID_S(h_S, i_int, 1));
  if(ASC(b_S) == 34)
  {
   togfl_int = 1 - togfl_int;
   goto Lab_191;
  }
  if(strcmp(b_S, "\\") == 0)
  {
   sprintf(h_S,"%s%s%s",LEFT_S(h_S, i_int),"\\",RIGHT_S(h_S, leng_int - i_int));
   leng_int = 1 + leng_int;
   i_int = 1 + i_int;
  }
Lab_191:
  i_int = 1 + i_int;
 }
}


/*- User SUB--Start -*/
int tokenix(char  *h_S, int   *ntok_int, char  *sep_S, char  *sep2_S)
{
/* SHARED: tmp$() */

  int  brfl_int, togfl_int, leng_int, i_int, j_int;
  char z_S[LMAX], b_S[LMAX];

      char b;
 /*   Tokenizes h$ with respect to separators sep$, sep2$. */
 /*   Separator , is special: a,,b  gives 3 tokens: "a", "", "b" (ex. for LINE) */
 /*   Returns list of ntok% bare (gulix !) tokens in tmp$(), h$ unchanged. */
 *ntok_int = 0;
 brfl_int = 0;
 togfl_int = 0;
 sprintf(z_S,"%s%s",h_S,sep_S);
 leng_int = LEN(z_S);
 strcpy(b_S,"");
 if(strcmp(h_S, "") == 0)
 {
  goto Lab_169;
 }
 i_int = 0;
 j_int = 1;
      while (i_int < leng_int)
      {
       b = z_S[i_int];
       if (b == 34) { togfl_int = 1 - togfl_int; goto Lab_168; }
       if (! togfl_int)
       {
        if (b == '(') { brfl_int++; goto Lab_168; }
        if (b == ')') { brfl_int--; goto Lab_168; }
       }
       if((b==sep_S[0] || b==sep2_S[0]) && !brfl_int && !togfl_int)
       {
        if (i_int + 1 - j_int > 0 || b == ',') {
 strcpy(b_S,MID_S(z_S, j_int, i_int + 1 - j_int));
 gulix(b_S);
 *ntok_int = *ntok_int + 1;
 strcpy(tmp_S[*ntok_int],b_S);
 if(*ntok_int > TMAX)
 {
  fprintf(stderr,"%s\n","qb2c: tokenix: Dimension of tmp$() too small. Enlarge TMAX and recompile qb2c!");
          exit(1);
 }
        }
 j_int = i_int + 2;
       }
Lab_168:
 i_int = i_int + 1;
      }
Lab_169:
;}


/*- User SUB--Start -*/
int varpost(char  *line_S)
{
/* SHARED: stripff% */

  int  lleng_int, i_int, togfl_int, tmpfl_int, g_int, brcnt_int, n_int;
  char z_S[LMAX], d_S[LMAX];

   char b_S[10], b, c, t;
 /* (post)processing i% -> i_int, i& -> i_long, c$ -> c_S */
 /* and array brackets (except in declarations which is done). */
 /* Also handles MID$(a$,i%) -> MID_S(a_S,i_int,LMAX) */
 /* This works a line at the time: line$ is input and output */
       t = 32;
 lleng_int = LEN(line_S);
 i_int = 1;
 togfl_int = 0;
 tmpfl_int = 0;
 while(i_int <= lleng_int)
 {
  strcpy(z_S,MID_S(line_S, i_int, 2));
        b = line_S[i_int-1];
        if (b == 34) togfl_int = 1 - togfl_int;
  if(togfl_int == 0)
  {
         if (strncmp(&line_S[i_int-1],"/*",2)==0) { tmpfl_int=1; goto Lab_205;}
         if (strncmp(&line_S[i_int-1],"*/",2)==0) { tmpfl_int=0; goto Lab_205;}
  }
  if(togfl_int == 0 && tmpfl_int == 0)
  {
         if (b=='$')
         {
          if (i_int >= 4)
          {
   if(strcmp(MID_S(line_S, i_int - 3, 4), "MID$") == 0)
   {
    g_int = i_int + 2;
    brcnt_int = 1;
            while (brcnt_int > 0)
            {
             c = line_S[g_int];
             g_int++;
             if (c == '(') brcnt_int++;
             if (c == ')') brcnt_int--;
            }
    strcpy(d_S,MID_S(line_S, i_int + 2, g_int - i_int - 2));
    tokenix(d_S, &n_int, ",", "");
    if(n_int == 2)
    {
     sprintf(line_S,"%s%s%s%s%s",LEFT_S(line_S, i_int - 1),"_S(",d_S,", LMAX",MID_S(line_S, g_int, LMAX));
     lleng_int = lleng_int + 7;
     i_int = i_int + 1;
     goto Lab_205;
    }
    else
    {
     sprintf(line_S,"%s%s%s",LEFT_S(line_S, i_int - 1),"_S",MID_S(line_S, i_int + 1, LMAX));
     lleng_int = lleng_int + 1;
     i_int = i_int + 1;
     goto Lab_205;
    }
   }
   else
   {
    sprintf(line_S,"%s%s%s",LEFT_S(line_S, i_int - 1),"_S",MID_S(line_S, i_int + 1, LMAX));
    lleng_int = lleng_int + 1;
    i_int = i_int + 1;
    goto Lab_205;
   }
          }
          else
          {
   sprintf(line_S,"%s%s%s",LEFT_S(line_S, i_int - 1),"_S",MID_S(line_S, i_int + 1, LMAX));
   lleng_int = lleng_int + 1;
   i_int = i_int + 1;
   goto Lab_205;
          }
         }
         if( 95<=t && t<=122 || 65<=t && t<=90 || 48<=t && t<=57)
         {
          if (b=='%')
          {
           b_S[0]='\0'; c=-1; if(stripff_int==0) {strcpy(b_S,"_int"); c=3;}
           line_S[i_int-1]='\0'; strcpy(tws__S, line_S); strcat(tws__S, b_S);
           strcat(tws__S, &line_S[i_int]); strcpy(line_S, tws__S);
           lleng_int = lleng_int + c; i_int = i_int + c;
   goto Lab_205;
          }
          else
          {
           if ( b=='&' )
           {
            b_S[0]='\0'; c=-1; if(stripff_int==0) {strcpy(b_S,"_long"); c=4;}
   sprintf(line_S,"%s%s%s",LEFT_S(line_S, i_int - 1),b_S,MID_S(line_S, i_int + 1, LMAX));
            lleng_int = lleng_int + c; i_int = i_int + c;
   goto Lab_205;
           }
           else
           {
            if ( b=='#' )
            {
             b_S[0]='\0'; c=-1; if(stripff_int==0) {strcpy(b_S,"_double"); c=6;}
   sprintf(line_S,"%s%s%s",LEFT_S(line_S, i_int - 1),b_S,MID_S(line_S, i_int + 1, LMAX));
             lleng_int = lleng_int + c; i_int = i_int + c;
   goto Lab_205;
            }
            else
            {
             if ( b=='?' )
             {
              b_S[0]='\0'; c=-1; if(stripff_int==0) {strcpy(b_S,"_byte"); c=4;}
   sprintf(line_S,"%s%s%s",LEFT_S(line_S, i_int - 1),b_S,MID_S(line_S, i_int + 1, LMAX));
              lleng_int = lleng_int + c; i_int = i_int + c;
   goto Lab_205;
             }
            }
           }
          }
         }
  }
Lab_205:
       t = b; i_int++;
 }
}


/*- User SUB--Start -*/
int vartyp(char  *token_S, int   *ttyp_int)
{
/* SHARED: intflg%, Dflg%, doblflg%, longflg%, constfl% */
/* SHARED: tcnst$(), ncnst%, defstr%, defint%, defdbl% */

  int  ad_int, leng_int, ilog_int, jlog_int, i_int, expf_int, strf_int, brfl_int, togfl_int;
  char tok_S[LMAX];

   static char cx, b, ct;
 /* Determins the type 'ttyp%' of the token being variable or array: */
 /* Takes into account intflg%, doblflg%, longflg% and defstr% flags. */
 /* defxxx% flags (should) have the highest priority and override others */
 /* Constants (eg 321.) are either typ%=2 (no decimal dot) or typ%=4. */
 /* constfl% = 1 => it is a constant of a given type. */
 /* ttyp% = 0 => undecided. */
 /* tok$ must be ran through 'gulix'. */
 /*         1 => int */
 /*         2 => long */
 /*         3 => float */
 /*         4 => double */
 /*         5 => string */
 /*         6 => numerical expression */
 /*         7 => string expression */
 /*         8 => byte (unsigned char) */
 /*         9 => signed short int (2 byte) */
 /*        10 => array of signed short int (2 byte) or function */
 /*        11 => array of int     or function */
 /*        12 => array of long    or function */
 /*        13 => array of float   or function */
 /*        14 => array of double  or function */
 /*        15 => array of strings or function */
 /*        18 => array of bytes (unsigned chars) */
 /*        20 => declared CONSTant number */
 /*        25 => declared CONSTant string  NOT YET */
 /*       >30 => pointer of a type typ%-30 NOT YET (710, locally) */
 /* variable types when intflg% or Dflg% flag set */
 /* -i: i,j,k,l,m,n  (upper or lower case, if not $) are implicit 'int' type */
 /* -d: d (upper or lower case, if not $) are implicit 'double' type */
 /* sorting variable types (default): */
 *ttyp_int = 0;
 constfl_int = 0;
 ad_int = 0;
 leng_int = LEN(token_S);
 ilog_int = 0;   /* For -c or -d flags set */
 jlog_int = 0;
 /* Eliminate eventual brackets: */
    if (token_S[0]=='(' && token_S[leng_int-1]==')') {
     strcpy(tok_S, &token_S[1]); tok_S[leng_int=strlen(tok_S)-1]='\0';
    } else {
 strcpy(tok_S,token_S);
    }
 /* strip leading + - */
    i_int = 0; ct = tok_S[0];
    while (ct && (ct=='-' || ct=='+' || ct==' ')) {tok_S[i_int] = ' '; ct = tok_S[++i_int]; }
 gulix(tok_S);
 leng_int = LEN(tok_S);
 if(leng_int == 0)
 {
  goto Lab_149;
 }
 for(i_int = 1; i_int <= ncnst_int; i_int++)
 {
  if(strcmp(tok_S, tcnst_S[i_int]) == 0)
  {
   *ttyp_int = 20;
   goto Lab_149;
  }
 }
 /* Test for expression: */
 expf_int = 0;
 strf_int = 0;
 brfl_int = 0;
 togfl_int = 0;
 if(leng_int == 1)
 {
  goto Lab_147;
 }
 for(i_int = 1; i_int <= leng_int; i_int++)
 {
      cx = tok_S[i_int - 1];
      if (cx == 34) togfl_int = 1 - togfl_int;
  if(togfl_int == 0)
  {
       if ( cx == '(' ) brfl_int = brfl_int + 1;
       if ( cx == ')' ) brfl_int = brfl_int - 1;
  }
  if(brfl_int == 0 && togfl_int == 0)
  {
       if (cx == '$') strf_int = 1;
       if ( cx == 34 ) { strf_int = 1; constfl_int = 1; }
       if ( cx == 32 ) expf_int =1;
       if ( cx == '+') expf_int =1;
  }
 }
 if(expf_int == 1 && strf_int == 0)
 {
  *ttyp_int = 6;
     ct = toupper(tok_S[0]);
     if(ct >= 'A' && ct <= 'Z' && def__str[ct - 'A']) *ttyp_int = 7;
  goto Lab_149;
 }
 if(expf_int == 1 && strf_int == 1)
 {
  *ttyp_int = 7;
  goto Lab_149;
 }
Lab_147:
 if(VAL(tok_S) != 0 || strcmp(LEFT_S(tok_S, 1), "0") == 0)
 {
  constfl_int = 1;
  i_int = 1;
     cx = tok_S[0];
     while ( cx != '.' && cx != '!' && i_int < leng_int )
     {
      i_int++;
      cx = tok_S[i_int - 1];
     }
     if (cx == '.')
     {
       *ttyp_int = 3;
     }
     else
     {
      if (cx == '!')
      {
       *ttyp_int = 3;
       tok_S[i_int - 1] = '.';
      }
      else
      {
       *ttyp_int = 1;
      }
     }
  goto Lab_149;
 }
Lab_146:
    cx = tok_S[leng_int-1]; i_int = leng_int;
    if (cx == ')')
    {
 i_int = 1;
 ad_int = 10;
     while (tok_S[i_int] != '(') i_int++;
     cx = tok_S[i_int - 1];
    }
 if(intflg_int == 1)
 {
     b = tok_S[0];
     if((b >= 105 && b <= 110 || b >= 73 && b <= 78) && cx != '&' && cx != '$')
     {
  ilog_int = 1;
     }
 }
 if(Dflg_int == 1)
 {
     if (tok_S[0] == 68 || tok_S[0] == 100)
     {
  jlog_int = 1;
     }
 }
    if (cx == '%' || ilog_int == 1)
    {
 *ttyp_int = 1;
     if (ad_int == 10 && i_int >= 3 && tok_S[i_int-2] == '_') *ttyp_int = 9;
     if (i_int >= 3 && tok_S[i_int-2] == '_') *ttyp_int = 9;
    }
    else
    {
     if (cx == '$' || cx == 34)
     {
 *ttyp_int = 5;
     }
     else
     {
      if (cx == '&')
      {
 *ttyp_int = 2;
      }
      else
      {
       if (cx == '?')
       {
 *ttyp_int = 8;
       }
       else
       {
        if (cx == '#' || jlog_int == 1)
        {
 *ttyp_int = 4;
        }
        else
        {
 *ttyp_int = 3;
        }
       }
      }
     }
    }
 if(defstr_int && *ttyp_int == 3)
 {
     if(toupper(tok_S[0]) >= 'A' && toupper(tok_S[0]) <= 'Z') {
      if(def__str[toupper(tok_S[0]) - 'A'] && *ttyp_int == 3) *ttyp_int = 5;
     }
 }
 if(defint_int && *ttyp_int == 3)
 {
     if(toupper(tok_S[0]) >= 'A' && toupper(tok_S[0]) <= 'Z') {
      if(def__int[toupper(tok_S[0]) - 'A'] && *ttyp_int == 3) *ttyp_int = 1;
     }
 }
 if(defdbl_int && *ttyp_int == 3)
 {
     if(toupper(tok_S[0]) >= 'A' && toupper(tok_S[0]) <= 'Z') {
      if(def__dbl[toupper(tok_S[0]) - 'A'] && *ttyp_int == 3) *ttyp_int = 4;
     }
 }
 *ttyp_int = *ttyp_int + ad_int;
 if(*ttyp_int == 13)
 {
     if (memcmp(tok_S,"LEN(",4)==0 || memcmp(tok_S,"ASC(",4)==0 || memcmp(tok_S,"EOF(",4)==0 || memcmp(tok_S,"XLEN(",5)==0) *ttyp_int=11;
     if (memcmp(tok_S,"Int(",4)==0 || memcmp(tok_S,"Nint(",5)==0 || memcmp(tok_S,"LOF(",4)==0) *ttyp_int=12;
 }
 if(*ttyp_int == 3)
 {
  /*  IF tok$ = "TIMER" THEN ttyp% = 13: Sredjeno u 650 */
  if(strcmp(tok_S, "RND") == 0)
  {
   *ttyp_int = 14;
  }
 }
 if(longflg_int == 1)
 {
     switch(*ttyp_int) {
          case  1: *ttyp_int = 2;
                   break;
          case 11: *ttyp_int =12;
                   break;
     }
 }
 if(doblflg_int == 1)
 {
     switch(*ttyp_int) {
          case  3: *ttyp_int = 4;
                   break;
          case 13: *ttyp_int =14;
                   break;
     }
 }
Lab_149:   /* End vartyp */
;}


/*- User SUB--Start -*/
int helpm()
{
 fprintf(stderr,"%s\n","-i or -int  => implicit integers i*,j*,k*,l*,m*,n* or upper case");
 fprintf(stderr,"%s\n","-d or -double => all floats -> double");
 fprintf(stderr,"%s\n","-c64 or -C64 => C-64 specific syntax, switches on -b flag also");
 fprintf(stderr,"%s\n","-p or -post => do not perform postprocessing varnames");
 fprintf(stderr,"%s\n","-l or -long => all integers (except short)-> long");
 fprintf(stderr,"%s\n","-b or -bcpp => insensitive to case & spacing in QBASIC text");
 fprintf(stderr,"%s\n","-a or -ansi => OBSOLETE and NOT USED");
 fprintf(stderr,"%s\n","-c or -C    => allows C text lines commented with 'C '");
 fprintf(stderr,"%s\n","-m or -M    => disallow logical expr. in math. expression");
 fprintf(stderr,"%s\n","-w          => AND, OR operate bitwise");
 fprintf(stderr,"%s\n","-t or -T    => INKEY_S is dead (<termios.h> etc. not specified)");
 fprintf(stderr,"%s\n","-I          => INKEY_S is of sample type (no internal loop)");
 fprintf(stderr,"%s\n","-n or -N    => To supress SHELL command interpreter: all cmds literal");
 fprintf(stderr,"%s\n","-u          => Do not update SCREEN after every LINE, PSET, etc.");
 fprintf(stderr,"%s\n","-s          => Strip type sufixes from variable and function names");
 fprintf(stderr,"%s\n","-D          => implicit doubles d*, D*");
 fprintf(stderr,"%s\n","-r          => integer fractions became double: '/' -> '/ (double)'");
 fprintf(stderr,"%s\n","-v          => print version and exit");
 fprintf(stderr,"%s\n","-g          => print debug messages (expert)");
 fprintf(stderr,"%s\n","-A          => convert array arguments to integer as in true BASIC");
 fprintf(stderr,"%s\n","-L          => set LMAX other than default (1024), must be 1-32767");
 fprintf(stderr,"%s\n","-P          => treat PRINT as print to the current graphics screen NOT OPERATIONAL");
 fprintf(stderr,"%s\n","-col        => default LINE color is the foreground (else the last set color)");
 fprintf(stderr,"%s\n","-B          => maximum compliance with BASIC: -A -r -b -P -I -col -w");
 fprintf(stderr,"%s\n","-h, -?      => print this help message");
}
/*- User SUBs--End -*/

/* Translates of used QB's intrinsic functions: */

extern char *SPACE_S(int n)
{
 int i;

 if (++j__S == 16) j__S=0;
 if (n < 0) n = 0;
 strcpy(w__S[j__S],"");
 for(i = 1; i <= n; i++)
 {
  strcat(w__S[j__S]," ");
 }
 return w__S[j__S];
}

extern char *MID_S(char *a_S, int start, int length)
{

 if (++j__S == 16) j__S=0;
 if(length < 0) { 
  printf("Error: in MID_S: length < 0\n");
  exit(0); }
 if(start  < 0) {
  printf("Error: in MID_S: start < 1\n");
  exit(0); }
 if(start > strlen(a_S)) 
 { w__S[j__S][0]='\0'; }
 else
 { strncpy(w__S[j__S], &a_S[start-1], length);
   w__S[j__S][length]='\0'; }

 return w__S[j__S];
}

extern char *LEFT_S(char *a_S, int length)
{

 if (++j__S == 16) j__S=0;
 if(length < 0) { 
  printf("Error: in LEFT_S: length < 0\n");
  exit(0); }
 strncpy(w__S[j__S], a_S, length);
 w__S[j__S][length]='\0';

 return w__S[j__S];
}

extern char *RIGHT_S(char *a_S, int length)
{
 int  start;

 if (++j__S == 16) j__S=0;
 if ((start = strlen(a_S) - length) < 0) start = 0;
 if (length < 0) {
  printf("Error: in RIGHT_S: length < 0\n");
  exit(0); }
 strncpy(w__S[j__S], &a_S[start], length);
 w__S[j__S][length]='\0';

 return w__S[j__S];
}

extern char *STR_S(double d)
{

 if (++j__S == 16) j__S=0;
 sprintf(w__S[j__S],"% G",d);
 return w__S[j__S];
}

extern char *CHR_S(int i)
{

 if (++j__S == 16) j__S=0;
 w__S[j__S][0]=i;
 w__S[j__S][1]='\0';
 return w__S[j__S];
}

extern long ASC(char *c_S)
{
 if (++i__l == 16) i__l=0;
 if((w__l[i__l]=c_S[0]) < 0) w__l[i__l]=256+w__l[i__l];
 return w__l[i__l];
}

extern double VAL(char *a_S)
{
 if (++i__d == 16) i__d = 0;
 w__d[i__d] = atof(a_S);
 return w__d[i__d];
}

extern int LEN(char *a_S)
{
 if (++i__d == 16) i__d = 0;
 w__d[i__d] = strlen(a_S);
 return w__d[i__d];
}

extern long Nint(double x)
{
 return floor(0.5 + x); 
}

extern int eof(FILE *stream)
{
 static int c, istat;

 istat=((c=fgetc(stream))==EOF);
 ungetc(c,stream);
 return istat; 
}

extern char *COMMAND_S(int n_arg_int, char *argv_S[])
{
 int i;

 if (++j__S == 16) j__S=0;
 for(i = 1; i <= n_arg_int; i++)
 {
  strcat(w__S[j__S],argv_S[i]);
  strcat(w__S[j__S]," ");
 }
 w__S[j__S][strlen(w__S[j__S])-1]='\0';
 return w__S[j__S];
}

extern double DBL(double d)
{
 if (++i__d == 16) i__d = 0;
 w__d[i__d] = d;
 return w__d[i__d];
}

extern void RANDOMIZE(long n)
{
 srand(n % 65536);
}

extern double TIMER()
{
 struct timeval tv;
 struct timezone tz;

 gettimeofday(&tv, &tz);
 return ((tv.tv_sec % 86400)+tv.tv_usec/(double)1000000);
}

extern char *TIME_S(int i)
{
 static struct tm *tp;
 long elapse_time;

 if (++j__S == 16) j__S=0;
 time(&elapse_time);
 tp=localtime(&elapse_time);
 strftime(w__S[j__S],LMAX,"%H:%M:%S",tp);
 return w__S[j__S];
}

extern int EXISTS(char *file_S)
{
 if(fopen(file_S, "r") == NULL) return 0;
 return 1;
}
